<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>tinykv project2b文档翻译和关键点标注</title>
    <url>/2024/05/05/tinykv%20project2B_doc_translation/</url>
    <content><![CDATA[<span id="more"></span>

<p>这几天想写tinykv project2B的思路，但是感觉内容太多不知道从何处写起。思来想去觉得可以先翻译一下project2B的文档，将比较关键的地方标注出来。</p>
<hr>
<h2 id="B部分"><a href="#B部分" class="headerlink" title="B部分"></a>B部分</h2><p>在这一部分中，您将使用 A 部分中实现的 Raft 模块构建一个容错的键值存储服务。你的键&#x2F;值服务将是一个复制的状态机，由几个使用 Raft 进行复制的键&#x2F;值服务器组成。只要大多数服务器处于活动状态并且可以通信，键&#x2F;值服务就应继续处理客户端请求，即使存在其他故障或网络分区。</p>
<p>在 project1 中，您已经实现了一个独立的 kv 服务器，因此您应该已经熟悉 kv 服务器 <code>Storage</code>​ 的API 和接口。</p>
<p>在介绍代码之前，您需要先了解三个术语：<code>Store</code>​, <code>Peer</code>​ and <code>Region</code>​，以及<code>proto/proto/metapb.proto</code>​中定义的术语。</p>
<ul>
<li>Store 代表 tinykv-server 的实例</li>
<li>Peer 代表运行在 Store 上的 Raft 节点</li>
<li>Region 是 Peers 的集合，也称为 Raft Group（<mark><strong>Region将键空间以范围range划分，是实现Project3 MuitiRaft的关键概念，Project2中默认只有一个Region</strong></mark>）</li>
</ul>
<p>​![image](tinykv project2B_doc_translation&#x2F;image-20240505150015-qwdhuaz.png)​</p>
<p>为简单起见，project2 的 Store 上只有一个 Peer 节点，集群中只有一个 Region。因此，您现在无需考虑 Region 的范围。Project3 中将进一步引入多个 Region。</p>
<h3 id="the-Code"><a href="#the-Code" class="headerlink" title="the Code"></a>the Code</h3><p>首先，您应该看看<code>kv/storage/raft_storage/raft_server.go</code>​中的<code>RaftStorage</code>​，其也实现了<code>Storage</code>​接口。与<code>StandaloneStorage</code>​直接写入或读取底层引擎不同，它首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后对底层引擎进行实际的写入和读取。通过这种方式，可以保持多个<code>Stores</code>​之间的一致性。</p>
<p>​<code>RaftStorage</code>​创建一个<code>Raftstore</code>​驱动 Raft。在调用<code>Reader</code>​or<code>Write</code>​函数时，它实际上会通过通道（通道为<code>raftWorker</code>​的<code>raftCh</code>​）向 raftstore 发送一个定义在<code>proto/proto/raft_cmdpb.proto</code>​中的<code>RaftCmdRequest</code>​和四种基本命令类型（Get&#x2F;Put&#x2F;Delete&#x2F;Snap），<mark><strong>并在 Raft 提交并应用命令后利用回调向客户端返回响应</strong></mark>。<code>Reader</code>​和<code>Write</code>​函数的参数<code>kvrpc.Context</code>​现在很有用，它从客户端的角度携带<code>Region</code>​信息，并作为<code>RaftCmdRequest</code>​的标头传递。<mark><strong>信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否将该请求Propose到 Raft 层进行共识</strong></mark>。</p>
<p>然后，TinyKV的核心就来了——raftstore。结构有点复杂，请阅读 TiKV 参考文献，以便更好地理解设计：</p>
<ul>
<li><a href="https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore">https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore</a> （中文版，<mark><strong>非常推荐，对于整个Project2、Project3的理解有很大帮助，不过TiKV做了很多目前我们不用关心的优化，例如异步Apply、读写分离</strong></mark>）</li>
<li><a href="https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore">https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore</a> （英文版）</li>
</ul>
<p>raftstore的入口是<code>Raftstore</code>​，见<code>kv/raftstore/raftstore.go</code>​。它启动了一些工作线程异步处理特定任务，其中大多数现在没有使用，因此您可以忽略它们。您需要关注的只是<code>raftWorker</code>​.（kv&#x2F;raftstore&#x2F;raft_worker.go）</p>
<p>整个过程分为两部分：raft worker 轮询<code>raftCh</code>​以获取消息，包括驱动 Raft 模块的 base tick 和作为 Raft 条目提出（proposed）Raft 命令；<mark><strong>它从 Raft 模块获取并处理 ready，处理流程包括转发 raft 消息、持久化状态、将提交的条目应用于状态机。应用后，还要将响应通过回调返回给客户端。</strong></mark></p>
<h3 id="实现peer-storage"><a href="#实现peer-storage" class="headerlink" title="实现peer storage"></a>实现peer storage</h3><p>peer storage是你通过 A 部分中的<code>Storage</code>​接口进行交互的内容，但除了 raft 日志之外，peer storage还管理其他持久化的元数据，这对于重启后恢复一致的状态机非常重要。此外，<code>proto/proto/raft_serverpb.proto</code>​中定义了三个重要状态：</p>
<ul>
<li>RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log 的 Index。</li>
<li>RaftApplyState：用于存储 Raft 应用的最后一个 Log 索引和一些截断的 Log 信息。</li>
<li>RegionLocalState：用于存储此 Store 上的 Region 信息和相应的 Peer State。Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。</li>
</ul>
<p>这些状态存储在两个 badger 实例中：raftdb 和 kvdb：</p>
<ul>
<li>raftdb 存储 Raft 日志和<code>RaftLocalState</code>​</li>
<li>kvdb 将键值数据存储在不同的列族，<code>RegionLocalState</code>​和<code>RaftApplyState</code>​中。你可以把 kvdb 看作是 Raft 论文中提到的状态机</li>
</ul>
<p>格式如下，<code>kv/raftstore/meta</code>​中提供了一些辅助函数，并用<code>writebatch.SetMeta()</code>​将它们设置为 badger。</p>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">KeyFormat</th>
<th align="left">Value</th>
<th align="left">DB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">raft_log_key</td>
<td align="left">0x01 0x02 region_id 0x01 log_idx</td>
<td align="left">Entry</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">raft_state_key</td>
<td align="left">0x01 0x02 region_id 0x02</td>
<td align="left">RaftLocalState</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">apply_state_key</td>
<td align="left">0x01 0x02 region_id 0x03</td>
<td align="left">RaftApplyState</td>
<td align="left">kv</td>
</tr>
<tr>
<td align="left">region_state_key</td>
<td align="left">0x01 0x03 region_id 0x01</td>
<td align="left">RegionLocalState</td>
<td align="left">kv</td>
</tr>
</tbody></table>
<blockquote>
<p>您可能想知道为什么 TinyKV 需要两个 badger 实例。实际上，它可以使用一个badger来存储 raft 日志和状态机数据。分成两个实例只是为了和 TiKV 的设计保持一致。</p>
</blockquote>
<p>应在<code>PeerStorage</code>​中创建和更新这些元数据。创建 PeerStorage 时，请参见<code>kv/raftstore/peer_storage.go</code>​。它初始化此 Peer 的 RaftLocalState、RaftApplyState，或者在重启时从底层引擎获取上一个值。请注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值均为 5（只要它大于 1），但不是 0。之所以不将其设置为 0，是为了与 Peer 在 conf 更改后被动创建的情况区分开来。你现在可能还不太明白，所以只要记住它，当你实现conf change时，细节将在project3b中描述。</p>
<p>这部分需要实现的代码只有一个函数：<code>PeerStorage.SaveReadyState</code>​，这个函数的作用是将<code>raft.Ready</code>​中的数据保存到 badger存储引擎（<mark><strong>kvdb和raftdb，Project2C ​<code>ApplySnapshot</code>会涉及kvdb</strong></mark>）中，包括<code>Append</code>​日志条目（<mark><strong>即持久化 Raft 日志到 raftdb</strong></mark>）和保存 Raft HardState。</p>
<p>要<code>Append</code>​日志条目，只需将在<code>raft.Ready.Entries</code>​中的所有日志条目保存到 raftdb 中，并删除之前追加的日志条目，这些条目永远不会被提交。另外，更新peer storage的<code>RaftLocalState</code>​并将其保存到 raftdb。</p>
<p>保存<code>hard state</code>​也非常简单，只需更新 peer storage的<code>RaftLocalState.HardState</code>​并将其保存到 raftdb 即可。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>用<code>WriteBatch</code>​一次保存这些状态。</li>
<li>有关如何读取和写入这些状态，请参阅<code>peer_storage.go</code>​中的其他函数。</li>
<li>设置环境变量 LOG_LEVEL&#x3D;debug，这可能有助于您进行调试，另请参阅所有可用的<a href="https://github.com/talent-plan/tinykv/blob/course/log/log.go">日志级别</a>。</li>
</ul>
</blockquote>
<h3 id="Implement-Raft-ready-process"><a href="#Implement-Raft-ready-process" class="headerlink" title="Implement Raft ready process"></a>Implement Raft ready process</h3><p>在 project2 的 A 部分中，您构建了一个基于 tick 的 Raft 模块。现在，您需要编写外部进程来驱动它。大多数代码已经在<code>kv/raftstore/peer_msg_handler.go</code>​和<code>kv/raftstore/peer.go</code>​下实现。<mark><strong>所以你需要学习代码并完成<code>proposeRaftCommand</code>和<code>HandleRaftReady</code>​的逻辑</strong></mark>。以下是对该框架的一些解释。</p>
<p>Raft <code>RawNode</code>​已经使用<code>PeerStorage</code>​创建并存储在<code>peer</code>​中。在 raft worker 中，您可以看到它包含了<code>peer</code>​，采用<code>peerMsgHandler</code>​将其封装 。主要有两个功能：一个是<code>HandleMsg</code>​，另一个是<code>HandleRaftReady</code>​。</p>
<p>​<code>HandleMsg</code>​处理从 raftCh 接收到的所有消息，包括<code>MsgTypeTick</code>​ （调用<code>RawNode.Tick()</code>​来驱动Raft），<code>MsgTypeRaftCmd</code>​包装来自客户端的请求，以及<code>MsgTypeRaftMessage</code>​ Raft 对等节点之间传输的消息。所有消息类型都在<code>kv/raftstore/message/msg.go</code>​中定义。您可以查看它的详细信息，其中一些将在以下部分中使用。</p>
<p>消息处理完毕后，Raft 节点应该会有一些状态更新。<mark><strong>所以<code>HandleRaftReady</code>应该从 Raft 模块中获取 Ready 并执行相应的操作，例如持久化日志条目、应用已提交的条目并通过网络向其他 Peer 节点发送 Raft 消息</strong></mark>。</p>
<p>在伪代码中，raftstore 使用 Raft，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-s.Ticker:</span><br><span class="line">    Node.Tick()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> Node.HasReady() &#123;</span><br><span class="line">      rd := Node.Ready()</span><br><span class="line">      saveToStorage(rd.State, rd.Entries, rd.Snapshot)</span><br><span class="line">      send(rd.Messages)</span><br><span class="line">      <span class="keyword">for</span> _, entry := <span class="keyword">range</span> rd.CommittedEntries &#123;</span><br><span class="line">        process(entry)</span><br><span class="line">      &#125;</span><br><span class="line">      s.Node.Advance(rd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述伪代码的<code>default</code>​分支大致展示了<code>HandleRaftReady</code>​的处理流程。</p>
</blockquote>
<p>因此，读取或写入的整个过程将是这样的：</p>
<ul>
<li>客户端调用 RPC RawGet&#x2F;RawPut&#x2F;RawDelete&#x2F;RawScan</li>
<li>RPC 处理程序调用<code>RaftStorage</code>​相关方法</li>
<li>​<code>RaftStorage</code>​向 raftstore 发送 Raft 命令请求，等待响应</li>
<li>​<code>RaftStore</code>​将 Raft 命令请求作为 Raft 日志<code>Propose</code>​给 Raft 层</li>
<li>Raft 模块<code>Append</code>​日志，并使用<code>PeerStorage</code>​进行持久化</li>
<li>Raft 模块提交日志（该日志被大多数节点接受）</li>
<li>Raft worker 在处理 Raft ready 时应用 Raft 命令，并通过 callback 返回响应</li>
<li>​<code>RaftStorage</code>​接收来自回调的响应并返回到 RPC 处理程序</li>
<li>RPC 处理程序执行一些操作并将 RPC 响应返回给客户端</li>
</ul>
<p>您应该运行<code>make project2b</code>​以通过所有测试。整个测试运行一个模拟集群，包括多个具有模拟网络的 TinyKV 实例。它执行一些读取和写入操作，并检查返回值是否符合预期。</p>
<p>需要注意的是，错误处理是通过测试的重要组成部分。您可能已经注意到<code>proto/proto/errorpb.proto</code>​其中定义了一些错误，并且该错误是 gRPC 响应的一个字段。此外，实现<code>error</code>​接口的相应错误在<code>kv/raftstore/util/error.go</code>​中定义，因此您可以将它们用作函数的返回值。</p>
<p>这些错误主要与 Region 有关。所以它也是<code>RaftResponseHeader</code>​ of <code>RaftCmdResponse</code>​的成员。<mark><strong>在 Propose 请求或应用命令时</strong></mark>，可能会出现一些错误。如果是这样，你应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。您可以使用<code>kv/raftstore/cmd_resp.go</code>​提供的​<code>BindRespError</code>​将这些错误转换为在返回带有错误的响应时定义的错误。</p>
<p>在此阶段，您可以考虑以下这些错误，其他错误将在 project3 中处理：</p>
<ul>
<li>ErrNotLeader：在 follower 上 Propose raft 命令。因此，使用它来让客户端尝试将请求发送给其他 Peer。</li>
<li>ErrStaleCommand：可能是由于领导者更改，某些日志未提交并被新的领导者日志覆盖。但客户并不知道这一点，仍在等待响应。因此，您应该返回此命令以让客户端知道并重试该命令。</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>​<code>PeerStorage</code>​实现了 Raft 模块的<code>Storage</code>​接口，你应该使用提供的<code>SaveReadyState()</code>​方法来持久化 Raft 相关的状态。</li>
<li>使用<code>engine_util</code>​中的<code>WriteBatch</code>​以原子方式进行多次写入，例如，<mark><strong>您需要确保在一个<code>WriteBatch</code>中应用已提交的条目并更新<code>Applied</code>索引（这两个写入不要分开来做）</strong></mark>。</li>
<li>用<code>Transport</code>​向其他 Peer 节点发送 raft 消息，它在<code>GlobalContext</code>​中</li>
<li>如果服务器不是多数服务器的一部分，并且没有最新数据，则不应完成 get RPC。你可以直接将 get 操作放入 raft 日志中，或者实现 Raft 论文第 8 节中描述的只读操作的优化（<mark><strong>建议先完成最基本的功能，再考虑实现各种优化</strong></mark>）。</li>
<li>在应用日志条目时，不要忘记更新并保留<code>ApplyState</code>​。</li>
<li>你可以像 TiKV 一样异步应用已提交的 Raft 日志条目。这不是必需的，尽管提高性能是一个很大的挑战。</li>
<li>Propose时记录命令的回调，应用后返回回调。</li>
<li>对于 snap 命令响应，应将 badger Txn 显式设置为回调。</li>
<li><mark><strong>在 2A 之后采用随机测试，您可能需要多次运行某些测试以查找错误</strong></mark></li>
</ul>
</blockquote>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project1思路</title>
    <url>/2024/05/02/tinykv_project1_solution/</url>
    <content><![CDATA[<span id="more"></span>
<p>project1是一个热身项目，内容非常简单。项目文档中提到需要实现两部分的内容：（1）独立存储引擎；（2）原始kv服务处理程序。下面分别介绍一下基本的思路。</p>
<h2 id="独立存储引擎"><a href="#独立存储引擎" class="headerlink" title="独立存储引擎"></a>独立存储引擎</h2><p>文档中提到该任务是对badgerDB的读写API的封装以支持列族（Column Family, CF）。通过运行<code>grep -rIi &quot;Your Code Here (1).&quot;</code>​发现需要编写的代码主要在<code>kv/storage/standalone_storage/standalone_storage.go</code>​，需要实现：</p>
<ol>
<li>定义<code>StandAloneStorage</code>​的数据结构</li>
<li>定义<code>NewStandAloneStorage</code>​函数，根据参数<code>Config</code>​创建一个<code>StandAloneStorage</code>​对象</li>
<li>填充<code>Start, Stop, Reader, Write</code>​四个函数</li>
</ol>
<h3 id="​StandAloneStorage​​​的定义和新建"><a href="#​StandAloneStorage​​​的定义和新建" class="headerlink" title="​StandAloneStorage​​​的定义和新建"></a>​<code>StandAloneStorage</code>​​​的定义和新建</h3><p>根据项目文档，engine_util包 （<code>kv/util/engine_util</code>​）中提供了所有的读写操作，即需要封装的API。但是我们并不知道它们在哪里，<code>kv/util/engine_util/doc.go</code>​中给出了一些信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">* engines: a data structure <span class="keyword">for</span> keeping engines required by unistore.</span><br><span class="line">* write_batch: code to batch writes into a single, atomic <span class="string">&#x27;transaction&#x27;</span>.</span><br><span class="line">* cf_iterator: code to iterate over a whole column family in badger.</span><br></pre></td></tr></table></figure>

<p>从命名和描述可以看出engines是存储引擎、write_batch是将多个写入整合到一个batch中，cf_iterator则是在badger中迭代列族。</p>
<p>再来看具体的文件。</p>
<p>​<code>kv/util/engine_util/engines.go</code>​中定义了<code>Engines</code>​类，包含了两个<code>badger.DB</code>​的指针，还提供了<code>NewEngines</code>​、<code>WriteKV</code>​、<code>WriteRaft</code>​、<code>Close</code>​、<code>Destroy</code>​、<code>CreateDB</code>​这些函数。很显然<code>StandAloneStorage</code>​是对<code>Engines</code>​的封装，需要包含一个<code>engine_util.Engines</code>​成员，<code>NewStandAloneStorage</code>​需要进行<code>CreateDB</code>​和<code>NewEngines</code>​两个步骤。<code>Start</code>​不需要修改，<code>Stop</code>​需要调用<code>en.Close()</code>​;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engines <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Data, including data which is committed (i.e., committed across other nodes) and un-committed (i.e., only present</span></span><br><span class="line">	<span class="comment">// locally).</span></span><br><span class="line">	Kv     *badger.DB</span><br><span class="line">	KvPath <span class="type">string</span></span><br><span class="line">	<span class="comment">// Metadata used by Raft.</span></span><br><span class="line">	Raft     *badger.DB</span><br><span class="line">	RaftPath <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StandAloneStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your Data Here (1).</span></span><br><span class="line">	en *engine_util.Engines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>关于Write的实现，文档告诉我们参数<code>ctx *kvrpcpb.Context</code>​暂时不用管，只剩下一个参数<code>batch []storage.Modify</code>​，可知是接口<code>Modify</code>​类型切片，通过观察类定义和相关函数发现，<code>Modify</code>​中可以是类型为<code>Put</code>​或<code>Delete</code>​类型的<code>Data</code>​，使用<code>.Key().Cf().Value()</code>​取对应的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Modify <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Put <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   []<span class="type">byte</span></span><br><span class="line">	Value []<span class="type">byte</span></span><br><span class="line">	Cf    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delete <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key []<span class="type">byte</span></span><br><span class="line">	Cf  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Modify)</span></span> Key() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Put:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Put).Key</span><br><span class="line">	<span class="keyword">case</span> Delete:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Delete).Key</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Modify)</span></span> Value() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> putData, ok := m.Data.(Put); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> putData.Value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Modify)</span></span> Cf() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Put:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Put).Cf</span><br><span class="line">	<span class="keyword">case</span> Delete:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Delete).Cf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们在<code>Write</code>​中需要做的应该是：声明一个空的<code>WriteBatch wb</code>，然后遍历参数<code>batch</code>​，提取每一个<code>key,val,cf</code>​，使用辅助函数添加到<code>wb</code>中；遍历结束后调用<code>en.WriteKV</code>​实现写入。</p>
<p>通过阅读<code>kv/util/engine_util/write_batch.go</code>​可知要用到的辅助函数是类<code>WriteBatch</code>​的<code>SetCF</code>​和<code>DeleteCF</code>​接口。</p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>​<code>Reader</code>​方法返回一个<code>StorageReader</code>​接口，要求实现<code>GetCF()、IterCF()、Close()</code>​三个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StorageReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// When the key doesn&#x27;t exist, return nil for the value</span></span><br><span class="line">	GetCF(cf <span class="type">string</span>, key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">	IterCF(cf <span class="type">string</span>) engine_util.DBIterator</span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档中说应该使用<code>badger.Txn</code>​来实现<code>Reader</code>​函数，但是<code>badger.Txn</code>​并没有<code>GetCF()、IterCF()、Close()</code>​这三个方法，因此不能满足<code>StorageReader</code>​接口的要求（go语言接口<code>interface</code>的限制），我们要对其进行封装。</p>
<p>我这里定义了一个<code>StandAloneStorageReader</code>​类，包含了一个<code>badger.Txn</code>​成员，分别使用<code>engine_util.GetCFFromTxn</code>​、<code>engine_util.NewCFIterator</code>​、<code>txn.Discard</code>​实现了<code>GetCF()、IterCF()、Close()</code>​。在<code>Reader</code>​中只需要调用<code>en.Kv.NewTransaction</code>​创建一个<code>txn</code>​，然后返回一个<code>StandAloneStorageReader</code>​即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandAloneStorage)</span></span> Reader(ctx *kvrpcpb.Context) (storage.StorageReader, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (1).</span></span><br><span class="line">	txn := s.en.Kv.NewTransaction(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span> &amp;StandAloneStorageReader&#123;</span><br><span class="line">		txn: txn,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StandAloneStorageReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	txn *badger.Txn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现服务处理程序"><a href="#实现服务处理程序" class="headerlink" title="实现服务处理程序"></a>实现服务处理程序</h2><p>需要实现的代码在<code>kv/server/raw_api.go</code>​当中，需要实现<code>RawGet</code>​、<code>RawPut</code>​、<code>RawDelete</code>​、<code>RawScan</code>​。前三个都很简单，没有需要自己寻找或设计的数据结构，部分接口需要查找，不过都是可以根据参数和成员得到的。</p>
<p>​<code>RawScan</code>​函数主要是要弄清它的功能：从<code>startkey</code>​开始，取至多<code>limit</code>​个<code>kvPairs</code>​。</p>
<p>这样就知道需要用<code>Reader</code>​的迭代器，首先<code>Seek</code>​到<code>StartKey</code>​的位置，然后取至多<code>limit</code>​个<code>kvPairs</code>​。</p>
<p>​<code>iter</code>​的使用方式参考：<code>iter-&gt;Seek(StartKey)</code>​ –&gt;<code>iter-&gt;Valid()</code>​ –&gt;<code>iter.Next()</code>​</p>
<h2 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h2><p>出现一个问题</p>
<p>​<img src="/2024/05/02/tinykv_project1_solution/image-20231116204912-q20bqqq.png" alt="image">​</p>
<p>查看测试代码，发现当KeyNotFound时要求err返回nil</p>
<p>​<img src="/2024/05/02/tinykv_project1_solution/image-20231116204940-tsx3alt.png" alt="image">​</p>
<p>解决后成功通过！完成 project 1！</p>
<p>​<img src="/2024/05/02/tinykv_project1_solution/image-20231116213243-xxct0mn.png" alt="image">​</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project2a思路</title>
    <url>/2024/05/03/tinykv_project2a_solution/</url>
    <content><![CDATA[<span id="more"></span>

<p>project2需要实现一个基于raft算法的高可用kv服务器。根据文档，有三部分需要完成，包括：</p>
<ul>
<li>A：实现基本的 Raft 算法</li>
<li>B：在 Raft 之上构建容错 KV 服务器</li>
<li>C：新增 raftlog GC 和 snapshot 支持</li>
</ul>
<p>Project2A主要任务是实现Raft算法。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>非常建议先阅读一遍raft论文再来做project2A，不然在很多概念的理解上都会很吃力。一个非常有帮助的链接：</p>
<p><a href="https://raft.github.io/">Raft Consensus Algorithm</a></p>
<p>‍</p>
<h2 id="aa选举和ab日志复制"><a href="#aa选举和ab日志复制" class="headerlink" title="aa选举和ab日志复制"></a>aa选举和ab日志复制</h2><p>这一部分主要实现Raft层进行共识（实现一致性）的逻辑，主要代码在<code>raft/log.go</code>​和<code>raft/raft.go</code>​当中。</p>
<h3 id="Raft和RaftLog类定义"><a href="#Raft和RaftLog类定义" class="headerlink" title="Raft和RaftLog类定义"></a>Raft和RaftLog类定义</h3><p>如题目中所说，<code>raft.Raft</code>​提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。</p>
<p>Raft类定义解析如下：</p>
<ul>
<li>id：节点id</li>
<li>Term：任期</li>
<li>Vote：当前任期投票给了谁</li>
<li>RaftLog：缓存日志条目</li>
<li>Prs：用于leader维护各节点日志复制的进度（Match代表已经匹配的Index，Next代表即将发送的下一个Index）</li>
<li>State：节点状态</li>
<li>votes：记录投票信息</li>
<li>msgs：需要发送的消息，消息分本地消息（本节点处理）和普通消息</li>
<li>Lead：只想当前的leader</li>
<li>heartbeatTimeout：心跳超时</li>
<li>electionTimeout：选举超时</li>
<li>heartbeatElapsed：记录距上次心跳超时经过的时间，用于判断是否心跳超时</li>
<li>electionElapsed：记录，用于判断是否选举超时</li>
<li>leadTransferee、PendingConfIndex：在3A领导权转移和配置变更中使用，此处忽略</li>
</ul>
<p>结合Raft算法的要求，我增加了以下成员：</p>
<ol>
<li>randElectTimeout：随机选举超时，必需，减少选举失败。</li>
<li>voteCount：当前票数，不必需</li>
<li>denialCount：当前拒绝投票数，不必需，方便统计</li>
</ol>
<p>‍</p>
<p>​<code>raft.RaftLog</code>​是一个辅助结构体，主要用于raft节点缓存日志条目，通过<code>raft/storage.go</code>​中定义的<code>Storage</code>​接口与上层应用进行交互，能够获取日志条目和快照等持久化数据。</p>
<p>RaftLog类定义解析如下：</p>
<ul>
<li><p>storage：存储了自从上次快照以来的所有stable的日志条目，stable指已经持久化了。storage中还提供了获取初始状态、FirstIndex、LastIndex等信息的接口，初始化需要用到。</p>
</li>
<li><p>applied、committed、stabled是非常重要的三个索引：分别代表已应用的、已提交的、已持久化的日志条目的最大索引，所有的日志条目的索引有如下关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  snapshot/first.....applied....committed....stabled.....last</span></span><br><span class="line"><span class="comment">//  --------|------------------------------------------------|</span></span><br><span class="line"><span class="comment">//                            log entries</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
<li><p>entries：所有还未compact的日志条目，这里compact的含义暂时忽略。</p>
</li>
<li><p>pendingSnapshot：在2C中使用，暂时忽略。</p>
</li>
</ul>
<p>参考代码中storage具有一个dummy entry的设计（题目也有说明：默认第一次启动raft时应具有条目 0），为RaftLog增加一个成员：</p>
<ul>
<li>dummyIndex：第一个日志的索引，用于方便计算下标位置</li>
</ul>
<h3 id="原理和数据处理流程"><a href="#原理和数据处理流程" class="headerlink" title="原理和数据处理流程"></a>原理和数据处理流程</h3><p>上面提到的日志条目实际上是代表某个操作的条目（例如<code>put、get</code>​等），tinykv首先要对这些操作的条目利用raft算法进行共识，只有在集群内大多数节点“接受”了某个操作，这个操作才会被“应用”到存储引擎中进行实际的数据操作。Raft模块就是维护集群在这些操作条目上的一致性，进而上层应用可以执行相同的操作，实现数据一致性。</p>
<p>如题目所述，Raft模块的处理流程都是由上层应用通过调用<code>RawNode</code>​（RawNode是对Raft的封装）的各个接口来异步推进的。</p>
<ol>
<li>上层应用负责通过调用<code>RawNode.Tick()</code>​来推进Raft节点的逻辑时钟，从而推进选举和leader发送心跳。</li>
<li>上层应用通过调用<code>RawNode.Step()</code>​来推动Raft节点处理消息，Raft节点只需要把消息推送到<code>raft.Raft.msgs</code>​中，在<code>raft.Raft.Step()</code>​中实现消息处理的逻辑。</li>
<li>上层应用通过调用<code>RawNode.Propose()</code>​向raft节点发送新的日志条目。</li>
<li>通过<code>RawNode.Ready()</code>​来获取raft节点的各项状态更新，据此进行消息转发、持久化、实际数据操作等。</li>
<li>通过<code>RawNode.Advance()</code>​来更新raft节点的内部状态，如应用的索引、稳定日志索引等。</li>
<li>。。。</li>
</ol>
<p>在project2A中，我们只需要理解：</p>
<p>上层的 RawNode 会定时调用 <code>tick()</code>​，驱动 Raft，同时如果有消息，则通过 <code>Step()</code>​ 函数传递给 Raft。然后 Raft 进行一系列的处理。将需要发送给其他节点的消息存放在 <code>r.msgs</code>​ 中，RawNode 会在生成 Ready 的时候取走并发送给别的节点。整个流程是线性的，<code>Tick()</code>​ 和<code>Step()</code>​ 不会被同时触发，这里不存在多线程的情况。</p>
<p>因此在2aa和2ab中，主要需要完成：</p>
<ol>
<li>针对<code>tick()</code>​的处理，即推进选举和leader发送心跳消息<code>heartbeatMsg</code>​等</li>
<li>针对<code>Step()</code>​的处理，即消息处理，按照raft算法对各种类型的消息执行相应的动作，这些消息包含本地的消息、其他节点的消息、上层发来的propose消息等。</li>
<li>辅助结构<code>RaftLog</code>​模块</li>
</ol>
<h3 id="RaftLog模块"><a href="#RaftLog模块" class="headerlink" title="RaftLog模块"></a>RaftLog模块</h3><p>首先是<code>newLog</code>​，根据参数，需要从<code>storage</code>​中获取数据来进行初始化动作。由于<code>storage</code>​中保存的是所有已经持久化但是未被应用的日志条目，因此<code>applied = firstIndex - 1</code>​，<code>stabled = lastIndex</code>​。<code>storage</code>​中保存的<code>hardState</code>​保存了<code>Term、Vote、Commit</code>​三个信息，前两个用于Raft初始化，<code>Commit</code>​用来初始化<code>RaftLog.committed</code>​。获取<code>entries</code>​的方式也很简单，<code>storage</code>​提供了<code>Entries</code>​接口，因此可以通过调用<code>Entries(firstIndex, lastIndex+1)</code>​获取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLog</span><span class="params">(storage Storage)</span></span> *RaftLog &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	firstIndex, _ := storage.FirstIndex()</span><br><span class="line">	lastIndex, _ := storage.LastIndex()</span><br><span class="line">	hardState, _, _ := storage.InitialState()</span><br><span class="line">	entries := <span class="built_in">make</span>([]pb.Entry, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> firstIndex &lt;= lastIndex &#123;</span><br><span class="line">		entries, _ = storage.Entries(firstIndex, lastIndex+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> entries == <span class="literal">nil</span> &#123;</span><br><span class="line">			entries = <span class="built_in">make</span>([]pb.Entry, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log := &amp;RaftLog&#123;</span><br><span class="line">		storage:         storage,</span><br><span class="line">		committed:       hardState.Commit,</span><br><span class="line">		applied:         firstIndex - <span class="number">1</span>, <span class="comment">// 对applied进行修正</span></span><br><span class="line">		stabled:         lastIndex,</span><br><span class="line">		entries:         entries,</span><br><span class="line">		pendingSnapshot: <span class="literal">nil</span>,</span><br><span class="line">		dummyIndex:      firstIndex,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其余函数"><a href="#其余函数" class="headerlink" title="其余函数"></a>其余函数</h4><p>​<code>unstableEntries</code>​：所有未持久化的日志，字面意思处理即可</p>
<p>​<code>nextEnts</code>​：所有已经提交但没有应用的日志<code>(applied, committed]</code>​</p>
<p>​<code>lastIndex</code>​：最后一个条目的索引</p>
<p>​<code>Term</code>​：获取指定索引的日志条目的term，注意要返回<code>ErrUnavailable</code>​错误，如果不在[firstIndex, lastIndex]，调用<code>storage.Term</code>​即可</p>
<blockquote>
<p>这一部分代码编写要十分注意几个Index的细节处理和条件判断，否则容易出现越界等错误。</p>
</blockquote>
<h3 id="Raft模块"><a href="#Raft模块" class="headerlink" title="Raft模块"></a>Raft模块</h3><h4 id="newRaft"><a href="#newRaft" class="headerlink" title="newRaft"></a>newRaft</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newRaft return a raft peer with the given config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRaft</span><span class="params">(c *Config)</span></span> *Raft &#123;</span><br><span class="line">	<span class="keyword">if</span> err := c.validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>Config</code>​提供了初始化所需的数据。值得注意的是<code>Storage</code>​，需要用它新建<code>RaftLog</code>​，获取<code>Term</code>​、<code>Vote</code>​等状态数据。另外，<code>c.peers</code>​有时会为空，这时也需要通过<code>Storage.InitialState()</code>​获取。节点初始身份为<code>follower</code>​。</p>
<h4 id="tick"><a href="#tick" class="headerlink" title="tick()"></a>tick()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tick() &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">switch</span> r.State &#123;</span><br><span class="line">	<span class="keyword">case</span> StateFollower:</span><br><span class="line">		r.tickFollower()</span><br><span class="line">	<span class="keyword">case</span> StateCandidate:</span><br><span class="line">		r.tickCandidate()</span><br><span class="line">	<span class="keyword">case</span> StateLeader:</span><br><span class="line">		r.tickLeader()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑时钟推进时，根据当前节点的身份状态选择下一步的处理。</p>
<p>对于<code>Follower</code>​和<code>Candidate</code>​，tick的作用是推进选举超时，如果一旦发现超时，首先清零选举超时，然后发起选举。这里发起选举是通过<code>Step()</code>​处理一个本地消息<code>MessageType_MsgHup</code>​触发的，后面会提到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickFollower() &#123;</span><br><span class="line">	r.electionElapsed += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> r.electionElapsed &gt;= r.randElectTimeout &#123;</span><br><span class="line">		r.electionElapsed = <span class="number">0</span></span><br><span class="line">		r.Step(pb.Message&#123;From: r.id, To: r.id, MsgType: pb.MessageType_MsgHup&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickCandidate() &#123;</span><br><span class="line">	r.electionElapsed += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> r.electionElapsed &gt;= r.randElectTimeout &#123;</span><br><span class="line">		r.electionElapsed = <span class="number">0</span></span><br><span class="line">		r.Step(pb.Message&#123;From: r.id, To: r.id, MsgType: pb.MessageType_MsgHup&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>Leader</code>​，tick的作用是触发心跳超时。如果发现超时，同样清零以后再广播心跳给其他节点<code>BroadCastHeartBeat</code>​，这里广播心跳也是通过<code>Step()</code>​处理一个本地消息<code>MessageType_HeartBeat</code>​触发的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickLeader() &#123;</span><br><span class="line">	r.heartbeatElapsed += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> r.heartbeatElapsed &gt;= r.heartbeatTimeout &#123;</span><br><span class="line">		r.heartbeatElapsed = <span class="number">0</span></span><br><span class="line">		r.Step(pb.Message&#123;From: r.id, To: r.id, MsgType: pb.MessageType_MsgBeat&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="身份转换becomexxx"><a href="#身份转换becomexxx" class="headerlink" title="身份转换becomexxx"></a>身份转换becomexxx</h4><p>根据Raft算法，节点有三个身份状态：<code>follower</code>​、<code>candidate</code>​、<code>leader</code>​。一个顺利的选举流程的身份转换过程通常是：<code>follower-&gt;candidate-&gt;leader</code>​，其余情况大多都是切换回<code>follower</code>​。</p>
<p>在身份转换时要对raft节点的一些数据进行更改。</p>
<p>对于<code>becomefollower</code>​，需要更新<code>Vote</code>​、<code>State</code>​、<code>Term</code>​、<code>Lead</code>​，清空<code>votes</code>​、<code>leadTransferee</code>​，重置两个超时时间，最后随机化选举超时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// becomeFollower transform this peer&#x27;s state to Follower</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> becomeFollower(term <span class="type">uint64</span>, lead <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">if</span> term &gt; r.Term &#123;</span><br><span class="line">		r.Vote = None</span><br><span class="line">	&#125;</span><br><span class="line">	r.State = StateFollower</span><br><span class="line">	r.Term = term</span><br><span class="line">	r.Lead = lead</span><br><span class="line">	r.votes = <span class="literal">nil</span></span><br><span class="line">	r.voteCount = <span class="number">0</span></span><br><span class="line">	r.denialCount = <span class="number">0</span></span><br><span class="line">	r.leadTransferee = None</span><br><span class="line">	<span class="comment">// reset</span></span><br><span class="line">	r.heartbeatElapsed = <span class="number">0</span></span><br><span class="line">	r.electionElapsed = <span class="number">0</span></span><br><span class="line">	r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>becomeCandidate</code>​，根据Raft算法，要自增<code>Term</code>​，然后先投票给自己（如果当前集群只有一个节点，直接<code>becomeLeader</code>​）。也要重置超时，随机化选举超时。</p>
<p>对于<code>becomeLeader</code>​，可以看到注释里面提示：<code>// NOTE: Leader should propose a noop entry on its term</code>​，即需要向其他节点发送一条空条目，这是为了更新<code>Prs</code>​（Match代表已经匹配的Index，Next代表即将发送的下一个Index），来获取<code>follower</code>​的进度。</p>
<h3 id="step-消息处理"><a href="#step-消息处理" class="headerlink" title="step()消息处理"></a>step()消息处理</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> Step(m pb.Message) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="comment">// node is not in cluster or has been removed</span></span><br><span class="line">	<span class="keyword">switch</span> r.State &#123;</span><br><span class="line">	<span class="keyword">case</span> StateFollower:</span><br><span class="line">		<span class="keyword">return</span> r.stepFollower(m)</span><br><span class="line">	<span class="keyword">case</span> StateCandidate:</span><br><span class="line">		<span class="keyword">return</span> r.stepCandidate(m)</span><br><span class="line">	<span class="keyword">case</span> StateLeader:</span><br><span class="line">		<span class="keyword">return</span> r.stepLeader(m)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> stepFollower(m pb.Message) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.MsgType &#123;</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgHup:</span><br><span class="line">		r.handleHup()</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgPropose:</span><br><span class="line">		<span class="keyword">return</span> ErrProposalDropped</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgAppend:</span><br><span class="line">		r.handleAppendEntries(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgRequestVote:</span><br><span class="line">		r.handleRequestVote(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgSnapshot:</span><br><span class="line">		r.handleSnapshot(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgHeartbeat:</span><br><span class="line">		r.handleHeartbeat(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgTransferLeader:</span><br><span class="line">		r.handleTransferLeader(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgTimeoutNow:</span><br><span class="line">		r.handleHup()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​<code>Step</code>​结合当前节点身份状态<code>r.State</code>​和消息类型<code>MsgType</code>​选择要执行的动作。<strong>这部分是实现Raft层的重点</strong>，首先要理解各个Msg的作用以及含义。</p>
<p>文档中提到，对于一个Raft节点来说，Msg分本地消息和普通消息，其中普通消息是要发给其他节点的，要放到<code>r.msgs</code>​中供上层异步地取用；本地消息是本地发起的，因此套个<code>Step()</code>​直接进行消息处理。之前在<code>tick()</code>​中发起的就是本地消息<code>MsgHup</code>​和<code>MsgBeat</code>​</p>
<p>Raft 通过一个<code>Message</code>​结构体包含了所有种类的msg，所以其字段对于某一种msg会存在富余的情况，所以要结合raft算法来确定某一种msg设置了哪些字段，以及各个字段的作用是什么。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	MsgType              MessageType <span class="string">`protobuf:&quot;varint,1,opt,name=msg_type,json=msgType,proto3,enum=eraftpb.MessageType&quot; json:&quot;msg_type,omitempty&quot;`</span></span><br><span class="line">	To                   <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,2,opt,name=to,proto3&quot; json:&quot;to,omitempty&quot;`</span></span><br><span class="line">	From                 <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,3,opt,name=from,proto3&quot; json:&quot;from,omitempty&quot;`</span></span><br><span class="line">	Term                 <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,4,opt,name=term,proto3&quot; json:&quot;term,omitempty&quot;`</span></span><br><span class="line">	LogTerm              <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,5,opt,name=log_term,json=logTerm,proto3&quot; json:&quot;log_term,omitempty&quot;`</span></span><br><span class="line">	Index                <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,6,opt,name=index,proto3&quot; json:&quot;index,omitempty&quot;`</span></span><br><span class="line">	Entries              []*Entry    <span class="string">`protobuf:&quot;bytes,7,rep,name=entries&quot; json:&quot;entries,omitempty&quot;`</span></span><br><span class="line">	Commit               <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,8,opt,name=commit,proto3&quot; json:&quot;commit,omitempty&quot;`</span></span><br><span class="line">	Snapshot             *Snapshot   <span class="string">`protobuf:&quot;bytes,9,opt,name=snapshot&quot; json:&quot;snapshot,omitempty&quot;`</span></span><br><span class="line">	Reject               <span class="type">bool</span>        <span class="string">`protobuf:&quot;varint,10,opt,name=reject,proto3&quot; json:&quot;reject,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>      <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>       <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tinykv中Raft的所有消息类型如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MessageType_name = <span class="keyword">map</span>[<span class="type">int32</span>]<span class="type">string</span>&#123;</span><br><span class="line">	<span class="number">0</span>:  <span class="string">&quot;MsgHup&quot;</span>,</span><br><span class="line">	<span class="number">1</span>:  <span class="string">&quot;MsgBeat&quot;</span>,</span><br><span class="line">	<span class="number">2</span>:  <span class="string">&quot;MsgPropose&quot;</span>,</span><br><span class="line">	<span class="number">3</span>:  <span class="string">&quot;MsgAppend&quot;</span>,</span><br><span class="line">	<span class="number">4</span>:  <span class="string">&quot;MsgAppendResponse&quot;</span>,</span><br><span class="line">	<span class="number">5</span>:  <span class="string">&quot;MsgRequestVote&quot;</span>,</span><br><span class="line">	<span class="number">6</span>:  <span class="string">&quot;MsgRequestVoteResponse&quot;</span>,</span><br><span class="line">	<span class="number">7</span>:  <span class="string">&quot;MsgSnapshot&quot;</span>,</span><br><span class="line">	<span class="number">8</span>:  <span class="string">&quot;MsgHeartbeat&quot;</span>,</span><br><span class="line">	<span class="number">9</span>:  <span class="string">&quot;MsgHeartbeatResponse&quot;</span>,</span><br><span class="line">	<span class="number">11</span>: <span class="string">&quot;MsgTransferLeader&quot;</span>,</span><br><span class="line">	<span class="number">12</span>: <span class="string">&quot;MsgTimeoutNow&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下列表汇总了所有消息类型的描述、有效字段，以及哪些身份状态需要处理该类型的消息：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>描述</th>
<th>有效字段</th>
<th>follower</th>
<th>candidate</th>
<th>leader</th>
</tr>
</thead>
<tbody><tr>
<td>MsgHup</td>
<td>本地消息，发起选举</td>
<td>MsgType<br></td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>MsgBeat</td>
<td>本地消息，Leader广播心跳，用于检查follower进度和避免新的选举</td>
<td>MsgType</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>MsgPropose</td>
<td>本地消息，来自上层应用的Propose请求。只有Leader实际处理，其他都返回<code>ErrProposalDropped</code>​</td>
<td>MsgType Entries To</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgAppend</td>
<td>用于Leader向其他节点同步数据，即日志复制。</td>
<td>MsgType Index Term LogTerm Entries Commit To From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgAppendResponse</td>
<td>用于回复收到的 <code>MessageType_MsgAppend</code>​ 和 <code>MessageType_MsgSnapshot</code>​。Leader据此更新Match和Next等记录</td>
<td>MsgType Index Term Reject To From</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>MsgRequestVote</td>
<td>candidate发送的投票请求</td>
<td>MsgType Index Term LogTerm To From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgRequestVoteResponse</td>
<td>投票响应</td>
<td>MsgType Term Reject To From</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>MsgSnapshot</td>
<td>project2c，当 Leader 发现目标节点所需的日志已经被 compact 的时候，则发送 Snapshot。</td>
<td>MsgType Term Snapshot To From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgHeartbeat</td>
<td>来自Leader的心跳消息</td>
<td>MsgType Term To From</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MsgHeartbeatResponse</td>
<td>心跳响应，包含当前follower的Commit索引，Leader据此判断它的进度</td>
<td>MsgType Term Commit To From Reject</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>MsgTransferLeader</td>
<td>本地消息，领导权转移，Project3A</td>
<td>MsgType From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgTimeoutNow</td>
<td>目标节点收到该消息，即刻自增 term 发起选举</td>
<td>MsgType From To<br></td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
</tbody></table>
<p>下面分为领导人选举和日志复制两个部分分别介绍这些消息的处理逻辑。</p>
<h3 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h3><h4 id="handleHup"><a href="#handleHup" class="headerlink" title="handleHup"></a>handleHup</h4><p>首先，<code>follower</code>​和<code>candidate</code>​选举超时都会触发<code>MsgHup</code>​，用于直接发起选举。<code>handleHup</code>的处理逻辑如下：</p>
<ol>
<li><p>判断能否进行选举：</p>
<ol>
<li>判断自己是否在当前的 Prs 里面。因为自己可能已经被移除（Project3 涉及）。</li>
<li>判断是否有 pendingSnapshot。如果正在 applying snapshot，则不要发起选举，因为一定是其他的 leader 发给你 snapshot，如果你发起选举，你的 term+1 必定大于现有的 leader，这会造成集群的不稳定。</li>
</ol>
</li>
<li><p>​<code>becomeCandidate</code>​</p>
</li>
<li><p>向其他所有节点发送投票请求<code>MsgRequestVote</code>​</p>
</li>
</ol>
<h4 id="handleRequestVote"><a href="#handleRequestVote" class="headerlink" title="handleRequestVote"></a>handleRequestVote</h4><p>​<code>follower</code>​、<code>candidate</code>​、<code>leader</code>​都有可能收到投票请求。在Raft论文中，为了避免已经提交的日志被覆盖保障一致性，除了最基本的任期条件，还增加了一个选举限制条件，即日志的新旧条件，具体可以再看一下论文中的描述。<code>handleRequestVote</code>的处理逻辑如下：</p>
<ol>
<li>如果任期比自己大，becomeFollower<strong>（此时不一定投票给他）</strong></li>
<li>如果任期没自己大，拒绝</li>
<li>如果当前任期已经投票了，且不是他，拒绝</li>
<li>如果日志比自己旧（比较最后一个条目的Term和Index，先比较Term，相等的情况下再比较Index），拒绝，否则<code>becomefollower</code>​并且投票给他</li>
</ol>
<h4 id="handleRequestVoteResponse"><a href="#handleRequestVoteResponse" class="headerlink" title="handleRequestVoteResponse"></a>handleRequestVoteResponse</h4><p>candidate收到投票响应后：</p>
<ol>
<li>如果任期比自己大，becomeFollower，此时直接返回</li>
<li>根据<code>Reject</code>​更新<code>r.votes、r.voteCount、r.denialCount</code>​</li>
<li>如果<code>r.voteCount</code>​超过半数，直接<code>becomeLeader</code>​，选举成功；<code>r.denialCount</code>​同理，如果超过半数，直接<code>becomeFollower</code>​，选举失败。</li>
</ol>
<blockquote>
<p>注意，不能直接<code>r.voteCount++</code>​和<code>r.denialCount++</code>​记录票数，而要通过遍历<code>r.votes</code>​，因为后面3B的测试中会出现重复的响应，会出现一直选举不出来的情况。</p>
</blockquote>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>节点成为Leader后，会不断向其他节点发送心跳来维持自己的地位，并通过心跳响应来了解其他节点的日志提交的进度，进而决定是否需要同步日志给他。</p>
<h4 id="handleBeat"><a href="#handleBeat" class="headerlink" title="handleBeat"></a>handleBeat</h4><p>直接广播heartbeat</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleBroadcastHeartBeat() &#123;</span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> r.Prs &#123;</span><br><span class="line">		<span class="keyword">if</span> peer == r.id &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		r.sendHeartbeat(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleHeartbeat"><a href="#handleHeartbeat" class="headerlink" title="handleHeartbeat"></a>handleHeartbeat</h4><p>只要根据<code>Term</code>决定是否<code>Reject</code>​，返回的响应中要附带<code>Commit</code>​，方便Leader收到后进行日志同步</p>
<h4 id="handleHeartbeatResponse"><a href="#handleHeartbeatResponse" class="headerlink" title="handleHeartbeatResponse"></a>handleHeartbeatResponse</h4><p>leader在收到心跳响应后</p>
<ol>
<li>判断返回的Term是否大于当前Term，如果是则<code>becomeFollower</code>​直接返回</li>
<li>根据follower的<code>Commit</code>​信息和leader中记录的<code>Match</code>​，判断leader是否需要同步日志给他</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleHeartBeatResponse(m pb.Message) &#123;</span><br><span class="line">	<span class="keyword">if</span> m.Term &gt; r.Term &#123;</span><br><span class="line">		r.becomeFollower(m.Term, None)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if it doesn&#x27;t have update-to-date log</span></span><br><span class="line">	<span class="keyword">if</span> m.Commit &lt; r.RaftLog.committed || r.Prs[m.From].Match &lt; r.RaftLog.LastIndex() &#123;</span><br><span class="line">		r.sendAppend(m.From)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点成为Leader后，上层应用会发送日志条目给他，即<code>MsgPropose</code>​，他需要将这些条目加入到自己的<code>RaftLog</code>​当中，然后同步给其他节点。</p>
<h4 id="handlePropose"><a href="#handlePropose" class="headerlink" title="handlePropose"></a>handlePropose</h4><p>只有leader处理，如果不是leader，直接返回<code>ErrPorosalDropped</code>​。</p>
<ol>
<li>判断<code>r.leadTransferee</code>​，如果正在进行领导权转移，不能接受propose，直接返回<code>ErrPorosalDropped</code>​（Project3A）</li>
<li>将propose消息中的<code>Entries</code>​加入到<code>r.RaftLog</code>​中</li>
<li>广播Append消息给其他节点，即<strong>日志复制</strong></li>
<li>尝试更新Commit，<code>tryUpdateCommit</code>​</li>
</ol>
<h4 id="sendAppend的实现"><a href="#sendAppend的实现" class="headerlink" title="sendAppend的实现"></a>sendAppend的实现</h4><p>​<code>sendAppend(to)</code>​即发送<code>MsgAppend</code>​给节点to，有许多值得注意的地方，各字段赋值如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := pb.Message&#123;</span><br><span class="line">	MsgType: pb.MessageType_MsgAppend,</span><br><span class="line">	To:      to,</span><br><span class="line">	From:    r.id,</span><br><span class="line">	Term:    r.Term,</span><br><span class="line">	LogTerm: preLogTerm,</span><br><span class="line">	Index:   preLogIndex,</span><br><span class="line">	Entries: sendEntreis,</span><br><span class="line">	Commit:  r.RaftLog.committed,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>LogTerm、Index</code>​分别代表论文中的<code>preLogTerm、preLogIndex</code>​（<code>preLogTerm = Term(Next-1)、preLogIndex = Next-1</code>​），是进行日志匹配的关键项，根据论文中的定理，如果在next-1的位置处匹配（即Term相同），代表之前的所有日志都匹配，就可以放心地接收<code>Next</code>​往后的所有条目了。</p>
<p>​<code>Commit</code>​的作用如上所述是让其他节点也能更新自己的<code>committed</code>​。</p>
<blockquote>
<p>在project2C中，当Leader找不到<code>preLogIndex</code>​对应的日志条目时，代表它已经被Compact掉了，也代表节点to落后自己太多了，此时不再发送append消息，而是发送一个Snapshot给它。</p>
</blockquote>
<h4 id="tryUpdateCommit的实现"><a href="#tryUpdateCommit的实现" class="headerlink" title="tryUpdateCommit的实现"></a>tryUpdateCommit的实现</h4><p>Leader需要根据集群所有节点的进度更新自己的Commit同时推进其他节点的Commit，日志的提交需要满足“大多数”的条件，只有当日志被提交以后才能被上层实际应用。</p>
<p>根据Raft算法， 我们取所有<code>Match</code>​的中位数，如果有更新，则广播给其他节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tryUpdateCommit() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(r.Prs) == <span class="number">1</span> &#123;</span><br><span class="line">		r.RaftLog.committed = r.RaftLog.LastIndex()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get all match</span></span><br><span class="line">	<span class="keyword">var</span> matches []<span class="type">uint64</span></span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> r.Prs &#123;</span><br><span class="line">		<span class="keyword">if</span> peer == r.id &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		matches = <span class="built_in">append</span>(matches, r.Prs[peer].Match)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(UInt64Slice(matches))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get mid</span></span><br><span class="line">	midIndex := matches[<span class="built_in">len</span>(matches)/<span class="number">2</span>]</span><br><span class="line">	midTerm, _ := r.RaftLog.Term(midIndex)</span><br><span class="line">	<span class="comment">// if mid &gt; commit, update commit</span></span><br><span class="line">	<span class="keyword">if</span> midIndex &gt; r.RaftLog.committed &amp;&amp; midTerm == r.Term &#123;</span><br><span class="line">		r.RaftLog.committed = midIndex</span><br><span class="line">		<span class="comment">// send append to all peers</span></span><br><span class="line">		r.bcastAppend()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleAppendEntries"><a href="#handleAppendEntries" class="headerlink" title="handleAppendEntries"></a>handleAppendEntries</h4><p>这部分是实现日志复制的核心，有很多需要注意的细节。</p>
<p>我的实现步骤如下：</p>
<ol>
<li>如果比当前任期小，直接返回拒绝</li>
<li>becomeFollower()</li>
<li>如果<code>m.Index</code>​比当前节点的lastIndex要大，说明Next-1 &gt; lastIndex，显然Next要减小一点，于是直接拒绝，返回的响应中 Index &#x3D; lastIndex + 1，让 Next减小到lastIndex+1（日志复制部分要注意理解<code>r.Prs</code>​中<code>Match</code>​和<code>Next</code>​字段的含义）</li>
<li>如果<code>r.RaftLog.Term(m.Index)</code>​与<code>m.LogTerm</code>​不相同，说明在<code>m.Index</code>​处发生冲突，接下来论文中的原始做法是返回<code>Index = m.Index</code>​，从而让Next &#x3D; <code>m.Index</code>​，即Next–。优化做法是返回在<code>r.RaftLog.Term(m.Index)</code>​这一任期下该节点的第一条日志的索引<code>conflictIndex</code>​，即让Next &#x3D; <code>conflictIndex</code>​，这样能加快日志匹配的速度。</li>
<li>如果上述两种情况都没有发生，说明该节点在<code>m.Index</code>​及之前的日志与Leader都是匹配，因此可以“接受”这个Append请求。但是有一种特殊情况需要考虑，就是被append的所有日志条目<code>m.Entries</code>​已经在该节点中存在了，这时可能后面还有一些日志条目，因此不能无脑截断然后append，如果没有冲突应当要保留这些多出来的日志。我的做法是首先判断该节点在<code>m.Index</code>​往后的日志长度是否大于<code>len(m.Entries)</code>​，如果不大于则可以无脑截断然后append，如果大于，则要逐个检查是否与<code>m.Entries</code>​中的条目相匹配，满足则不做任何修改，只要一个条目有冲突都直接截断然后append。</li>
<li>accept之后，要根据<code>m.Commit</code>​对<code>r.RaftLog.committed</code>​进行更新，我的做法是<code>r.RaftLog.committed = min(m.Commit, m.Index+uint64(len(m.Entries)))</code>​</li>
<li>返回accpet的响应，注意对<code>Index</code>​的设置</li>
</ol>
<h4 id="handleAppendResponse"><a href="#handleAppendResponse" class="headerlink" title="handleAppendResponse"></a>handleAppendResponse</h4><p>根据Raft算法，当leader收到Reject Append的响应后，要更新<code>Next</code>​（回退到某个可能匹配的位置），然后重新<code>sendAppend</code>​。</p>
<p>在<code>MsgAppendResponse m</code>​中：</p>
<ol>
<li>若<code>Reject == true</code>​，<code>m.Index</code>​代表Next需要回退到的位置；</li>
<li>若<code>Reject == false</code>​，<code>m.Index</code>​代表最新匹配的位置，即新的<code>Match</code>​值。</li>
</ol>
<p>因此，具体处理流程如下：</p>
<ol>
<li>如果<code>m.Term</code>​大于当前任期，Leader直接<code>becomeFollower</code>​并返回</li>
<li>如果<code>m.Reject == true</code>​，令<code>r.Prs[m.From].Next = m.Index</code>​，重新调用<code>sendAppend</code>​</li>
<li>如果<code>m.Reject == false &amp;&amp; m.Index &gt; r.Prs[m.From].Match</code>​，说明该follower接收了新的条目，更新对应的<code>Match</code>​和<code>Next</code>​，调用<code>tryUpdateCommit</code>​尝试提交日志条目。</li>
</ol>
<p>‍</p>
<p>以上就实现了基本的领导人选举和日志复制，后面的项目还会增加<code>Snapshot</code>​、<code>TransferLeader</code>​等操作。</p>
<h3 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h3><h4 id="选举超时随机化"><a href="#选举超时随机化" class="headerlink" title="选举超时随机化"></a>选举超时随机化</h4><p>根据raft论文，每次触发选举超时都要对这个超时时间进行随机化，能够有效减少选举冲突的情况发生。我的做法是在<code>becomexxx</code>​函数，即节点状态变更的函数中都加入以下代码来进行时间重置和选举超时随机化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">r.heartbeatElapsed = 0</span><br><span class="line">r.electionElapsed = 0</span><br><span class="line">r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</span><br></pre></td></tr></table></figure>

<p>那么如何进行随机化？从哪里知道使用<code>r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</code>​，即控制在<code>[et,2et]</code>​之间呢？</p>
<p>这是从2AA的测试点<code>testNonleaderElectionTimeoutRandomized</code>​中得知的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">func testNonleaderElectionTimeoutRandomized(t *testing.T, state StateType) &#123;</span><br><span class="line">	et := 10</span><br><span class="line">	r := newTestRaft(1, []uint64&#123;1, 2, 3&#125;, et, 1, NewMemoryStorage())</span><br><span class="line">	timeouts := make(map[int]bool)</span><br><span class="line">	<span class="keyword">for</span> round := 0; round &lt; 50*et; round++ &#123;</span><br><span class="line">		switch state &#123;</span><br><span class="line">		<span class="keyword">case</span> StateFollower:</span><br><span class="line">			r.becomeFollower(r.Term+1, 2)</span><br><span class="line">		<span class="keyword">case</span> StateCandidate:</span><br><span class="line">			r.becomeCandidate()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time := 0</span><br><span class="line">		<span class="keyword">for</span> len(r.readMessages()) == 0 &#123;</span><br><span class="line">			r.tick()</span><br><span class="line">			time++</span><br><span class="line">		&#125;</span><br><span class="line">		timeouts[time] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> d := et + 1; d &lt; 2*et; d++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !timeouts[d] &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;timeout in %d ticks should happen&quot;</span>, d)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述测试代码做的事情就是进行足够多次的模拟，验证随机化的选举超时有没有覆盖<code>[et+1,2et)</code>​。由此可知随机化的具体标准。</p>
<h4 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h4><p>在2aa测试点中经常出现集群只有一个节点的情况，因此要对这种情况做特殊处理，使Candidate直接成为leader。</p>
<p>“给其他节点发送投票请求”时要注意附带<code>Term、LogTerm、Index</code>​三个字段，其中<code>LogTerm</code>​是最大日志的任期，<code>Index</code>​是最大日志的索引，其他节点可以通过它们来判断投票发起者的日志是否比自己的新，日志比自己旧那么就投反对票。这样就实现了论文中的“选举限制”，保障了安全性。</p>
<h4 id="becomeLeader"><a href="#becomeLeader" class="headerlink" title="becomeLeader"></a>becomeLeader</h4><p>​<code>becomeLeader</code>​存在一些需要特别注意的特殊处理：</p>
<ol>
<li><p>初始化<code>r.Prs</code>​，即每个节点的<code>Progress&#123;Match, Next&#125;</code>​。之前提到过是用于leader维护各节点日志复制的进度（Match代表已经匹配的Index，Next代表即将发送的下一个Index）。Match初始化为0即可，Next则要初始化为<code>r.RaftLog.LastIndex() + 1</code>​，代表后续给其他节点同步日志都先从<code>Next</code>​的位置开始，发生冲突再让对应节点的<code>Next</code>​回退。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, peer := range r.Prs &#123;</span><br><span class="line">	peer.Match = 0</span><br><span class="line">	peer.Next = r.RaftLog.LastIndex() + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据文档和代码注释中的提示“<code>Leader should propose a noop entry on its term</code>​”，也就是<code>becomeLeader</code>​时append一个在Leader任期下的一个空条目，这样做的目的是让所有节点进行一次初始的日志同步操作</p>
</li>
</ol>
<h4 id="broadCastAppend"><a href="#broadCastAppend" class="headerlink" title="broadCastAppend"></a>broadCastAppend</h4><p>我的raft实现中主要有两处要<code>broadCastAppend</code>​，一处是上面提到的<code>becomeLeader</code>​，一处是<code>handlePropose</code>​（接收来自上层的日志条目）。</p>
<p>在每次<code>broadCastAppend</code>​之后都要立即<code>tryUpdateCommit</code>​而不等待<code>AppendResponse</code>​，这是考虑了单节点这一特殊情况，否则单节点将永远无法更新自己的<code>committed</code>​。</p>
<h4 id="handleAppendEntries-1"><a href="#handleAppendEntries-1" class="headerlink" title="handleAppendEntries"></a>handleAppendEntries</h4><p>​<code>handleAppendEntries</code>​的实现一定要仔细，注意覆盖所有的条件，注意测试点中提出的要求。</p>
<p>例如，在日志匹配的前提下，对于目标节点超出<code>preLogIndex</code>​的日志条目，不能够无脑截断掉。因为这些条目很可能与即将append的条目也是完全匹配的，那么再往后多出来的部分就不能够删除掉而要保留下来，因为本质上没做任何修改。</p>
<p>例如，在日志不匹配的前提下，同样不能对目标节点的日志做任何修改。我一开始为了方便处理，对于目标节点超出<code>preLogIndex</code>​的日志条目都直接截断掉，结果很多测试出现问题。</p>
<h4 id="消息处理的幂等性"><a href="#消息处理的幂等性" class="headerlink" title="消息处理的幂等性"></a>消息处理的幂等性</h4><p>文档中有这么一句描述：</p>
<blockquote>
<p>Raft RPC是幂等的,收到相同的RPC不会由任何危害.例如，如果追随者收到一个AppendEntries请求，其中包含其日志中已经存在的日志条目，则会忽略新请求中的这些条目。</p>
</blockquote>
<p>所以我们在实现各种handle函数时，要经常考虑有重复请求的情况，例如重复的投票，重复的append消息等等。</p>
<p>‍</p>
<h3 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h3><p>2aa和2ab的测试大多数问题都可以靠错误日志发现原因。发生错误时，可以看看测试点的代码，里面可能有一些特殊的要求，对应的修改即可。</p>
<p>我在<code>testCandidateResetTerm</code>​遇到过测试卡死，通过输出发现问题原因是处理<code>Msg_Append</code>​时逻辑出错，导致日志冲突而<code>next</code>​没有发生变化，所以死循环了，一直在sendAppend。</p>
<p>这一部分问题比较多的就是<code>handleAppendEntries</code>​，我当时也是改了很多次才形成了最终的这个版本。</p>
<p>‍</p>
<h2 id="project2ac-RawNode-Ready"><a href="#project2ac-RawNode-Ready" class="headerlink" title="project2ac RawNode Ready"></a>project2ac RawNode Ready</h2><p>这一部分代码主要在<code>raft/rawnode.go</code>​，在理解了具体要求之后实现比较简单。</p>
<p><code>RawNode</code>​是对<code>Raft</code>​的一个封装，提供了Raft模块与上层交互的相关函数。</p>
<ol>
<li>​<code>Ready()</code>​：返回一个Ready类型的数据，其中包含了当前Raft节点的状态，上层应用根据Ready中的数据进行持久化、日志条目的应用等操作。</li>
<li>​<code>HasReady()</code>​：判断是否有状态更新。</li>
<li>​<code>Advance(rd Ready)</code>​：由上层应用处理完某个Ready调用，用来更新Raft节点的一些状态。</li>
</ol>
<p>首先我们需要考虑<code>RawNode</code>​的类定义中除了<code>Raft</code>​还需要什么成员。</p>
<p>​<code>Ready</code>​类定义如下：</p>
<ol>
<li>​<code>*SoftState</code>​：包含<code>Lead</code>​和<code>RaftState</code>​</li>
<li>​<code>pb.HardState</code>​：包含<code>Term</code>​、<code>Vote</code>​、<code>Commit</code>​</li>
<li>​<code>Entrise</code>​：存放还没持久化的所有条目</li>
<li>​<code>Snapshot</code>​：存放需要应用的snapshot</li>
<li>​<code>CommittedEntries</code>​：存放已经提交但是还没有被应用的日志条目</li>
<li>​<code>Messages</code>​：存放raft节点中需要转发的一些消息（RequestVote、AppendEntries等等）</li>
</ol>
<p>由上面的定义可以得知我们的<code>HasReady()</code>​需要对这6种数据进行检查，看是否有更新，后四个都只需要判断有没有即可，前两个则需要观察是否有变化，所以<code>RawNode</code>​的定义中要包含<code>prevSoftState</code>​和<code>prevHardState</code>​。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RawNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Raft *Raft</span><br><span class="line">	<span class="comment">// Your Data Here (2A).</span></span><br><span class="line">	prevSoftState *SoftState</span><br><span class="line">	prevHardState pb.HardState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<code>NewRaftNode</code>​也很简单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRawNode</span><span class="params">(config *Config)</span></span> (*RawNode, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	raft := newRaft(config)</span><br><span class="line">	rn := &amp;RawNode&#123;</span><br><span class="line">		Raft: raft,</span><br><span class="line">		prevSoftState: &amp;SoftState&#123;</span><br><span class="line">			Lead:      raft.Lead,</span><br><span class="line">			RaftState: raft.State,</span><br><span class="line">		&#125;,</span><br><span class="line">		prevHardState: pb.HardState&#123;</span><br><span class="line">			Term:   raft.Term,</span><br><span class="line">			Vote:   raft.Vote,</span><br><span class="line">			Commit: raft.RaftLog.committed,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<code>HasReady()</code>​检查是否有状态更新；<code>Ready()</code>​提取这些更新的状态数据，需要注意的是获取<code>Raft.msgs</code>​之后要clear掉，并且骨架代码中已经提供了很多辅助函数，例如<code>isHardStateEqual</code>​、<code>isEmptySnap</code>​等。</p>
<p>​<code>Advance()</code>​需要做的是更新两个索引值<code>stabled</code>​和<code>applied</code>​，同时<code>update prevSoftState、prevHardState</code>​即可。从这个函数可以看出上层对于Ready中的数据处理主要为“持久化”和“应用”两个方面。</p>
<p>‍</p>
<p>最后附上通过的截图（太长了只截取了一部分）</p>
<p>​<img src="/2024/05/03/tinykv_project2a_solution/image-20240503164749-1q2mgqe.png" alt="image">​</p>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>Tinykv，启~动！！</title>
    <url>/2024/05/01/tinykv_start/</url>
    <content><![CDATA[<p>前段时间磕磕绊绊学习了Tinykv这个项目，通过所有测试就没再理了，现在觉得不能把工夫浪费了，因此写个Blog记录一下。</p>
<h2 id="什么是Tinykv？"><a href="#什么是Tinykv？" class="headerlink" title="什么是Tinykv？"></a>什么是Tinykv？</h2><p>Tinykv是PingCAP推出的一个学习分布式系统的课程，这个公司在存储领域很厉害，比较著名的产品是TiDB。</p>
<p>Tinykv这个课程的具体内容是使用Raft共识算法构建一个具有分布式事务支持的键值存储系统，它提供了一些骨架代码，我们只需要填充其中的一些核心逻辑，例如Raft层实现共识，RaftStore实现消息处理等等。</p>
<p>整个课程有4个Project，分别为StandaloneKv、raftKv、MuiltiRaftKv、Transactions，整体难度上：porject3 &gt; project2 &gt;&gt; project4 &gt; project1。其中project2B和project3B是两个分水岭，一般都会Bug满天飞，需要打印详细的日志仔细地跟踪，并且有的Bug复现概率较低，要反复跑好几次，因此要坚持下来需要一定的毅力。</p>
<p>如果集中精力做的话，我了解到的几个同学都是暑假一个月不到的时间就完成了，整体代码量也不多，就是测试修Bug比较折磨。我当时还有学业上的别的事情，并没有太多的精力集中搞这个，从开始到完成花了有三个月，期间也是卡在2B和3B摆烂了很久。不过所幸是坚持到了最后。</p>
<p>如果时间凑巧的话，还可以报名PingCAP定期举办的tinykv学习营（<a href="https://tidb.net/talent-plan">Talent Plan | TiDB 社区</a>），能起到一定的督促作用，还能与其他同学交流经验心得，可以少踩很多坑。</p>
<p>整个课程做下来能够学到的东西还是挺多的，例如raft共识算法、分布式系统架构、多版本并发控制等等，对于想走存储、分布式系统方向的同学还是很有用处的。</p>
<p>‍</p>
<h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p>github仓库</p>
<p><a href="https://github.com/talent-plan/tinykv">talent-plan&#x2F;tinykv：基于 TiKV 模型构建分布式键值服务的课程 (github.com)</a></p>
<p>讲解视频</p>
<p><a href="https://learn.pingcap.com/learner/course/510001">Talent Plan 2021 KV 学习营分享课 (pingcap.com)</a></p>
<p>很有帮助的文章，Tinykv白皮书</p>
<p><a href="https://zhuanlan.zhihu.com/p/457696758">如何快速通关 Talent Plan TinyKV？ - 知乎 (zhihu.com)</a></p>
<p>‍</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>tinykv对硬件稍微有点要求，否则跑得太慢又Bug满天飞心态很容易炸。我是使用14核处理器，32GB内存，SSD固态的笔记本，搭配wsl2的linux环境，运行起来非常流畅。固态据说是刚需，其他感觉与这差不多的配置或者低一点也没关系。非常推荐使用wsl，可以直接连接vscode非常快，环境配起来也嘎嘎轻松；用虚拟机也可以，不过我感觉有点慢。有配置好服务器的话更好，可以一直挂着跑。</p>
<p>附上我当时配置wsl2参考的博客</p>
<p><a href="https://blog.csdn.net/syqkali/article/details/131524540">如何在Windows11上安装WSL2的Ubuntu22.04（包括换源）_wsl2换源_syqkali的博客-CSDN博客</a></p>
<p>由于项目用go实现，所以也要配置golang的运行环境，项目里还用到了make，我这里直接用apt安装即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">apt search golang-go</span><br><span class="line">sudo apt install golang-go</span><br><span class="line">go version </span><br><span class="line">sudo apt install make</span><br></pre></td></tr></table></figure>

<p>接着从github仓库下载源码，得到的就是只有骨架代码的版本了。</p>
<p>​<code>git clone https://github.com/talent-plan/tinykv.git</code>​</p>
<p>建议在github上创建一个私有仓库来维护代码，这样就知道在哪些地方做了修改，并且可以很方便地恢复了。</p>
<p>‍</p>
<h2 id="快速掌握Go语言基本语法"><a href="#快速掌握Go语言基本语法" class="headerlink" title="快速掌握Go语言基本语法"></a>快速掌握Go语言基本语法</h2><p>如果对Go语言的基本语法不熟悉，可以通过以下链接的教程快速掌握，对于Tinykv已经足够了。</p>
<p><a href="https://tour.go-zh.org/welcome/1">Go 语言之旅 (go-zh.org)</a></p>
<p>‍</p>
<h2 id="Tinykv快速上手"><a href="#Tinykv快速上手" class="headerlink" title="Tinykv快速上手"></a>Tinykv快速上手</h2><p>tinykv根目录下的doc目录存放了四个project的说明文档。文档是全英文的（如果英文不是很好的话，可以先找中文翻译了解一下大体的框架，细节上还是要看英文，有些翻译得不准会造成误解），文档介绍了每个项目的要实现的具体功能和一些细节上的要求，不过整体上文档还是不够全面，很多功能需要仔细阅读它的骨架代码才能实现。</p>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>每个project所要编写的代码的位置都给出了注释提示，可以通过grep命令找到需要编写代码的地方。</p>
<p>以project1为例，可以使用命令<code>grep -rIi &quot;Your Code Here(1)&quot;</code>​，来查找project1的项目文件以及需要编写代码的地方，主要的函数名和参数返回值都已经定义好了，只要填充其中的逻辑即可。注意project1之后的234都分成了A、B、C三部分，这时查找则是例如<code>grep -rIi &quot;Your Code Here(2A)&quot;</code>​这样。</p>
<p>​​<img src="/2024/05/01/tinykv_start/image-20240501155452-w7ey5c1.png" alt="image">​</p>
<p>当然虽然给出了主要的函数名和参数返回值，在project2和3还是要增加很多自定义的函数。</p>
<h3 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h3><p><code>make projectxxx</code></p>
<p>project2b、2c、3b、3c测试一遍是不够的，需要跑很多次才能复现一些Bug，可以使用shell脚本批量跑。</p>
<p>下面是我使用的测试脚本，只需要改运行次数times和project，removelog是在PASS的情况下删除日志。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># settings to change</span></span><br><span class="line"><span class="built_in">times</span>=20</span><br><span class="line">project=<span class="string">&quot;2b&quot;</span></span><br><span class="line">removelog=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># don&#x27;t change</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;./test_output&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="string">&quot;./test_output&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">logdir=<span class="string">&quot;./test_output/<span class="variable">$&#123;project&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$logdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$logdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">lastdir=<span class="string">&quot;<span class="variable">$&#123;logdir&#125;</span>/`date +%Y%m%d%H%M%S`&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$lastdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$lastdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">summary=<span class="string">&quot;<span class="variable">$&#123;lastdir&#125;</span>/summary.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;times pass fail panic runtime&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">totalpass=0</span><br><span class="line">totalfail=0</span><br><span class="line">totalpanic=0</span><br><span class="line">totalruntime=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$times</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    logfile=<span class="string">&quot;<span class="variable">$&#123;lastdir&#125;</span>/<span class="variable">$i</span>.log&quot;</span></span><br><span class="line">    start=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;make project<span class="variable">$&#123;project&#125;</span> <span class="variable">$i</span> times&quot;</span></span><br><span class="line">    make project<span class="variable">$&#123;project&#125;</span> &gt;&gt; <span class="variable">$logfile</span></span><br><span class="line">    end=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    pass_count=$(grep -i <span class="string">&quot;PASS&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;pass count: <span class="variable">$pass_count</span>&quot;</span></span><br><span class="line">    fail_count=$(grep -i <span class="string">&quot;fail&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;fail count: <span class="variable">$fail_count</span>&quot;</span></span><br><span class="line">    panic_count=$(grep -i <span class="string">&quot;panic&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;panic count: <span class="variable">$panic_count</span>&quot;</span></span><br><span class="line">    runtime=$((end-start))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span> <span class="variable">$pass_count</span> <span class="variable">$fail_count</span> <span class="variable">$panic_count</span> <span class="variable">$runtime</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">    totalpass=$((totalpass+pass_count))</span><br><span class="line">    totalfail=$((totalfail+fail_count))</span><br><span class="line">    totalpanic=$((totalpanic+panic_count))</span><br><span class="line">    totalruntime=$((totalruntime+runtime))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if pass, remove the log</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$removelog</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$panic_count</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">rm</span> <span class="variable">$logfile</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;total <span class="variable">$totalfail</span> <span class="variable">$totalpanic</span> <span class="variable">$totalruntime</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br></pre></td></tr></table></figure>
<p>Project2B、2C、3B的测试时间比较长，有时只需要解决某一个测试点的Bug，没必要跑所有的测试点浪费时间。可以用命令<code>GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitConfChangeSnapshotUnreliableRecover3B|| true</code>来运行单个测试点。</p>
<p>下面是我使用的单测试点的测试脚本，注意要改title和中间的测试命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># settings to change</span></span><br><span class="line">project=<span class="string">&quot;3b&quot;</span></span><br><span class="line">removelog=1</span><br><span class="line"><span class="built_in">times</span>=50</span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeRemoveLeader3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestSplitRecoverManyClients3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeRecoverManyClients3B&quot;</span></span><br><span class="line">title=<span class="string">&quot;TestSplitConfChangeSnapshotUnreliableRecover3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeRemoveLeader3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeSnapshotUnreliableRecover3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestSplitConfChangeSnapshotUnreliableRecoverConcurrentPartition3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeUnreliableRecover3B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no change below this line</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;./test_output&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="string">&quot;./test_output&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">logdir=<span class="string">&quot;test_output/<span class="variable">$project</span>/<span class="variable">$title</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$logdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$logdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">lastdir=<span class="string">&quot;<span class="variable">$logdir</span>/`date +%Y%m%d%H%M%S`&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$lastdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$lastdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">summary=<span class="string">&quot;<span class="variable">$lastdir</span>/summary.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;times pass fail panic runtime panicinfo&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">totalpass=0</span><br><span class="line">totalfail=0</span><br><span class="line">totalpanic=0</span><br><span class="line">totalruntime=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$times</span>)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    logfile=<span class="string">&quot;<span class="variable">$&#123;lastdir&#125;</span>/<span class="variable">$i</span>.log&quot;</span></span><br><span class="line">    start=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;start <span class="variable">$i</span> times&quot;</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRemoveLeader3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitRecover3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRemoveLeader3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitRecoverManyClients3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRecoverManyClients3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    (GO111MODULE=on go <span class="built_in">test</span> -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitConfChangeSnapshotUnreliableRecover3B|| <span class="literal">true</span>) &gt;&gt; <span class="variable">$logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRemoveLeader3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeSnapshotUnreliableRecover3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitConfChangeSnapshotUnreliableRecoverConcurrentPartition3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeUnreliableRecover3B|| true) &gt;&gt; $logfile</span></span><br><span class="line"></span><br><span class="line">    end=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    pass_count=$(grep -i <span class="string">&quot;PASS&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;pass count: <span class="variable">$pass_count</span>&quot;</span></span><br><span class="line">    fail_count=$(grep -i <span class="string">&quot;fail&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;fail count: <span class="variable">$fail_count</span>&quot;</span></span><br><span class="line">    panic_count=$(grep -i <span class="string">&quot;panic&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;panic count: <span class="variable">$panic_count</span>&quot;</span></span><br><span class="line">    runtime=$((end-start))</span><br><span class="line"></span><br><span class="line">    panic_info=$(grep -m 1 -i <span class="string">&quot;panic&quot;</span> <span class="variable">$logfile</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span> <span class="variable">$pass_count</span> <span class="variable">$fail_count</span> <span class="variable">$panic_count</span> <span class="variable">$runtime</span> <span class="variable">$panic_info</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">    totalpass=$((totalpass+pass_count))</span><br><span class="line">    totalfail=$((totalfail+fail_count))</span><br><span class="line">    totalpanic=$((totalpanic+panic_count))</span><br><span class="line">    totalruntime=$((totalruntime+runtime))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if pass, remove the log</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$removelog</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$pass_count</span> -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">rm</span> <span class="variable">$logfile</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;total <span class="variable">$totalfail</span> <span class="variable">$totalpanic</span> <span class="variable">$totalruntime</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br></pre></td></tr></table></figure>

<h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><p>打印日志非常重要，尤其是对于跟踪Project2B、2C、3B中的Bug。</p>
<p>可以在<code>log/log.go</code>​的末尾增加以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> debug_raft = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> debug_raftStore = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DPrintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> debug &gt; <span class="number">0</span> &#123;</span><br><span class="line">		_log.Infof(format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DPrintfRaft</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> debug_raft &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;[Raft]: &quot;</span>+format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DPrintfRaftStore</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> debug_raftStore &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;[RaftStore]: &quot;</span>+format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>debug_xxx</code>​改为大于0之后，在需要打印日志的地方调用<code>log.DPrintfxxx</code>​即可。</p>
<p>我这里分了三种日志类型，最重要的是<code>Raft</code>​和<code>RaftStore</code>​，分别对应Raft层的日志和RaftStore的日志，这样做的好处是面对海量的日志能够很容易找到哪个模块的代码出了问题，也可以很轻松过地关闭一个模块的日志减少干扰。</p>
<p>‍</p>
<h2 id="Tinykv架构"><a href="#Tinykv架构" class="headerlink" title="Tinykv架构"></a>Tinykv架构</h2><p>在正式编码之前，我们可以大致了解一下Tinykv的架构，这里我直接结合官方的图大致来讲一下自己的理解。</p>
<p>​<img src="/2024/05/01/tinykv_start/image-20240501170434-8r9kv28.png" alt="image">​</p>
<p>Tinykv只关注分布式数据库系统的存储层，可以处理响应来自SQL层的RPC请求，同时还有一个TinyScheduler组件作为整个Tinykv集群的控制中心，从Tinykv的心跳中收集信息，负责一些调度工作，向Tinykv节点发送调度命令以实现负载均衡（project 3c）等等功能。</p>
<p>自下而上解析Tinykv的组成：</p>
<ol>
<li><p>Engine，即kv存储引擎，是实际存储kv的地方。在Tinykv中使用的是badgerDB，使用了两个DB实例：kv和raftkv，分别用于存储实际的kv数据和raft日志，当然还分别存储了一些状态数据。</p>
</li>
<li><p>Storage，我理解为分布式逻辑层，这里分为了Standalone Storage和RaftStorage</p>
<ol>
<li><p>Standalone Storage对应project1，在badgerDB的API基础上封装了列族（可以理解为给每个key加上了前缀以实现分类），这是为了在后面project4中实现事务机制。</p>
</li>
<li><p>RaftStorage：project2和3的重点。负责了请求的处理和响应。包括了Raft层和Raft层之上的逻辑<strong>RaftStore</strong></p>
<ol>
<li>Raft层用于接收来自上层的Raft日志，实现共识算法，会定期给上层反馈已经提交的日志和要转发的消息等等。</li>
<li>RaftStore则负责消息的封装和路由（分发到raft节点）、raft日志的持久化和命令的应用等等，比较复杂。</li>
</ol>
</li>
</ol>
</li>
<li><p>server，接收RPC调用和响应，实现MVCC（多版本并发控制）和封装事务性API，对应project4</p>
</li>
</ol>
<p>‍</p>
<p>项目目录：</p>
<ul>
<li>​<code>kv</code>​包含键值存储的实现。</li>
<li>​<code>raft</code>​包含 Raft 共识算法的实现。</li>
<li>​<code>scheduler</code>​包含 TinyScheduler 的实现，该实现负责管理 TinyKV 节点和生成时间戳。</li>
<li>​<code>proto</code>​包含节点和进程之间所有通信的实现，使用基于 gRPC 的协议缓冲区。此包包含 TinyKV 使用的协议定义，以及您可以使用的生成的 Go 代码。</li>
<li>​<code>log</code>​包含基于级别输出日志的实用程序。</li>
</ul>
<p>‍</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了上述的一些准备之后就可以开始攻克Tinykv的各个project了，万事开头难，这也是我正儿八经的第一篇博客，后续会更新四个project的思路和踩的一些坑。由于缺乏有关分布式系统的很多知识，理解上可能会有很多谬误和遗漏，欢迎多多提问和指正。</p>
<p>Tinykv 启~动！</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
</search>
