<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>tinykv project1思路</title>
    <url>/2024/05/02/tinykv_project1_solution/</url>
    <content><![CDATA[<span id="more"></span>
<p>project1是一个热身项目，内容非常简单。项目文档中提到需要实现两部分的内容：（1）独立存储引擎；（2）原始kv服务处理程序。下面分别介绍一下基本的思路。</p>
<h2 id="独立存储引擎"><a href="#独立存储引擎" class="headerlink" title="独立存储引擎"></a>独立存储引擎</h2><p>文档中提到该任务是对badgerDB的读写API的封装以支持列族（Column Family, CF）。通过运行<code>grep -rIi &quot;Your Code Here (1).&quot;</code>​发现需要编写的代码主要在<code>kv/storage/standalone_storage/standalone_storage.go</code>​，需要实现：</p>
<ol>
<li>定义<code>StandAloneStorage</code>​的数据结构</li>
<li>定义<code>NewStandAloneStorage</code>​函数，根据参数<code>Config</code>​创建一个<code>StandAloneStorage</code>​对象</li>
<li>填充<code>Start, Stop, Reader, Write</code>​四个函数</li>
</ol>
<h3 id="​StandAloneStorage​​​的定义和新建"><a href="#​StandAloneStorage​​​的定义和新建" class="headerlink" title="​StandAloneStorage​​​的定义和新建"></a>​<code>StandAloneStorage</code>​​​的定义和新建</h3><p>根据项目文档，engine_util包 （<code>kv/util/engine_util</code>​）中提供了所有的读写操作，即需要封装的API。但是我们并不知道它们在哪里，<code>kv/util/engine_util/doc.go</code>​中给出了一些信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">* engines: a data structure <span class="keyword">for</span> keeping engines required by unistore.</span><br><span class="line">* write_batch: code to batch writes into a single, atomic <span class="string">&#x27;transaction&#x27;</span>.</span><br><span class="line">* cf_iterator: code to iterate over a whole column family in badger.</span><br></pre></td></tr></table></figure>

<p>从命名和描述可以看出engines是存储引擎、write_batch是将多个写入整合到一个batch中，cf_iterator则是在badger中迭代列族。</p>
<p>再来看具体的文件。</p>
<p>​<code>kv/util/engine_util/engines.go</code>​中定义了<code>Engines</code>​类，包含了两个<code>badger.DB</code>​的指针，还提供了<code>NewEngines</code>​、<code>WriteKV</code>​、<code>WriteRaft</code>​、<code>Close</code>​、<code>Destroy</code>​、<code>CreateDB</code>​这些函数。很显然<code>StandAloneStorage</code>​是对<code>Engines</code>​的封装，需要包含一个<code>engine_util.Engines</code>​成员，<code>NewStandAloneStorage</code>​需要进行<code>CreateDB</code>​和<code>NewEngines</code>​两个步骤。<code>Start</code>​不需要修改，<code>Stop</code>​需要调用<code>en.Close()</code>​;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engines <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Data, including data which is committed (i.e., committed across other nodes) and un-committed (i.e., only present</span></span><br><span class="line">	<span class="comment">// locally).</span></span><br><span class="line">	Kv     *badger.DB</span><br><span class="line">	KvPath <span class="type">string</span></span><br><span class="line">	<span class="comment">// Metadata used by Raft.</span></span><br><span class="line">	Raft     *badger.DB</span><br><span class="line">	RaftPath <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StandAloneStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your Data Here (1).</span></span><br><span class="line">	en *engine_util.Engines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>关于Write的实现，文档告诉我们参数<code>ctx *kvrpcpb.Context</code>​暂时不用管，只剩下一个参数<code>batch []storage.Modify</code>​，可知是接口<code>Modify</code>​类型切片，通过观察类定义和相关函数发现，<code>Modify</code>​中可以是类型为<code>Put</code>​或<code>Delete</code>​类型的<code>Data</code>​，使用<code>.Key().Cf().Value()</code>​取对应的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Modify <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Put <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   []<span class="type">byte</span></span><br><span class="line">	Value []<span class="type">byte</span></span><br><span class="line">	Cf    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delete <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key []<span class="type">byte</span></span><br><span class="line">	Cf  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Modify)</span></span> Key() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Put:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Put).Key</span><br><span class="line">	<span class="keyword">case</span> Delete:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Delete).Key</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Modify)</span></span> Value() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> putData, ok := m.Data.(Put); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> putData.Value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Modify)</span></span> Cf() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Put:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Put).Cf</span><br><span class="line">	<span class="keyword">case</span> Delete:</span><br><span class="line">		<span class="keyword">return</span> m.Data.(Delete).Cf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们在<code>Write</code>​中需要做的应该是：声明一个空的<code>WriteBatch wb</code>，然后遍历参数<code>batch</code>​，提取每一个<code>key,val,cf</code>​，使用辅助函数添加到<code>wb</code>中；遍历结束后调用<code>en.WriteKV</code>​实现写入。</p>
<p>通过阅读<code>kv/util/engine_util/write_batch.go</code>​可知要用到的辅助函数是类<code>WriteBatch</code>​的<code>SetCF</code>​和<code>DeleteCF</code>​接口。</p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>​<code>Reader</code>​方法返回一个<code>StorageReader</code>​接口，要求实现<code>GetCF()、IterCF()、Close()</code>​三个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StorageReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// When the key doesn&#x27;t exist, return nil for the value</span></span><br><span class="line">	GetCF(cf <span class="type">string</span>, key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">	IterCF(cf <span class="type">string</span>) engine_util.DBIterator</span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档中说应该使用<code>badger.Txn</code>​来实现<code>Reader</code>​函数，但是<code>badger.Txn</code>​并没有<code>GetCF()、IterCF()、Close()</code>​这三个方法，因此不能满足<code>StorageReader</code>​接口的要求（go语言接口<code>interface</code>的限制），我们要对其进行封装。</p>
<p>我这里定义了一个<code>StandAloneStorageReader</code>​类，包含了一个<code>badger.Txn</code>​成员，分别使用<code>engine_util.GetCFFromTxn</code>​、<code>engine_util.NewCFIterator</code>​、<code>txn.Discard</code>​实现了<code>GetCF()、IterCF()、Close()</code>​。在<code>Reader</code>​中只需要调用<code>en.Kv.NewTransaction</code>​创建一个<code>txn</code>​，然后返回一个<code>StandAloneStorageReader</code>​即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandAloneStorage)</span></span> Reader(ctx *kvrpcpb.Context) (storage.StorageReader, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (1).</span></span><br><span class="line">	txn := s.en.Kv.NewTransaction(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span> &amp;StandAloneStorageReader&#123;</span><br><span class="line">		txn: txn,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StandAloneStorageReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	txn *badger.Txn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现服务处理程序"><a href="#实现服务处理程序" class="headerlink" title="实现服务处理程序"></a>实现服务处理程序</h2><p>需要实现的代码在<code>kv/server/raw_api.go</code>​当中，需要实现<code>RawGet</code>​、<code>RawPut</code>​、<code>RawDelete</code>​、<code>RawScan</code>​。前三个都很简单，没有需要自己寻找或设计的数据结构，部分接口需要查找，不过都是可以根据参数和成员得到的。</p>
<p>​<code>RawScan</code>​函数主要是要弄清它的功能：从<code>startkey</code>​开始，取至多<code>limit</code>​个<code>kvPairs</code>​。</p>
<p>这样就知道需要用<code>Reader</code>​的迭代器，首先<code>Seek</code>​到<code>StartKey</code>​的位置，然后取至多<code>limit</code>​个<code>kvPairs</code>​。</p>
<p>​<code>iter</code>​的使用方式参考：<code>iter-&gt;Seek(StartKey)</code>​ –&gt;<code>iter-&gt;Valid()</code>​ –&gt;<code>iter.Next()</code>​</p>
<h2 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h2><p>出现一个问题</p>
<p>​<img src="/2024/05/02/tinykv_project1_solution/image-20231116204912-q20bqqq.png" alt="image">​</p>
<p>查看测试代码，发现当KeyNotFound时要求err返回nil</p>
<p>​<img src="/2024/05/02/tinykv_project1_solution/image-20231116204940-tsx3alt.png" alt="image">​</p>
<p>解决后成功通过！完成 project 1！</p>
<p>​<img src="/2024/05/02/tinykv_project1_solution/image-20231116213243-xxct0mn.png" alt="image">​</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project2b文档翻译和关键点标注</title>
    <url>/2024/05/05/tinykv_project2B_doc_translation/</url>
    <content><![CDATA[<span id="more"></span>

<p>这几天想写tinykv project2B的思路，但是感觉内容太多不知道从何处写起。思来想去觉得可以先翻译一下project2B的文档，将比较关键的地方标注出来。</p>
<hr>
<h2 id="B部分"><a href="#B部分" class="headerlink" title="B部分"></a>B部分</h2><p>在这一部分中，您将使用 A 部分中实现的 Raft 模块构建一个容错的键值存储服务。你的键&#x2F;值服务将是一个复制的状态机，由几个使用 Raft 进行复制的键&#x2F;值服务器组成。只要大多数服务器处于活动状态并且可以通信，键&#x2F;值服务就应继续处理客户端请求，即使存在其他故障或网络分区。</p>
<p>在 project1 中，您已经实现了一个独立的 kv 服务器，因此您应该已经熟悉 kv 服务器 <code>Storage</code>​ 的API 和接口。</p>
<p>在介绍代码之前，您需要先了解三个术语：<code>Store</code>​, <code>Peer</code>​ and <code>Region</code>​，以及<code>proto/proto/metapb.proto</code>​中定义的术语。</p>
<ul>
<li>Store 代表 tinykv-server 的实例</li>
<li>Peer 代表运行在 Store 上的 Raft 节点</li>
<li>Region 是 Peers 的集合，也称为 Raft Group（<mark><strong>Region将键空间以范围range划分，是实现Project3 MuitiRaft的关键概念，Project2中默认只有一个Region</strong></mark>）</li>
</ul>
<p>​<img src="/2024/05/05/tinykv_project2B_doc_translation/image-20240505150015-qwdhuaz.png" alt="image">​</p>
<p>为简单起见，project2 的 Store 上只有一个 Peer 节点，集群中只有一个 Region。因此，您现在无需考虑 Region 的范围。Project3 中将进一步引入多个 Region。</p>
<h3 id="the-Code"><a href="#the-Code" class="headerlink" title="the Code"></a>the Code</h3><p>首先，您应该看看<code>kv/storage/raft_storage/raft_server.go</code>​中的<code>RaftStorage</code>​，其也实现了<code>Storage</code>​接口。与<code>StandaloneStorage</code>​直接写入或读取底层引擎不同，它首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后对底层引擎进行实际的写入和读取。通过这种方式，可以保持多个<code>Stores</code>​之间的一致性。</p>
<p>​<code>RaftStorage</code>​创建一个<code>Raftstore</code>​驱动 Raft。在调用<code>Reader</code>​or<code>Write</code>​函数时，它实际上会通过通道（通道为<code>raftWorker</code>​的<code>raftCh</code>​）向 raftstore 发送一个定义在<code>proto/proto/raft_cmdpb.proto</code>​中的<code>RaftCmdRequest</code>​和四种基本命令类型（Get&#x2F;Put&#x2F;Delete&#x2F;Snap），<mark><strong>并在 Raft 提交并应用命令后利用回调向客户端返回响应</strong></mark>。<code>Reader</code>​和<code>Write</code>​函数的参数<code>kvrpc.Context</code>​现在很有用，它从客户端的角度携带<code>Region</code>​信息，并作为<code>RaftCmdRequest</code>​的标头传递。<mark><strong>信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否将该请求Propose到 Raft 层进行共识</strong></mark>。</p>
<p>然后，TinyKV的核心就来了——raftstore。结构有点复杂，请阅读 TiKV 参考文献，以便更好地理解设计：</p>
<ul>
<li><a href="https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore">https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore</a> （中文版，<mark><strong>非常推荐，对于整个Project2、Project3的理解有很大帮助，不过TiKV做了很多目前我们不用关心的优化，例如异步Apply、读写分离</strong></mark>）</li>
<li><a href="https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore">https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore</a> （英文版）</li>
</ul>
<p>raftstore的入口是<code>Raftstore</code>​，见<code>kv/raftstore/raftstore.go</code>​。它启动了一些工作线程异步处理特定任务，其中大多数现在没有使用，因此您可以忽略它们。您需要关注的只是<code>raftWorker</code>​.（kv&#x2F;raftstore&#x2F;raft_worker.go）</p>
<p>整个过程分为两部分：raft worker 轮询<code>raftCh</code>​以获取消息，包括驱动 Raft 模块的 base tick 和作为 Raft 条目提出（proposed）Raft 命令；<mark><strong>它从 Raft 模块获取并处理 ready，处理流程包括转发 raft 消息、持久化状态、将提交的条目应用于状态机。应用后，还要将响应通过回调返回给客户端。</strong></mark></p>
<h3 id="实现peer-storage"><a href="#实现peer-storage" class="headerlink" title="实现peer storage"></a>实现peer storage</h3><p>peer storage是你通过 A 部分中的<code>Storage</code>​接口进行交互的内容，但除了 raft 日志之外，peer storage还管理其他持久化的元数据，这对于重启后恢复一致的状态机非常重要。此外，<code>proto/proto/raft_serverpb.proto</code>​中定义了三个重要状态：</p>
<ul>
<li>RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log 的 Index。</li>
<li>RaftApplyState：用于存储 Raft 应用的最后一个 Log 索引和一些截断的 Log 信息。</li>
<li>RegionLocalState：用于存储此 Store 上的 Region 信息和相应的 Peer State。Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。</li>
</ul>
<p>这些状态存储在两个 badger 实例中：raftdb 和 kvdb：</p>
<ul>
<li>raftdb 存储 Raft 日志和<code>RaftLocalState</code>​</li>
<li>kvdb 将键值数据存储在不同的列族，<code>RegionLocalState</code>​和<code>RaftApplyState</code>​中。你可以把 kvdb 看作是 Raft 论文中提到的状态机</li>
</ul>
<p>格式如下，<code>kv/raftstore/meta</code>​中提供了一些辅助函数，并用<code>writebatch.SetMeta()</code>​将它们设置为 badger。</p>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">KeyFormat</th>
<th align="left">Value</th>
<th align="left">DB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">raft_log_key</td>
<td align="left">0x01 0x02 region_id 0x01 log_idx</td>
<td align="left">Entry</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">raft_state_key</td>
<td align="left">0x01 0x02 region_id 0x02</td>
<td align="left">RaftLocalState</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">apply_state_key</td>
<td align="left">0x01 0x02 region_id 0x03</td>
<td align="left">RaftApplyState</td>
<td align="left">kv</td>
</tr>
<tr>
<td align="left">region_state_key</td>
<td align="left">0x01 0x03 region_id 0x01</td>
<td align="left">RegionLocalState</td>
<td align="left">kv</td>
</tr>
</tbody></table>
<blockquote>
<p>您可能想知道为什么 TinyKV 需要两个 badger 实例。实际上，它可以使用一个badger来存储 raft 日志和状态机数据。分成两个实例只是为了和 TiKV 的设计保持一致。</p>
</blockquote>
<p>应在<code>PeerStorage</code>​中创建和更新这些元数据。创建 PeerStorage 时，请参见<code>kv/raftstore/peer_storage.go</code>​。它初始化此 Peer 的 RaftLocalState、RaftApplyState，或者在重启时从底层引擎获取上一个值。请注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值均为 5（只要它大于 1），但不是 0。之所以不将其设置为 0，是为了与 Peer 在 conf 更改后被动创建的情况区分开来。你现在可能还不太明白，所以只要记住它，当你实现conf change时，细节将在project3b中描述。</p>
<p>这部分需要实现的代码只有一个函数：<code>PeerStorage.SaveReadyState</code>​，这个函数的作用是将<code>raft.Ready</code>​中的数据保存到 badger存储引擎（<mark><strong>kvdb和raftdb，Project2C ​<code>ApplySnapshot</code>会涉及kvdb</strong></mark>）中，包括<code>Append</code>​日志条目（<mark><strong>即持久化 Raft 日志到 raftdb</strong></mark>）和保存 Raft HardState。</p>
<p>要<code>Append</code>​日志条目，只需将在<code>raft.Ready.Entries</code>​中的所有日志条目保存到 raftdb 中，并删除之前追加的日志条目，这些条目永远不会被提交。另外，更新peer storage的<code>RaftLocalState</code>​并将其保存到 raftdb。</p>
<p>保存<code>hard state</code>​也非常简单，只需更新 peer storage的<code>RaftLocalState.HardState</code>​并将其保存到 raftdb 即可。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>用<code>WriteBatch</code>​一次保存这些状态。</li>
<li>有关如何读取和写入这些状态，请参阅<code>peer_storage.go</code>​中的其他函数。</li>
<li>设置环境变量 LOG_LEVEL&#x3D;debug，这可能有助于您进行调试，另请参阅所有可用的<a href="https://github.com/talent-plan/tinykv/blob/course/log/log.go">日志级别</a>。</li>
</ul>
</blockquote>
<h3 id="Implement-Raft-ready-process"><a href="#Implement-Raft-ready-process" class="headerlink" title="Implement Raft ready process"></a>Implement Raft ready process</h3><p>在 project2 的 A 部分中，您构建了一个基于 tick 的 Raft 模块。现在，您需要编写外部进程来驱动它。大多数代码已经在<code>kv/raftstore/peer_msg_handler.go</code>​和<code>kv/raftstore/peer.go</code>​下实现。<mark><strong>所以你需要学习代码并完成<code>proposeRaftCommand</code>和<code>HandleRaftReady</code>​的逻辑</strong></mark>。以下是对该框架的一些解释。</p>
<p>Raft <code>RawNode</code>​已经使用<code>PeerStorage</code>​创建并存储在<code>peer</code>​中。在 raft worker 中，您可以看到它包含了<code>peer</code>​，采用<code>peerMsgHandler</code>​将其封装 。主要有两个功能：一个是<code>HandleMsg</code>​，另一个是<code>HandleRaftReady</code>​。</p>
<p>​<code>HandleMsg</code>​处理从 raftCh 接收到的所有消息，包括<code>MsgTypeTick</code>​ （调用<code>RawNode.Tick()</code>​来驱动Raft），<code>MsgTypeRaftCmd</code>​包装来自客户端的请求，以及<code>MsgTypeRaftMessage</code>​ Raft 对等节点之间传输的消息。所有消息类型都在<code>kv/raftstore/message/msg.go</code>​中定义。您可以查看它的详细信息，其中一些将在以下部分中使用。</p>
<p>消息处理完毕后，Raft 节点应该会有一些状态更新。<mark><strong>所以<code>HandleRaftReady</code>应该从 Raft 模块中获取 Ready 并执行相应的操作，例如持久化日志条目、应用已提交的条目并通过网络向其他 Peer 节点发送 Raft 消息</strong></mark>。</p>
<p>在伪代码中，raftstore 使用 Raft，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-s.Ticker:</span><br><span class="line">    Node.Tick()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> Node.HasReady() &#123;</span><br><span class="line">      rd := Node.Ready()</span><br><span class="line">      saveToStorage(rd.State, rd.Entries, rd.Snapshot)</span><br><span class="line">      send(rd.Messages)</span><br><span class="line">      <span class="keyword">for</span> _, entry := <span class="keyword">range</span> rd.CommittedEntries &#123;</span><br><span class="line">        process(entry)</span><br><span class="line">      &#125;</span><br><span class="line">      s.Node.Advance(rd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述伪代码的<code>default</code>​分支大致展示了<code>HandleRaftReady</code>​的处理流程。</p>
</blockquote>
<p>因此，读取或写入的整个过程将是这样的：</p>
<ul>
<li>客户端调用 RPC RawGet&#x2F;RawPut&#x2F;RawDelete&#x2F;RawScan</li>
<li>RPC 处理程序调用<code>RaftStorage</code>​相关方法</li>
<li>​<code>RaftStorage</code>​向 raftstore 发送 Raft 命令请求，等待响应</li>
<li>​<code>RaftStore</code>​将 Raft 命令请求作为 Raft 日志<code>Propose</code>​给 Raft 层</li>
<li>Raft 模块<code>Append</code>​日志，并使用<code>PeerStorage</code>​进行持久化</li>
<li>Raft 模块提交日志（该日志被大多数节点接受）</li>
<li>Raft worker 在处理 Raft ready 时应用 Raft 命令，并通过 callback 返回响应</li>
<li>​<code>RaftStorage</code>​接收来自回调的响应并返回到 RPC 处理程序</li>
<li>RPC 处理程序执行一些操作并将 RPC 响应返回给客户端</li>
</ul>
<p>您应该运行<code>make project2b</code>​以通过所有测试。整个测试运行一个模拟集群，包括多个具有模拟网络的 TinyKV 实例。它执行一些读取和写入操作，并检查返回值是否符合预期。</p>
<p>需要注意的是，错误处理是通过测试的重要组成部分。您可能已经注意到<code>proto/proto/errorpb.proto</code>​其中定义了一些错误，并且该错误是 gRPC 响应的一个字段。此外，实现<code>error</code>​接口的相应错误在<code>kv/raftstore/util/error.go</code>​中定义，因此您可以将它们用作函数的返回值。</p>
<p>这些错误主要与 Region 有关。所以它也是<code>RaftResponseHeader</code>​ of <code>RaftCmdResponse</code>​的成员。<mark><strong>在 Propose 请求或应用命令时</strong></mark>，可能会出现一些错误。如果是这样，你应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。您可以使用<code>kv/raftstore/cmd_resp.go</code>​提供的​<code>BindRespError</code>​将这些错误转换为在返回带有错误的响应时定义的错误。</p>
<p>在此阶段，您可以考虑以下这些错误，其他错误将在 project3 中处理：</p>
<ul>
<li>ErrNotLeader：在 follower 上 Propose raft 命令。因此，使用它来让客户端尝试将请求发送给其他 Peer。</li>
<li>ErrStaleCommand：可能是由于领导者更改，某些日志未提交并被新的领导者日志覆盖。但客户并不知道这一点，仍在等待响应。因此，您应该返回此命令以让客户端知道并重试该命令。</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>​<code>PeerStorage</code>​实现了 Raft 模块的<code>Storage</code>​接口，你应该使用提供的<code>SaveReadyState()</code>​方法来持久化 Raft 相关的状态。</li>
<li>使用<code>engine_util</code>​中的<code>WriteBatch</code>​以原子方式进行多次写入，例如，<mark><strong>您需要确保在一个<code>WriteBatch</code>中应用已提交的条目并更新<code>Applied</code>索引（这两个写入不要分开来做）</strong></mark>。</li>
<li>用<code>Transport</code>​向其他 Peer 节点发送 raft 消息，它在<code>GlobalContext</code>​中</li>
<li>如果服务器不是多数服务器的一部分，并且没有最新数据，则不应完成 get RPC。你可以直接将 get 操作放入 raft 日志中，或者实现 Raft 论文第 8 节中描述的只读操作的优化（<mark><strong>建议先完成最基本的功能，再考虑实现各种优化</strong></mark>）。</li>
<li>在应用日志条目时，不要忘记更新并保留<code>ApplyState</code>​。</li>
<li>你可以像 TiKV 一样异步应用已提交的 Raft 日志条目。这不是必需的，尽管提高性能是一个很大的挑战。</li>
<li>Propose时记录命令的回调，应用后返回回调。</li>
<li>对于 snap 命令响应，应将 badger Txn 显式设置为回调。</li>
<li><mark><strong>在 2A 之后采用随机测试，您可能需要多次运行某些测试以查找错误</strong></mark></li>
</ul>
</blockquote>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project2a思路</title>
    <url>/2024/05/03/tinykv_project2a_solution/</url>
    <content><![CDATA[<span id="more"></span>

<p>project2需要实现一个基于raft算法的高可用kv服务器。根据文档，有三部分需要完成，包括：</p>
<ul>
<li>A：实现基本的 Raft 算法</li>
<li>B：在 Raft 之上构建容错 KV 服务器</li>
<li>C：新增 raftlog GC 和 snapshot 支持</li>
</ul>
<p>Project2A主要任务是实现Raft算法。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>非常建议先阅读一遍raft论文再来做project2A，不然在很多概念的理解上都会很吃力。一个非常有帮助的链接：</p>
<p><a href="https://raft.github.io/">Raft Consensus Algorithm</a></p>
<p>‍</p>
<h2 id="aa选举和ab日志复制"><a href="#aa选举和ab日志复制" class="headerlink" title="aa选举和ab日志复制"></a>aa选举和ab日志复制</h2><p>这一部分主要实现Raft层进行共识（实现一致性）的逻辑，主要代码在<code>raft/log.go</code>​和<code>raft/raft.go</code>​当中。</p>
<h3 id="Raft和RaftLog类定义"><a href="#Raft和RaftLog类定义" class="headerlink" title="Raft和RaftLog类定义"></a>Raft和RaftLog类定义</h3><p>如题目中所说，<code>raft.Raft</code>​提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。</p>
<p>Raft类定义解析如下：</p>
<ul>
<li>id：节点id</li>
<li>Term：任期</li>
<li>Vote：当前任期投票给了谁</li>
<li>RaftLog：缓存日志条目</li>
<li>Prs：用于leader维护各节点日志复制的进度（Match代表已经匹配的Index，Next代表即将发送的下一个Index）</li>
<li>State：节点状态</li>
<li>votes：记录投票信息</li>
<li>msgs：需要发送的消息，消息分本地消息（本节点处理）和普通消息</li>
<li>Lead：只想当前的leader</li>
<li>heartbeatTimeout：心跳超时</li>
<li>electionTimeout：选举超时</li>
<li>heartbeatElapsed：记录距上次心跳超时经过的时间，用于判断是否心跳超时</li>
<li>electionElapsed：记录，用于判断是否选举超时</li>
<li>leadTransferee、PendingConfIndex：在3A领导权转移和配置变更中使用，此处忽略</li>
</ul>
<p>结合Raft算法的要求，我增加了以下成员：</p>
<ol>
<li>randElectTimeout：随机选举超时，必需，减少选举失败。</li>
<li>voteCount：当前票数，不必需</li>
<li>denialCount：当前拒绝投票数，不必需，方便统计</li>
</ol>
<p>‍</p>
<p>​<code>raft.RaftLog</code>​是一个辅助结构体，主要用于raft节点缓存日志条目，通过<code>raft/storage.go</code>​中定义的<code>Storage</code>​接口与上层应用进行交互，能够获取日志条目和快照等持久化数据。</p>
<p>RaftLog类定义解析如下：</p>
<ul>
<li><p>storage：存储了自从上次快照以来的所有stable的日志条目，stable指已经持久化了。storage中还提供了获取初始状态、FirstIndex、LastIndex等信息的接口，初始化需要用到。</p>
</li>
<li><p>applied、committed、stabled是非常重要的三个索引：分别代表已应用的、已提交的、已持久化的日志条目的最大索引，所有的日志条目的索引有如下关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  snapshot/first.....applied....committed....stabled.....last</span></span><br><span class="line"><span class="comment">//  --------|------------------------------------------------|</span></span><br><span class="line"><span class="comment">//                            log entries</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
<li><p>entries：所有还未compact的日志条目，这里compact的含义暂时忽略。</p>
</li>
<li><p>pendingSnapshot：在2C中使用，暂时忽略。</p>
</li>
</ul>
<p>参考代码中storage具有一个dummy entry的设计（题目也有说明：默认第一次启动raft时应具有条目 0），为RaftLog增加一个成员：</p>
<ul>
<li>dummyIndex：第一个日志的索引，用于方便计算下标位置</li>
</ul>
<h3 id="原理和数据处理流程"><a href="#原理和数据处理流程" class="headerlink" title="原理和数据处理流程"></a>原理和数据处理流程</h3><p>上面提到的日志条目实际上是代表某个操作的条目（例如<code>put、get</code>​等），tinykv首先要对这些操作的条目利用raft算法进行共识，只有在集群内大多数节点“接受”了某个操作，这个操作才会被“应用”到存储引擎中进行实际的数据操作。Raft模块就是维护集群在这些操作条目上的一致性，进而上层应用可以执行相同的操作，实现数据一致性。</p>
<p>如题目所述，Raft模块的处理流程都是由上层应用通过调用<code>RawNode</code>​（RawNode是对Raft的封装）的各个接口来异步推进的。</p>
<ol>
<li>上层应用负责通过调用<code>RawNode.Tick()</code>​来推进Raft节点的逻辑时钟，从而推进选举和leader发送心跳。</li>
<li>上层应用通过调用<code>RawNode.Step()</code>​来推动Raft节点处理消息，Raft节点只需要把消息推送到<code>raft.Raft.msgs</code>​中，在<code>raft.Raft.Step()</code>​中实现消息处理的逻辑。</li>
<li>上层应用通过调用<code>RawNode.Propose()</code>​向raft节点发送新的日志条目。</li>
<li>通过<code>RawNode.Ready()</code>​来获取raft节点的各项状态更新，据此进行消息转发、持久化、实际数据操作等。</li>
<li>通过<code>RawNode.Advance()</code>​来更新raft节点的内部状态，如应用的索引、稳定日志索引等。</li>
<li>。。。</li>
</ol>
<p>在project2A中，我们只需要理解：</p>
<p>上层的 RawNode 会定时调用 <code>tick()</code>​，驱动 Raft，同时如果有消息，则通过 <code>Step()</code>​ 函数传递给 Raft。然后 Raft 进行一系列的处理。将需要发送给其他节点的消息存放在 <code>r.msgs</code>​ 中，RawNode 会在生成 Ready 的时候取走并发送给别的节点。整个流程是线性的，<code>Tick()</code>​ 和<code>Step()</code>​ 不会被同时触发，这里不存在多线程的情况。</p>
<p>因此在2aa和2ab中，主要需要完成：</p>
<ol>
<li>针对<code>tick()</code>​的处理，即推进选举和leader发送心跳消息<code>heartbeatMsg</code>​等</li>
<li>针对<code>Step()</code>​的处理，即消息处理，按照raft算法对各种类型的消息执行相应的动作，这些消息包含本地的消息、其他节点的消息、上层发来的propose消息等。</li>
<li>辅助结构<code>RaftLog</code>​模块</li>
</ol>
<h3 id="RaftLog模块"><a href="#RaftLog模块" class="headerlink" title="RaftLog模块"></a>RaftLog模块</h3><p>首先是<code>newLog</code>​，根据参数，需要从<code>storage</code>​中获取数据来进行初始化动作。由于<code>storage</code>​中保存的是所有已经持久化但是未被应用的日志条目，因此<code>applied = firstIndex - 1</code>​，<code>stabled = lastIndex</code>​。<code>storage</code>​中保存的<code>hardState</code>​保存了<code>Term、Vote、Commit</code>​三个信息，前两个用于Raft初始化，<code>Commit</code>​用来初始化<code>RaftLog.committed</code>​。获取<code>entries</code>​的方式也很简单，<code>storage</code>​提供了<code>Entries</code>​接口，因此可以通过调用<code>Entries(firstIndex, lastIndex+1)</code>​获取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLog</span><span class="params">(storage Storage)</span></span> *RaftLog &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	firstIndex, _ := storage.FirstIndex()</span><br><span class="line">	lastIndex, _ := storage.LastIndex()</span><br><span class="line">	hardState, _, _ := storage.InitialState()</span><br><span class="line">	entries := <span class="built_in">make</span>([]pb.Entry, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> firstIndex &lt;= lastIndex &#123;</span><br><span class="line">		entries, _ = storage.Entries(firstIndex, lastIndex+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> entries == <span class="literal">nil</span> &#123;</span><br><span class="line">			entries = <span class="built_in">make</span>([]pb.Entry, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log := &amp;RaftLog&#123;</span><br><span class="line">		storage:         storage,</span><br><span class="line">		committed:       hardState.Commit,</span><br><span class="line">		applied:         firstIndex - <span class="number">1</span>, <span class="comment">// 对applied进行修正</span></span><br><span class="line">		stabled:         lastIndex,</span><br><span class="line">		entries:         entries,</span><br><span class="line">		pendingSnapshot: <span class="literal">nil</span>,</span><br><span class="line">		dummyIndex:      firstIndex,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其余函数"><a href="#其余函数" class="headerlink" title="其余函数"></a>其余函数</h4><p>​<code>unstableEntries</code>​：所有未持久化的日志，字面意思处理即可</p>
<p>​<code>nextEnts</code>​：所有已经提交但没有应用的日志<code>(applied, committed]</code>​</p>
<p>​<code>lastIndex</code>​：最后一个条目的索引</p>
<p>​<code>Term</code>​：获取指定索引的日志条目的term，注意要返回<code>ErrUnavailable</code>​错误，如果不在[firstIndex, lastIndex]，调用<code>storage.Term</code>​即可</p>
<blockquote>
<p>这一部分代码编写要十分注意几个Index的细节处理和条件判断，否则容易出现越界等错误。</p>
</blockquote>
<h3 id="Raft模块"><a href="#Raft模块" class="headerlink" title="Raft模块"></a>Raft模块</h3><h4 id="newRaft"><a href="#newRaft" class="headerlink" title="newRaft"></a>newRaft</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newRaft return a raft peer with the given config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRaft</span><span class="params">(c *Config)</span></span> *Raft &#123;</span><br><span class="line">	<span class="keyword">if</span> err := c.validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>Config</code>​提供了初始化所需的数据。值得注意的是<code>Storage</code>​，需要用它新建<code>RaftLog</code>​，获取<code>Term</code>​、<code>Vote</code>​等状态数据。另外，<code>c.peers</code>​有时会为空，这时也需要通过<code>Storage.InitialState()</code>​获取。节点初始身份为<code>follower</code>​。</p>
<h4 id="tick"><a href="#tick" class="headerlink" title="tick()"></a>tick()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tick() &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">switch</span> r.State &#123;</span><br><span class="line">	<span class="keyword">case</span> StateFollower:</span><br><span class="line">		r.tickFollower()</span><br><span class="line">	<span class="keyword">case</span> StateCandidate:</span><br><span class="line">		r.tickCandidate()</span><br><span class="line">	<span class="keyword">case</span> StateLeader:</span><br><span class="line">		r.tickLeader()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑时钟推进时，根据当前节点的身份状态选择下一步的处理。</p>
<p>对于<code>Follower</code>​和<code>Candidate</code>​，tick的作用是推进选举超时，如果一旦发现超时，首先清零选举超时，然后发起选举。这里发起选举是通过<code>Step()</code>​处理一个本地消息<code>MessageType_MsgHup</code>​触发的，后面会提到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickFollower() &#123;</span><br><span class="line">	r.electionElapsed += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> r.electionElapsed &gt;= r.randElectTimeout &#123;</span><br><span class="line">		r.electionElapsed = <span class="number">0</span></span><br><span class="line">		r.Step(pb.Message&#123;From: r.id, To: r.id, MsgType: pb.MessageType_MsgHup&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickCandidate() &#123;</span><br><span class="line">	r.electionElapsed += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> r.electionElapsed &gt;= r.randElectTimeout &#123;</span><br><span class="line">		r.electionElapsed = <span class="number">0</span></span><br><span class="line">		r.Step(pb.Message&#123;From: r.id, To: r.id, MsgType: pb.MessageType_MsgHup&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于<code>Leader</code>​，tick的作用是触发心跳超时。如果发现超时，同样清零以后再广播心跳给其他节点<code>BroadCastHeartBeat</code>​，这里广播心跳也是通过<code>Step()</code>​处理一个本地消息<code>MessageType_HeartBeat</code>​触发的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickLeader() &#123;</span><br><span class="line">	r.heartbeatElapsed += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> r.heartbeatElapsed &gt;= r.heartbeatTimeout &#123;</span><br><span class="line">		r.heartbeatElapsed = <span class="number">0</span></span><br><span class="line">		r.Step(pb.Message&#123;From: r.id, To: r.id, MsgType: pb.MessageType_MsgBeat&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="身份转换becomexxx"><a href="#身份转换becomexxx" class="headerlink" title="身份转换becomexxx"></a>身份转换becomexxx</h4><p>根据Raft算法，节点有三个身份状态：<code>follower</code>​、<code>candidate</code>​、<code>leader</code>​。一个顺利的选举流程的身份转换过程通常是：<code>follower-&gt;candidate-&gt;leader</code>​，其余情况大多都是切换回<code>follower</code>​。</p>
<p>在身份转换时要对raft节点的一些数据进行更改。</p>
<p>对于<code>becomefollower</code>​，需要更新<code>Vote</code>​、<code>State</code>​、<code>Term</code>​、<code>Lead</code>​，清空<code>votes</code>​、<code>leadTransferee</code>​，重置两个超时时间，最后随机化选举超时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// becomeFollower transform this peer&#x27;s state to Follower</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> becomeFollower(term <span class="type">uint64</span>, lead <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">if</span> term &gt; r.Term &#123;</span><br><span class="line">		r.Vote = None</span><br><span class="line">	&#125;</span><br><span class="line">	r.State = StateFollower</span><br><span class="line">	r.Term = term</span><br><span class="line">	r.Lead = lead</span><br><span class="line">	r.votes = <span class="literal">nil</span></span><br><span class="line">	r.voteCount = <span class="number">0</span></span><br><span class="line">	r.denialCount = <span class="number">0</span></span><br><span class="line">	r.leadTransferee = None</span><br><span class="line">	<span class="comment">// reset</span></span><br><span class="line">	r.heartbeatElapsed = <span class="number">0</span></span><br><span class="line">	r.electionElapsed = <span class="number">0</span></span><br><span class="line">	r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>becomeCandidate</code>​，根据Raft算法，要自增<code>Term</code>​，然后先投票给自己（如果当前集群只有一个节点，直接<code>becomeLeader</code>​）。也要重置超时，随机化选举超时。</p>
<p>对于<code>becomeLeader</code>​，可以看到注释里面提示：<code>// NOTE: Leader should propose a noop entry on its term</code>​，即需要向其他节点发送一条空条目，这是为了更新<code>Prs</code>​（Match代表已经匹配的Index，Next代表即将发送的下一个Index），来获取<code>follower</code>​的进度。</p>
<h3 id="step-消息处理"><a href="#step-消息处理" class="headerlink" title="step()消息处理"></a>step()消息处理</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> Step(m pb.Message) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="comment">// node is not in cluster or has been removed</span></span><br><span class="line">	<span class="keyword">switch</span> r.State &#123;</span><br><span class="line">	<span class="keyword">case</span> StateFollower:</span><br><span class="line">		<span class="keyword">return</span> r.stepFollower(m)</span><br><span class="line">	<span class="keyword">case</span> StateCandidate:</span><br><span class="line">		<span class="keyword">return</span> r.stepCandidate(m)</span><br><span class="line">	<span class="keyword">case</span> StateLeader:</span><br><span class="line">		<span class="keyword">return</span> r.stepLeader(m)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> stepFollower(m pb.Message) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.MsgType &#123;</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgHup:</span><br><span class="line">		r.handleHup()</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgPropose:</span><br><span class="line">		<span class="keyword">return</span> ErrProposalDropped</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgAppend:</span><br><span class="line">		r.handleAppendEntries(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgRequestVote:</span><br><span class="line">		r.handleRequestVote(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgSnapshot:</span><br><span class="line">		r.handleSnapshot(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgHeartbeat:</span><br><span class="line">		r.handleHeartbeat(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgTransferLeader:</span><br><span class="line">		r.handleTransferLeader(m)</span><br><span class="line">	<span class="keyword">case</span> pb.MessageType_MsgTimeoutNow:</span><br><span class="line">		r.handleHup()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​<code>Step</code>​结合当前节点身份状态<code>r.State</code>​和消息类型<code>MsgType</code>​选择要执行的动作。<strong>这部分是实现Raft层的重点</strong>，首先要理解各个Msg的作用以及含义。</p>
<p>文档中提到，对于一个Raft节点来说，Msg分本地消息和普通消息，其中普通消息是要发给其他节点的，要放到<code>r.msgs</code>​中供上层异步地取用；本地消息是本地发起的，因此套个<code>Step()</code>​直接进行消息处理。之前在<code>tick()</code>​中发起的就是本地消息<code>MsgHup</code>​和<code>MsgBeat</code>​</p>
<p>Raft 通过一个<code>Message</code>​结构体包含了所有种类的msg，所以其字段对于某一种msg会存在富余的情况，所以要结合raft算法来确定某一种msg设置了哪些字段，以及各个字段的作用是什么。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	MsgType              MessageType <span class="string">`protobuf:&quot;varint,1,opt,name=msg_type,json=msgType,proto3,enum=eraftpb.MessageType&quot; json:&quot;msg_type,omitempty&quot;`</span></span><br><span class="line">	To                   <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,2,opt,name=to,proto3&quot; json:&quot;to,omitempty&quot;`</span></span><br><span class="line">	From                 <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,3,opt,name=from,proto3&quot; json:&quot;from,omitempty&quot;`</span></span><br><span class="line">	Term                 <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,4,opt,name=term,proto3&quot; json:&quot;term,omitempty&quot;`</span></span><br><span class="line">	LogTerm              <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,5,opt,name=log_term,json=logTerm,proto3&quot; json:&quot;log_term,omitempty&quot;`</span></span><br><span class="line">	Index                <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,6,opt,name=index,proto3&quot; json:&quot;index,omitempty&quot;`</span></span><br><span class="line">	Entries              []*Entry    <span class="string">`protobuf:&quot;bytes,7,rep,name=entries&quot; json:&quot;entries,omitempty&quot;`</span></span><br><span class="line">	Commit               <span class="type">uint64</span>      <span class="string">`protobuf:&quot;varint,8,opt,name=commit,proto3&quot; json:&quot;commit,omitempty&quot;`</span></span><br><span class="line">	Snapshot             *Snapshot   <span class="string">`protobuf:&quot;bytes,9,opt,name=snapshot&quot; json:&quot;snapshot,omitempty&quot;`</span></span><br><span class="line">	Reject               <span class="type">bool</span>        <span class="string">`protobuf:&quot;varint,10,opt,name=reject,proto3&quot; json:&quot;reject,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>      <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>       <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tinykv中Raft的所有消息类型如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MessageType_name = <span class="keyword">map</span>[<span class="type">int32</span>]<span class="type">string</span>&#123;</span><br><span class="line">	<span class="number">0</span>:  <span class="string">&quot;MsgHup&quot;</span>,</span><br><span class="line">	<span class="number">1</span>:  <span class="string">&quot;MsgBeat&quot;</span>,</span><br><span class="line">	<span class="number">2</span>:  <span class="string">&quot;MsgPropose&quot;</span>,</span><br><span class="line">	<span class="number">3</span>:  <span class="string">&quot;MsgAppend&quot;</span>,</span><br><span class="line">	<span class="number">4</span>:  <span class="string">&quot;MsgAppendResponse&quot;</span>,</span><br><span class="line">	<span class="number">5</span>:  <span class="string">&quot;MsgRequestVote&quot;</span>,</span><br><span class="line">	<span class="number">6</span>:  <span class="string">&quot;MsgRequestVoteResponse&quot;</span>,</span><br><span class="line">	<span class="number">7</span>:  <span class="string">&quot;MsgSnapshot&quot;</span>,</span><br><span class="line">	<span class="number">8</span>:  <span class="string">&quot;MsgHeartbeat&quot;</span>,</span><br><span class="line">	<span class="number">9</span>:  <span class="string">&quot;MsgHeartbeatResponse&quot;</span>,</span><br><span class="line">	<span class="number">11</span>: <span class="string">&quot;MsgTransferLeader&quot;</span>,</span><br><span class="line">	<span class="number">12</span>: <span class="string">&quot;MsgTimeoutNow&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下列表汇总了所有消息类型的描述、有效字段，以及哪些身份状态需要处理该类型的消息：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>描述</th>
<th>有效字段</th>
<th>follower</th>
<th>candidate</th>
<th>leader</th>
</tr>
</thead>
<tbody><tr>
<td>MsgHup</td>
<td>本地消息，发起选举</td>
<td>MsgType<br></td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>MsgBeat</td>
<td>本地消息，Leader广播心跳，用于检查follower进度和避免新的选举</td>
<td>MsgType</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>MsgPropose</td>
<td>本地消息，来自上层应用的Propose请求。只有Leader实际处理，其他都返回<code>ErrProposalDropped</code>​</td>
<td>MsgType Entries To</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgAppend</td>
<td>用于Leader向其他节点同步数据，即日志复制。</td>
<td>MsgType Index Term LogTerm Entries Commit To From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgAppendResponse</td>
<td>用于回复收到的 <code>MessageType_MsgAppend</code>​ 和 <code>MessageType_MsgSnapshot</code>​。Leader据此更新Match和Next等记录</td>
<td>MsgType Index Term Reject To From</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>MsgRequestVote</td>
<td>candidate发送的投票请求</td>
<td>MsgType Index Term LogTerm To From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgRequestVoteResponse</td>
<td>投票响应</td>
<td>MsgType Term Reject To From</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>MsgSnapshot</td>
<td>project2c，当 Leader 发现目标节点所需的日志已经被 compact 的时候，则发送 Snapshot。</td>
<td>MsgType Term Snapshot To From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgHeartbeat</td>
<td>来自Leader的心跳消息</td>
<td>MsgType Term To From</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MsgHeartbeatResponse</td>
<td>心跳响应，包含当前follower的Commit索引，Leader据此判断它的进度</td>
<td>MsgType Term Commit To From Reject</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>MsgTransferLeader</td>
<td>本地消息，领导权转移，Project3A</td>
<td>MsgType From</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>MsgTimeoutNow</td>
<td>目标节点收到该消息，即刻自增 term 发起选举</td>
<td>MsgType From To<br></td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
</tbody></table>
<p>下面分为领导人选举和日志复制两个部分分别介绍这些消息的处理逻辑。</p>
<h3 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h3><h4 id="handleHup"><a href="#handleHup" class="headerlink" title="handleHup"></a>handleHup</h4><p>首先，<code>follower</code>​和<code>candidate</code>​选举超时都会触发<code>MsgHup</code>​，用于直接发起选举。<code>handleHup</code>的处理逻辑如下：</p>
<ol>
<li><p>判断能否进行选举：</p>
<ol>
<li>判断自己是否在当前的 Prs 里面。因为自己可能已经被移除（Project3 涉及）。</li>
<li>判断是否有 pendingSnapshot。如果正在 applying snapshot，则不要发起选举，因为一定是其他的 leader 发给你 snapshot，如果你发起选举，你的 term+1 必定大于现有的 leader，这会造成集群的不稳定。</li>
</ol>
</li>
<li><p>​<code>becomeCandidate</code>​</p>
</li>
<li><p>向其他所有节点发送投票请求<code>MsgRequestVote</code>​</p>
</li>
</ol>
<h4 id="handleRequestVote"><a href="#handleRequestVote" class="headerlink" title="handleRequestVote"></a>handleRequestVote</h4><p>​<code>follower</code>​、<code>candidate</code>​、<code>leader</code>​都有可能收到投票请求。在Raft论文中，为了避免已经提交的日志被覆盖保障一致性，除了最基本的任期条件，还增加了一个选举限制条件，即日志的新旧条件，具体可以再看一下论文中的描述。<code>handleRequestVote</code>的处理逻辑如下：</p>
<ol>
<li>如果任期比自己大，becomeFollower<strong>（此时不一定投票给他）</strong></li>
<li>如果任期没自己大，拒绝</li>
<li>如果当前任期已经投票了，且不是他，拒绝</li>
<li>如果日志比自己旧（比较最后一个条目的Term和Index，先比较Term，相等的情况下再比较Index），拒绝，否则<code>becomefollower</code>​并且投票给他</li>
</ol>
<h4 id="handleRequestVoteResponse"><a href="#handleRequestVoteResponse" class="headerlink" title="handleRequestVoteResponse"></a>handleRequestVoteResponse</h4><p>candidate收到投票响应后：</p>
<ol>
<li>如果任期比自己大，becomeFollower，此时直接返回</li>
<li>根据<code>Reject</code>​更新<code>r.votes、r.voteCount、r.denialCount</code>​</li>
<li>如果<code>r.voteCount</code>​超过半数，直接<code>becomeLeader</code>​，选举成功；<code>r.denialCount</code>​同理，如果超过半数，直接<code>becomeFollower</code>​，选举失败。</li>
</ol>
<blockquote>
<p>注意，不能直接<code>r.voteCount++</code>​和<code>r.denialCount++</code>​记录票数，而要通过遍历<code>r.votes</code>​，因为后面3B的测试中会出现重复的响应，会出现一直选举不出来的情况。</p>
</blockquote>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>节点成为Leader后，会不断向其他节点发送心跳来维持自己的地位，并通过心跳响应来了解其他节点的日志提交的进度，进而决定是否需要同步日志给他。</p>
<h4 id="handleBeat"><a href="#handleBeat" class="headerlink" title="handleBeat"></a>handleBeat</h4><p>直接广播heartbeat</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleBroadcastHeartBeat() &#123;</span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> r.Prs &#123;</span><br><span class="line">		<span class="keyword">if</span> peer == r.id &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		r.sendHeartbeat(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleHeartbeat"><a href="#handleHeartbeat" class="headerlink" title="handleHeartbeat"></a>handleHeartbeat</h4><p>只要根据<code>Term</code>决定是否<code>Reject</code>​，返回的响应中要附带<code>Commit</code>​，方便Leader收到后进行日志同步</p>
<h4 id="handleHeartbeatResponse"><a href="#handleHeartbeatResponse" class="headerlink" title="handleHeartbeatResponse"></a>handleHeartbeatResponse</h4><p>leader在收到心跳响应后</p>
<ol>
<li>判断返回的Term是否大于当前Term，如果是则<code>becomeFollower</code>​直接返回</li>
<li>根据follower的<code>Commit</code>​信息和leader中记录的<code>Match</code>​，判断leader是否需要同步日志给他</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleHeartBeatResponse(m pb.Message) &#123;</span><br><span class="line">	<span class="keyword">if</span> m.Term &gt; r.Term &#123;</span><br><span class="line">		r.becomeFollower(m.Term, None)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if it doesn&#x27;t have update-to-date log</span></span><br><span class="line">	<span class="keyword">if</span> m.Commit &lt; r.RaftLog.committed || r.Prs[m.From].Match &lt; r.RaftLog.LastIndex() &#123;</span><br><span class="line">		r.sendAppend(m.From)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点成为Leader后，上层应用会发送日志条目给他，即<code>MsgPropose</code>​，他需要将这些条目加入到自己的<code>RaftLog</code>​当中，然后同步给其他节点。</p>
<h4 id="handlePropose"><a href="#handlePropose" class="headerlink" title="handlePropose"></a>handlePropose</h4><p>只有leader处理，如果不是leader，直接返回<code>ErrPorosalDropped</code>​。</p>
<ol>
<li>判断<code>r.leadTransferee</code>​，如果正在进行领导权转移，不能接受propose，直接返回<code>ErrPorosalDropped</code>​（Project3A）</li>
<li>将propose消息中的<code>Entries</code>​加入到<code>r.RaftLog</code>​中</li>
<li>广播Append消息给其他节点，即<strong>日志复制</strong></li>
<li>尝试更新Commit，<code>tryUpdateCommit</code>​</li>
</ol>
<h4 id="sendAppend的实现"><a href="#sendAppend的实现" class="headerlink" title="sendAppend的实现"></a>sendAppend的实现</h4><p>​<code>sendAppend(to)</code>​即发送<code>MsgAppend</code>​给节点to，有许多值得注意的地方，各字段赋值如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := pb.Message&#123;</span><br><span class="line">	MsgType: pb.MessageType_MsgAppend,</span><br><span class="line">	To:      to,</span><br><span class="line">	From:    r.id,</span><br><span class="line">	Term:    r.Term,</span><br><span class="line">	LogTerm: preLogTerm,</span><br><span class="line">	Index:   preLogIndex,</span><br><span class="line">	Entries: sendEntreis,</span><br><span class="line">	Commit:  r.RaftLog.committed,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>LogTerm、Index</code>​分别代表论文中的<code>preLogTerm、preLogIndex</code>​（<code>preLogTerm = Term(Next-1)、preLogIndex = Next-1</code>​），是进行日志匹配的关键项，根据论文中的定理，如果在next-1的位置处匹配（即Term相同），代表之前的所有日志都匹配，就可以放心地接收<code>Next</code>​往后的所有条目了。</p>
<p>​<code>Commit</code>​的作用如上所述是让其他节点也能更新自己的<code>committed</code>​。</p>
<blockquote>
<p>在project2C中，当Leader找不到<code>preLogIndex</code>​对应的日志条目时，代表它已经被Compact掉了，也代表节点to落后自己太多了，此时不再发送append消息，而是发送一个Snapshot给它。</p>
</blockquote>
<h4 id="tryUpdateCommit的实现"><a href="#tryUpdateCommit的实现" class="headerlink" title="tryUpdateCommit的实现"></a>tryUpdateCommit的实现</h4><p>Leader需要根据集群所有节点的进度更新自己的Commit同时推进其他节点的Commit，日志的提交需要满足“大多数”的条件，只有当日志被提交以后才能被上层实际应用。</p>
<p>根据Raft算法， 我们取所有<code>Match</code>​的中位数，如果有更新，则广播给其他节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tryUpdateCommit() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(r.Prs) == <span class="number">1</span> &#123;</span><br><span class="line">		r.RaftLog.committed = r.RaftLog.LastIndex()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get all match</span></span><br><span class="line">	<span class="keyword">var</span> matches []<span class="type">uint64</span></span><br><span class="line">	<span class="keyword">for</span> peer := <span class="keyword">range</span> r.Prs &#123;</span><br><span class="line">		<span class="keyword">if</span> peer == r.id &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		matches = <span class="built_in">append</span>(matches, r.Prs[peer].Match)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(UInt64Slice(matches))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get mid</span></span><br><span class="line">	midIndex := matches[<span class="built_in">len</span>(matches)/<span class="number">2</span>]</span><br><span class="line">	midTerm, _ := r.RaftLog.Term(midIndex)</span><br><span class="line">	<span class="comment">// if mid &gt; commit, update commit</span></span><br><span class="line">	<span class="keyword">if</span> midIndex &gt; r.RaftLog.committed &amp;&amp; midTerm == r.Term &#123;</span><br><span class="line">		r.RaftLog.committed = midIndex</span><br><span class="line">		<span class="comment">// send append to all peers</span></span><br><span class="line">		r.bcastAppend()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleAppendEntries"><a href="#handleAppendEntries" class="headerlink" title="handleAppendEntries"></a>handleAppendEntries</h4><p>这部分是实现日志复制的核心，有很多需要注意的细节。</p>
<p>我的实现步骤如下：</p>
<ol>
<li>如果比当前任期小，直接返回拒绝</li>
<li>becomeFollower()</li>
<li>如果<code>m.Index</code>​比当前节点的lastIndex要大，说明Next-1 &gt; lastIndex，显然Next要减小一点，于是直接拒绝，返回的响应中 Index &#x3D; lastIndex + 1，让 Next减小到lastIndex+1（日志复制部分要注意理解<code>r.Prs</code>​中<code>Match</code>​和<code>Next</code>​字段的含义）</li>
<li>如果<code>r.RaftLog.Term(m.Index)</code>​与<code>m.LogTerm</code>​不相同，说明在<code>m.Index</code>​处发生冲突，接下来论文中的原始做法是返回<code>Index = m.Index</code>​，从而让Next &#x3D; <code>m.Index</code>​，即Next–。优化做法是返回在<code>r.RaftLog.Term(m.Index)</code>​这一任期下该节点的第一条日志的索引<code>conflictIndex</code>​，即让Next &#x3D; <code>conflictIndex</code>​，这样能加快日志匹配的速度。</li>
<li>如果上述两种情况都没有发生，说明该节点在<code>m.Index</code>​及之前的日志与Leader都是匹配，因此可以“接受”这个Append请求。但是有一种特殊情况需要考虑，就是被append的所有日志条目<code>m.Entries</code>​已经在该节点中存在了，这时可能后面还有一些日志条目，因此不能无脑截断然后append，如果没有冲突应当要保留这些多出来的日志。我的做法是首先判断该节点在<code>m.Index</code>​往后的日志长度是否大于<code>len(m.Entries)</code>​，如果不大于则可以无脑截断然后append，如果大于，则要逐个检查是否与<code>m.Entries</code>​中的条目相匹配，满足则不做任何修改，只要一个条目有冲突都直接截断然后append。</li>
<li>accept之后，要根据<code>m.Commit</code>​对<code>r.RaftLog.committed</code>​进行更新，我的做法是<code>r.RaftLog.committed = min(m.Commit, m.Index+uint64(len(m.Entries)))</code>​</li>
<li>返回accpet的响应，注意对<code>Index</code>​的设置</li>
</ol>
<h4 id="handleAppendResponse"><a href="#handleAppendResponse" class="headerlink" title="handleAppendResponse"></a>handleAppendResponse</h4><p>根据Raft算法，当leader收到Reject Append的响应后，要更新<code>Next</code>​（回退到某个可能匹配的位置），然后重新<code>sendAppend</code>​。</p>
<p>在<code>MsgAppendResponse m</code>​中：</p>
<ol>
<li>若<code>Reject == true</code>​，<code>m.Index</code>​代表Next需要回退到的位置；</li>
<li>若<code>Reject == false</code>​，<code>m.Index</code>​代表最新匹配的位置，即新的<code>Match</code>​值。</li>
</ol>
<p>因此，具体处理流程如下：</p>
<ol>
<li>如果<code>m.Term</code>​大于当前任期，Leader直接<code>becomeFollower</code>​并返回</li>
<li>如果<code>m.Reject == true</code>​，令<code>r.Prs[m.From].Next = m.Index</code>​，重新调用<code>sendAppend</code>​</li>
<li>如果<code>m.Reject == false &amp;&amp; m.Index &gt; r.Prs[m.From].Match</code>​，说明该follower接收了新的条目，更新对应的<code>Match</code>​和<code>Next</code>​，调用<code>tryUpdateCommit</code>​尝试提交日志条目。</li>
</ol>
<p>‍</p>
<p>以上就实现了基本的领导人选举和日志复制，后面的项目还会增加<code>Snapshot</code>​、<code>TransferLeader</code>​等操作。</p>
<h3 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h3><h4 id="选举超时随机化"><a href="#选举超时随机化" class="headerlink" title="选举超时随机化"></a>选举超时随机化</h4><p>根据raft论文，每次触发选举超时都要对这个超时时间进行随机化，能够有效减少选举冲突的情况发生。我的做法是在<code>becomexxx</code>​函数，即节点状态变更的函数中都加入以下代码来进行时间重置和选举超时随机化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">r.heartbeatElapsed = 0</span><br><span class="line">r.electionElapsed = 0</span><br><span class="line">r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</span><br></pre></td></tr></table></figure>

<p>那么如何进行随机化？从哪里知道使用<code>r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</code>​，即控制在<code>[et,2et]</code>​之间呢？</p>
<p>这是从2AA的测试点<code>testNonleaderElectionTimeoutRandomized</code>​中得知的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">func testNonleaderElectionTimeoutRandomized(t *testing.T, state StateType) &#123;</span><br><span class="line">	et := 10</span><br><span class="line">	r := newTestRaft(1, []uint64&#123;1, 2, 3&#125;, et, 1, NewMemoryStorage())</span><br><span class="line">	timeouts := make(map[int]bool)</span><br><span class="line">	<span class="keyword">for</span> round := 0; round &lt; 50*et; round++ &#123;</span><br><span class="line">		switch state &#123;</span><br><span class="line">		<span class="keyword">case</span> StateFollower:</span><br><span class="line">			r.becomeFollower(r.Term+1, 2)</span><br><span class="line">		<span class="keyword">case</span> StateCandidate:</span><br><span class="line">			r.becomeCandidate()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time := 0</span><br><span class="line">		<span class="keyword">for</span> len(r.readMessages()) == 0 &#123;</span><br><span class="line">			r.tick()</span><br><span class="line">			time++</span><br><span class="line">		&#125;</span><br><span class="line">		timeouts[time] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> d := et + 1; d &lt; 2*et; d++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !timeouts[d] &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;timeout in %d ticks should happen&quot;</span>, d)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述测试代码做的事情就是进行足够多次的模拟，验证随机化的选举超时有没有覆盖<code>[et+1,2et)</code>​。由此可知随机化的具体标准。</p>
<h4 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h4><p>在2aa测试点中经常出现集群只有一个节点的情况，因此要对这种情况做特殊处理，使Candidate直接成为leader。</p>
<p>“给其他节点发送投票请求”时要注意附带<code>Term、LogTerm、Index</code>​三个字段，其中<code>LogTerm</code>​是最大日志的任期，<code>Index</code>​是最大日志的索引，其他节点可以通过它们来判断投票发起者的日志是否比自己的新，日志比自己旧那么就投反对票。这样就实现了论文中的“选举限制”，保障了安全性。</p>
<h4 id="becomeLeader"><a href="#becomeLeader" class="headerlink" title="becomeLeader"></a>becomeLeader</h4><p>​<code>becomeLeader</code>​存在一些需要特别注意的特殊处理：</p>
<ol>
<li><p>初始化<code>r.Prs</code>​，即每个节点的<code>Progress&#123;Match, Next&#125;</code>​。之前提到过是用于leader维护各节点日志复制的进度（Match代表已经匹配的Index，Next代表即将发送的下一个Index）。Match初始化为0即可，Next则要初始化为<code>r.RaftLog.LastIndex() + 1</code>​，代表后续给其他节点同步日志都先从<code>Next</code>​的位置开始，发生冲突再让对应节点的<code>Next</code>​回退。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, peer := range r.Prs &#123;</span><br><span class="line">	peer.Match = 0</span><br><span class="line">	peer.Next = r.RaftLog.LastIndex() + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据文档和代码注释中的提示“<code>Leader should propose a noop entry on its term</code>​”，也就是<code>becomeLeader</code>​时append一个在Leader任期下的一个空条目，这样做的目的是让所有节点进行一次初始的日志同步操作</p>
</li>
</ol>
<h4 id="broadCastAppend"><a href="#broadCastAppend" class="headerlink" title="broadCastAppend"></a>broadCastAppend</h4><p>我的raft实现中主要有两处要<code>broadCastAppend</code>​，一处是上面提到的<code>becomeLeader</code>​，一处是<code>handlePropose</code>​（接收来自上层的日志条目）。</p>
<p>在每次<code>broadCastAppend</code>​之后都要立即<code>tryUpdateCommit</code>​而不等待<code>AppendResponse</code>​，这是考虑了单节点这一特殊情况，否则单节点将永远无法更新自己的<code>committed</code>​。</p>
<h4 id="handleAppendEntries-1"><a href="#handleAppendEntries-1" class="headerlink" title="handleAppendEntries"></a>handleAppendEntries</h4><p>​<code>handleAppendEntries</code>​的实现一定要仔细，注意覆盖所有的条件，注意测试点中提出的要求。</p>
<p>例如，在日志匹配的前提下，对于目标节点超出<code>preLogIndex</code>​的日志条目，不能够无脑截断掉。因为这些条目很可能与即将append的条目也是完全匹配的，那么再往后多出来的部分就不能够删除掉而要保留下来，因为本质上没做任何修改。</p>
<p>例如，在日志不匹配的前提下，同样不能对目标节点的日志做任何修改。我一开始为了方便处理，对于目标节点超出<code>preLogIndex</code>​的日志条目都直接截断掉，结果很多测试出现问题。</p>
<h4 id="消息处理的幂等性"><a href="#消息处理的幂等性" class="headerlink" title="消息处理的幂等性"></a>消息处理的幂等性</h4><p>文档中有这么一句描述：</p>
<blockquote>
<p>Raft RPC是幂等的,收到相同的RPC不会由任何危害.例如，如果追随者收到一个AppendEntries请求，其中包含其日志中已经存在的日志条目，则会忽略新请求中的这些条目。</p>
</blockquote>
<p>所以我们在实现各种handle函数时，要经常考虑有重复请求的情况，例如重复的投票，重复的append消息等等。</p>
<p>‍</p>
<h3 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h3><p>2aa和2ab的测试大多数问题都可以靠错误日志发现原因。发生错误时，可以看看测试点的代码，里面可能有一些特殊的要求，对应的修改即可。</p>
<p>我在<code>testCandidateResetTerm</code>​遇到过测试卡死，通过输出发现问题原因是处理<code>Msg_Append</code>​时逻辑出错，导致日志冲突而<code>next</code>​没有发生变化，所以死循环了，一直在sendAppend。</p>
<p>这一部分问题比较多的就是<code>handleAppendEntries</code>​，我当时也是改了很多次才形成了最终的这个版本。</p>
<p>‍</p>
<h2 id="project2ac-RawNode-Ready"><a href="#project2ac-RawNode-Ready" class="headerlink" title="project2ac RawNode Ready"></a>project2ac RawNode Ready</h2><p>这一部分代码主要在<code>raft/rawnode.go</code>​，在理解了具体要求之后实现比较简单。</p>
<p><code>RawNode</code>​是对<code>Raft</code>​的一个封装，提供了Raft模块与上层交互的相关函数。</p>
<ol>
<li>​<code>Ready()</code>​：返回一个Ready类型的数据，其中包含了当前Raft节点的状态，上层应用根据Ready中的数据进行持久化、日志条目的应用等操作。</li>
<li>​<code>HasReady()</code>​：判断是否有状态更新。</li>
<li>​<code>Advance(rd Ready)</code>​：由上层应用处理完某个Ready调用，用来更新Raft节点的一些状态。</li>
</ol>
<p>首先我们需要考虑<code>RawNode</code>​的类定义中除了<code>Raft</code>​还需要什么成员。</p>
<p>​<code>Ready</code>​类定义如下：</p>
<ol>
<li>​<code>*SoftState</code>​：包含<code>Lead</code>​和<code>RaftState</code>​</li>
<li>​<code>pb.HardState</code>​：包含<code>Term</code>​、<code>Vote</code>​、<code>Commit</code>​</li>
<li>​<code>Entrise</code>​：存放还没持久化的所有条目</li>
<li>​<code>Snapshot</code>​：存放需要应用的snapshot</li>
<li>​<code>CommittedEntries</code>​：存放已经提交但是还没有被应用的日志条目</li>
<li>​<code>Messages</code>​：存放raft节点中需要转发的一些消息（RequestVote、AppendEntries等等）</li>
</ol>
<p>由上面的定义可以得知我们的<code>HasReady()</code>​需要对这6种数据进行检查，看是否有更新，后四个都只需要判断有没有即可，前两个则需要观察是否有变化，所以<code>RawNode</code>​的定义中要包含<code>prevSoftState</code>​和<code>prevHardState</code>​。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RawNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Raft *Raft</span><br><span class="line">	<span class="comment">// Your Data Here (2A).</span></span><br><span class="line">	prevSoftState *SoftState</span><br><span class="line">	prevHardState pb.HardState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<code>NewRaftNode</code>​也很简单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRawNode</span><span class="params">(config *Config)</span></span> (*RawNode, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	raft := newRaft(config)</span><br><span class="line">	rn := &amp;RawNode&#123;</span><br><span class="line">		Raft: raft,</span><br><span class="line">		prevSoftState: &amp;SoftState&#123;</span><br><span class="line">			Lead:      raft.Lead,</span><br><span class="line">			RaftState: raft.State,</span><br><span class="line">		&#125;,</span><br><span class="line">		prevHardState: pb.HardState&#123;</span><br><span class="line">			Term:   raft.Term,</span><br><span class="line">			Vote:   raft.Vote,</span><br><span class="line">			Commit: raft.RaftLog.committed,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<code>HasReady()</code>​检查是否有状态更新；<code>Ready()</code>​提取这些更新的状态数据，需要注意的是获取<code>Raft.msgs</code>​之后要clear掉，并且骨架代码中已经提供了很多辅助函数，例如<code>isHardStateEqual</code>​、<code>isEmptySnap</code>​等。</p>
<p>​<code>Advance()</code>​需要做的是更新两个索引值<code>stabled</code>​和<code>applied</code>​，同时<code>update prevSoftState、prevHardState</code>​即可。从这个函数可以看出上层对于Ready中的数据处理主要为“持久化”和“应用”两个方面。</p>
<p>‍</p>
<p>最后附上通过的截图（太长了只截取了一部分）</p>
<p>​<img src="/2024/05/03/tinykv_project2a_solution/image-20240503164749-1q2mgqe.png" alt="image">​</p>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project2B思路</title>
    <url>/2024/05/08/tinykv_project2b_solution/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Request执行流程和调用链分析"><a href="#Request执行流程和调用链分析" class="headerlink" title="Request执行流程和调用链分析"></a>Request执行流程和调用链分析</h2><p>梳理tinykv中Request执行流程和调用链有助于理解project2B文档的要求和需要实现的逻辑，推荐看一看Talent Plan学习营分享课的对应部分，里面对Request执行流程分析的很到位。</p>
<p><a href="https://learn.pingcap.cn/learner/player/510002;id=510002;classroomId=720002;rcoId=630196;courseDetailId=510001;learnerAttemptId=1714889943880">Talent Plan 2021 KV 学习营分享课 (pingcap.cn)</a></p>
<p>我这里就照搬一下原视频中的图片。</p>
<p>​<img src="/2024/05/08/tinykv_project2b_solution/image-20240507201618-rk4gvqa.png" alt="image">​</p>
<p>‍</p>
<h3 id="1-Server-RaftStorage"><a href="#1-Server-RaftStorage" class="headerlink" title="1 Server -&gt; RaftStorage"></a>1 Server -&gt; RaftStorage</h3><p>当一个请求req到达时，首先Server对其进行一层封装传到RaftStorage。</p>
<p>server接口：proto&#x2F;pkg&#x2F;tinykvpb&#x2F;tinykvpb.pb.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server API for TinyKv service</span></span><br><span class="line"><span class="keyword">type</span> TinyKvServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// KV commands with mvcc/txn supported.</span></span><br><span class="line">	KvGet(context.Context, *kvrpcpb.GetRequest) (*kvrpcpb.GetResponse, <span class="type">error</span>)</span><br><span class="line">	KvScan(context.Context, *kvrpcpb.ScanRequest) (*kvrpcpb.ScanResponse, <span class="type">error</span>)</span><br><span class="line">	KvPrewrite(context.Context, *kvrpcpb.PrewriteRequest) (*kvrpcpb.PrewriteResponse, <span class="type">error</span>)</span><br><span class="line">	KvCommit(context.Context, *kvrpcpb.CommitRequest) (*kvrpcpb.CommitResponse, <span class="type">error</span>)</span><br><span class="line">	KvCheckTxnStatus(context.Context, *kvrpcpb.CheckTxnStatusRequest) (*kvrpcpb.CheckTxnStatusResponse, <span class="type">error</span>)</span><br><span class="line">	KvBatchRollback(context.Context, *kvrpcpb.BatchRollbackRequest) (*kvrpcpb.BatchRollbackResponse, <span class="type">error</span>)</span><br><span class="line">	KvResolveLock(context.Context, *kvrpcpb.ResolveLockRequest) (*kvrpcpb.ResolveLockResponse, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// RawKV commands.</span></span><br><span class="line">	RawGet(context.Context, *kvrpcpb.RawGetRequest) (*kvrpcpb.RawGetResponse, <span class="type">error</span>)</span><br><span class="line">	RawPut(context.Context, *kvrpcpb.RawPutRequest) (*kvrpcpb.RawPutResponse, <span class="type">error</span>)</span><br><span class="line">	RawDelete(context.Context, *kvrpcpb.RawDeleteRequest) (*kvrpcpb.RawDeleteResponse, <span class="type">error</span>)</span><br><span class="line">	RawScan(context.Context, *kvrpcpb.RawScanRequest) (*kvrpcpb.RawScanResponse, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Raft commands (tinykv &lt;-&gt; tinykv).</span></span><br><span class="line">	Raft(TinyKv_RaftServer) <span class="type">error</span></span><br><span class="line">	Snapshot(TinyKv_SnapshotServer) <span class="type">error</span></span><br><span class="line">	<span class="comment">// Coprocessor</span></span><br><span class="line">	Coprocessor(context.Context, *coprocessor.Request) (*coprocessor.Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server实现：kv&#x2F;server&#x2F;server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	storage storage.Storage</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (Used in 4B)</span></span><br><span class="line">	Latches *latches.Latches		<span class="comment">// 锁集合，实现多版本并发控制</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// coprocessor API handler, out of course scope</span></span><br><span class="line">	copHandler *coprocessor.CopHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前主要需要看Storage，在此处使用的是kv&#x2F;storage&#x2F;raft_storage&#x2F;raft_server.go中实现的<code>RaftStorage</code>​。</p>
<p>以它的<code>Write</code>​功能为例，首先将<code>batch</code>​中的<code>put、Get、Delete</code>​抽出来封装在<code>raft_cmdpb.Request</code>​中，再添加一些<code>header</code>​等打包成一个<code>RaftCommand</code>​发送给下层</p>
<p>​<code>RaftStorage</code>​就是Project2和Project3中需要实现的代码处理</p>
<h3 id="2-RaftStorage-Peer"><a href="#2-RaftStorage-Peer" class="headerlink" title="2 RaftStorage -&gt; Peer"></a>2 RaftStorage -&gt; Peer</h3><p>RaftStorage定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	engines *engine_util.Engines</span><br><span class="line">	config  *config.Config</span><br><span class="line"></span><br><span class="line">	node          *raftstore.Node</span><br><span class="line">	snapManager   *snap.SnapManager</span><br><span class="line">	raftRouter    *raftstore.RaftstoreRouter</span><br><span class="line">	raftSystem    *raftstore.Raftstore</span><br><span class="line">	resolveWorker *worker.Worker</span><br><span class="line">	snapWorker    *worker.Worker</span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RaftstoreRouter <span class="keyword">struct</span> &#123;</span><br><span class="line">	router *router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	peers       sync.Map <span class="comment">// regionID -&gt; peerState</span></span><br><span class="line">	peerSender  <span class="keyword">chan</span> message.Msg</span><br><span class="line">	storeSender <span class="keyword">chan</span>&lt;- message.Msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是<code>RaftstoreRouter</code>​，它是对<code>router</code>​的封装。router中有两个channel，都是生产者，作为中心的消息路由。<code>RaftstoreRouter</code>​增加了两个意义更加明确的函数<code>SendTaftMessage</code>​、<code>SendRaftCommand</code>​，用于传递消息给<code>peer</code>​。调用<code>router</code>​的<code>send</code>​接口就会把Msg传递给<code>peerSender</code>​这个channel。</p>
<p>以上就是消息生产者的部分，接下来看消费者的部分。</p>
<p>​<code>Server</code>​传到<code>RaftStorage</code>​的消息分<code>kv</code>​和<code>raft</code>​，对应<code>RaftStorage</code>​封装后分别是<code>RaftCmd</code>​和<code>RaftMessage</code>​，经过<code>Rounter</code>​，<code>RaftCmd</code>​会走到<code>RatfWorker</code>​（peer层前面专门处理Msg）里面，<code>RaftMessage</code>​会给到<code>StoreWorker</code>​，它会做一些region上的处理，同时把Msg再送到<code>RaftWoker</code>​里面去。</p>
<p>kv&#x2F;raftstore&#x2F;raft_worker.go：<code>raftWorker</code>​作为消费者，可以看到在初始创建的时候会拿到<code>router</code>​的<code>peerSender</code>​channel</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> raftWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">	pr *router</span><br><span class="line"></span><br><span class="line">	<span class="comment">// receiver of messages should sent to raft, including:</span></span><br><span class="line">	<span class="comment">// * raft command from `raftStorage`</span></span><br><span class="line">	<span class="comment">// * raft inner messages from other peers sent by network</span></span><br><span class="line">	raftCh <span class="keyword">chan</span> message.Msg</span><br><span class="line">	ctx    *GlobalContext</span><br><span class="line"></span><br><span class="line">	closeCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRaftWorker</span><span class="params">(ctx *GlobalContext, pm *router)</span></span> *raftWorker &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;raftWorker&#123;</span><br><span class="line">		raftCh: pm.peerSender,</span><br><span class="line">		ctx:    ctx,</span><br><span class="line">		pr:     pm,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<code>raftWorker</code>​跑起来之后会批量地取<code>peerSender</code>​中Msg，取了之后通过当前的PeerState生成<code>PeerMsgHandler</code>​来<code>HandleMsg</code>​。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *raftWorker)</span></span> run(closeCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup) &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">var</span> msgs []message.Msg</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msgs = msgs[:<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-closeCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-rw.raftCh:</span><br><span class="line">			msgs = <span class="built_in">append</span>(msgs, msg)</span><br><span class="line">		&#125;</span><br><span class="line">		pending := <span class="built_in">len</span>(rw.raftCh)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pending; i++ &#123;</span><br><span class="line">			msgs = <span class="built_in">append</span>(msgs, &lt;-rw.raftCh)</span><br><span class="line">		&#125;</span><br><span class="line">		peerStateMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*peerState)</span><br><span class="line">		<span class="keyword">for</span> _, msg := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			peerState := rw.getPeerState(peerStateMap, msg.RegionID)</span><br><span class="line">			<span class="keyword">if</span> peerState == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			newPeerMsgHandler(peerState.peer, rw.ctx).HandleMsg(msg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, peerState := <span class="keyword">range</span> peerStateMap &#123;</span><br><span class="line">			newPeerMsgHandler(peerState.peer, rw.ctx).HandleRaftReady()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此消息传递的流程大致如下：</p>
<p>​<img src="/2024/05/08/tinykv_project2b_solution/image-20240507202804-i9vjfjf.png" alt="image">​</p>
<h3 id="3-Peer-RawNode-Raft"><a href="#3-Peer-RawNode-Raft" class="headerlink" title="3 Peer -&gt; RawNode_Raft"></a>3 Peer -&gt; RawNode_Raft</h3><p>kv&#x2F;raftstore&#x2F;peer_msg_handler.go 就是在Project2中主要需要实现的代码文件。我们要实现的第一个func就是<code>proposeRaftCommand</code>​。此时由于请求还没走到Raft层，现在需要把它预先丢给Raft层，在经过共识之后才能实际地去应用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> HandleMsg(msg message.Msg) &#123;</span><br><span class="line">	<span class="keyword">switch</span> msg.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeRaftMessage:</span><br><span class="line">		raftMsg := msg.Data.(*rspb.RaftMessage)</span><br><span class="line">		<span class="keyword">if</span> err := d.onRaftMsg(raftMsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Errorf(<span class="string">&quot;%s handle raft message error %v&quot;</span>, d.Tag, err)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeRaftCmd:</span><br><span class="line">		raftCMD := msg.Data.(*message.MsgRaftCmd)</span><br><span class="line">		d.proposeRaftCommand(raftCMD.Request, raftCMD.Callback)</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeTick:</span><br><span class="line">		d.onTick()</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeSplitRegion:</span><br><span class="line">		split := msg.Data.(*message.MsgSplitRegion)</span><br><span class="line">		log.Infof(<span class="string">&quot;%s on split with %v&quot;</span>, d.Tag, split.SplitKey)</span><br><span class="line">		d.onPrepareSplitRegion(split.RegionEpoch, split.SplitKey, split.Callback)</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeRegionApproximateSize:</span><br><span class="line">		d.onApproximateRegionSize(msg.Data.(<span class="type">uint64</span>))</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeGcSnap:</span><br><span class="line">		gcSnap := msg.Data.(*message.MsgGCSnap)</span><br><span class="line">		d.onGCSnap(gcSnap.Snaps)</span><br><span class="line">	<span class="keyword">case</span> message.MsgTypeStart:</span><br><span class="line">		d.startTicker()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> proposeRaftCommand(msg *raft_cmdpb.RaftCmdRequest, cb *message.Callback) &#123;</span><br><span class="line">	err := d.preProposeRaftCommand(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cb.Done(ErrResp(err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Your Code Here (2B).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-RawNode-Raft-Peer"><a href="#4-RawNode-Raft-Peer" class="headerlink" title="4 RawNode_Raft -&gt; Peer"></a>4 RawNode_Raft -&gt; Peer</h2><p>当日志条目被Raft层提交以后，根据<code>Project2A</code>​，<code>Peer</code>​会通过<code>RawNode.Ready()</code>​异步地获取已经被提交的条目进行应用。我们回到刚才kv&#x2F;raftstore&#x2F;raft_worker.go中<code>run</code>​函数，可以看到在调用<code>HandleMsg(msg)</code>​之后，会批量地生成<code>PeerMsgHandler</code>​来<code>HandleRaftReady()</code>​。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *raftWorker)</span></span> run(closeCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup) &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">var</span> msgs []message.Msg</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msgs = msgs[:<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-closeCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-rw.raftCh:</span><br><span class="line">			msgs = <span class="built_in">append</span>(msgs, msg)</span><br><span class="line">		&#125;</span><br><span class="line">		pending := <span class="built_in">len</span>(rw.raftCh)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pending; i++ &#123;</span><br><span class="line">			msgs = <span class="built_in">append</span>(msgs, &lt;-rw.raftCh)</span><br><span class="line">		&#125;</span><br><span class="line">		peerStateMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*peerState)</span><br><span class="line">		<span class="keyword">for</span> _, msg := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			peerState := rw.getPeerState(peerStateMap, msg.RegionID)</span><br><span class="line">			<span class="keyword">if</span> peerState == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			newPeerMsgHandler(peerState.peer, rw.ctx).HandleMsg(msg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, peerState := <span class="keyword">range</span> peerStateMap &#123;</span><br><span class="line">			newPeerMsgHandler(peerState.peer, rw.ctx).HandleRaftReady()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实现的重点就是<code>HandleRaftReady()</code>​，这个函数执行的大致逻辑如下：</p>
<ol>
<li><p>首先判断有没有Ready，这需要调用Raft层的判断函数<code>HasReady()</code>​（raft&#x2F;rawnode.go），如果没有的话就说明共识还没完成，如果有的话就会进行Apply</p>
</li>
<li><p>如果要进行Apply的话，首先需要保存memory states 到磁盘当中，需要实现<code>SaveReadyState()</code>​（kv&#x2F;raftstore&#x2F;peer_storage.go），<code>SaveReadyState</code>​会做两件事情：</p>
<ol>
<li>将当前的Raft日志持久化，把已经Ready，可以Apply的一些状态保存下来</li>
<li>保存snapshot（2C实现）</li>
</ol>
</li>
<li><p>接下来就是实际上去进行Apply的逻辑，对kv进行实际的写入读取等操作。</p>
</li>
<li><p>在此之后，我们就可以<code>Advance</code>​（raft&#x2F;rawnode.go）了。这个我们在Project2A已经完成了，<code>Advance</code>​做的事情也就是在实际完成Apply之后，Raft层中的节点的<code>RaftLog</code>​中的<code>stable、applied</code>​进行更新，同时也要更新一下<code>RaftNode</code>​中的<code>prevSoftState</code>​、<code>prevHardState</code>​（用于后续的状态对比<code>HasReady</code>​）。</p>
</li>
</ol>
<p>‍</p>
<p>总结一下，我们在Project2B中需要实现Request流程中的以下几个环节：</p>
<ol>
<li>Propose，通过<code>peerMsgHandler.proposeRaftCommand</code>​向Raft层传递日志条目</li>
<li>获取Ready -&gt; Stable log（对应kv&#x2F;raftstore&#x2F;peer_storage.go中的<code>PeerStorage.SaveReadyState()</code>​） -&gt; Apply（同时CallBack）-&gt;Advance更新Raft节点状态，这些都是<code>peerMsgHandler.HandleRaftReady()</code>​需要实现的。</li>
</ol>
<p>‍</p>
<p>下面讲述Project2B的实现思路</p>
<h2 id="PeerStorage"><a href="#PeerStorage" class="headerlink" title="PeerStorage"></a>PeerStorage</h2><p>PeerStorage部分主要实现<code>SaveReadyState</code>​函数，对应Stable log环节，顾名思义，需要持久化一些数据。</p>
<p>根据文档，这个函数的作用是将<code>raft.Ready</code>​中更新的数据保存到 badger 中（即持久化），包括追加日志条目、保存 Raft HardState、应用Snapshot（2C）等。</p>
<h3 id="Append实现"><a href="#Append实现" class="headerlink" title="Append实现"></a>Append实现</h3><p>追加日志对应<code>PeerStorage.Append()</code>​，根据已有的注释，该函数将给定的条目Append到raftDB，并更新ps.raftState，还将删除永远不会提交的日志条目。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Append the given entries to the raft log and update ps.raftState also delete log entries that will</span></span><br><span class="line"><span class="comment">// never be committed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> Append(entries []eraftpb.Entry, raftWB *engine_util.WriteBatch) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2B).</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是封装好一个<code>WriteBatch</code>​，方便后续对<code>raftDB</code>​进行<code>WriteToDB</code>​，实现持久化。</p>
<p>执行步骤：</p>
<ol>
<li>​<code>if len(entries) == 0</code>​，返回</li>
<li>获取<code>stableLast := entries[len(entries)-1].Index</code>​，<code>prevLast, _ := ps.LastIndex()</code>​，分别代表目前需要持久化的最大Index，和已经持久化的最大Index。</li>
<li>更新当前peerStorage的raftState的<code>LastIndex</code>​和<code>LastTerm</code>​</li>
<li>遍历<code>entries</code>​，调用<code>raftWB.SetMeta</code>​实现Append</li>
<li>最后需要删除的条目对应索引<code>[stableLast + 1, preLast]</code>​，这些条目永远都不会提交（常见的一种情况是被覆盖掉了），通过调用<code>raftWB.DeleteMeta</code>​实现。</li>
</ol>
<h3 id="SaveReadyState-实现"><a href="#SaveReadyState-实现" class="headerlink" title="SaveReadyState 实现"></a>SaveReadyState 实现</h3><p>这个函数实现比较简单，目前不用实现ApplySnapshot，因此按以下步骤：</p>
<ol>
<li>Append日志条目</li>
<li>更新<code>raftState.HardState</code>​</li>
<li>持久化日志条目和更新后的<code>raftState</code>​，也是通过<code>SetMeta</code>​实现</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> SaveReadyState(ready *raft.Ready) (*ApplySnapResult, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Hint: you may call `Append()` and `ApplySnapshot()` in this function</span></span><br><span class="line">	<span class="comment">// Your Code Here (2B/2C).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. append</span></span><br><span class="line">	wb := &amp;engine_util.WriteBatch&#123;&#125;</span><br><span class="line">	ps.Append(ready.Entries, wb)</span><br><span class="line">	<span class="comment">// 2. update hardstate and save raftState</span></span><br><span class="line">	<span class="keyword">if</span> !raft.IsEmptyHardState(ready.HardState) &#123;</span><br><span class="line">		ps.raftState.HardState = &amp;ready.HardState</span><br><span class="line">	&#125;</span><br><span class="line">	wb.SetMeta(meta.RaftStateKey(ps.region.Id), ps.raftState)</span><br><span class="line">	<span class="comment">// 3. write to DB</span></span><br><span class="line">	ps.Engines.WriteRaft(wb)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="PeerMsgHandler"><a href="#PeerMsgHandler" class="headerlink" title="PeerMsgHandler"></a>PeerMsgHandler</h2><p>根据之前“Request执行流程和调用链分析”的描述，在<code>PeerMsgHandler</code>​中我们要实现<code>proposeRaftCommand</code>​和<code>HandleRaftReady</code>​两个函数。</p>
<h3 id="ProposeRaftCommand"><a href="#ProposeRaftCommand" class="headerlink" title="ProposeRaftCommand"></a>ProposeRaftCommand</h3><p>​<code>proposeRaftCommand</code>​是将上层的<code>RaftCmdRequest</code>​打包传递给Raft节点。</p>
<p>根据文档提示，要对以下两个错误进行处理：</p>
<ul>
<li>ErrNotLeader：在追随者上Propose raftCmd。因此，使用它来让客户端尝试其他peer。</li>
<li>ErrStaleCommand：可能是由于领导者更改，某些日志未提交并被新的领导者日志覆盖。但客户并不知道这一点，仍在等待响应。因此，您应该返回此命令以让客户端知道并重试该命令。</li>
</ul>
<p>很显然这里我们只要处理<code>ErrNotLeader</code>​这一错误，通过CallBack函数来返回错误响应。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !d.IsLeader() &#123;</span><br><span class="line">	leader := d.getPeerFromCache(d.LeaderId())</span><br><span class="line">	cb.Done(ErrResp(&amp;util.ErrNotLeader&#123;RegionId: d.regionId, Leader: leader&#125;))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过以上部分其实已经在<code>d.preProposeRaftCommand(msg)</code>​事先做好了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> proposeRaftCommand(msg *raft_cmdpb.RaftCmdRequest, cb *message.Callback) &#123;</span><br><span class="line">	err := d.preProposeRaftCommand(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cb.Done(ErrResp(err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Your Code Here (2B).</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们要在<code>peer</code>​当中保存callback，于是查看<code>peer</code>​结构体找到了关键的结构<code>proposals</code>​，注释也说得非常直白。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Record the callback of the proposals</span></span><br><span class="line"><span class="comment">// (Used in 2B)</span></span><br><span class="line">proposals []*proposal</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> proposal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// index + term for unique identification</span></span><br><span class="line">	index <span class="type">uint64</span></span><br><span class="line">	term  <span class="type">uint64</span></span><br><span class="line">	cb    *message.Callback</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关的函数在peer_msg_handler.go里面也为我们封装好了，直接调用即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">proposal := &amp;proposal&#123;</span><br><span class="line">	index: d.nextProposalIndex(),</span><br><span class="line">	term:  d.Term(),</span><br><span class="line">	cb:    cb,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着Propose的逻辑，之前在2A部分提到过，上层的条目都是通过<code>RawNode.Propose()</code>​传递给Raft模块，因此这里是<code>d.RaftGroup.Propose</code>​，但是参数应该是<code>[]byte</code>​，所以这里需要对<code>msg</code>​做一些处理，在<code>RaftCmdRequest</code>​类下查找辅助函数，可以找到<code>Marshal</code>​正是我们需要的。完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">proposal := &amp;proposal&#123;</span><br><span class="line">	index: d.nextProposalIndex(),</span><br><span class="line">	term:  d.Term(),</span><br><span class="line">	cb:    cb,</span><br><span class="line">&#125;</span><br><span class="line">data, marErr := msg.Marshal()</span><br><span class="line"><span class="keyword">if</span> marErr != <span class="literal">nil</span> &#123;</span><br><span class="line">	cb.Done(ErrResp(marErr))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">perr := d.RaftGroup.Propose(data)</span><br><span class="line"><span class="keyword">if</span> perr != <span class="literal">nil</span> &#123;</span><br><span class="line">	cb.Done(ErrResp(perr))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// log.DPrintf(&quot;kv/raftstore/peer_msg_handler.go: proposal: %v&quot;, proposal)</span></span><br><span class="line">d.proposals = <span class="built_in">append</span>(d.proposals, proposal)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>d.proposals = append(d.proposals, proposal)</code>​最后再调用，有可能前面的一些环节出错，例如<code>Propose</code>​到了非Leader节点，这时应该直接通过回调返回错误的响应。</p>
</blockquote>
<h2 id="HandleRaftReady"><a href="#HandleRaftReady" class="headerlink" title="HandleRaftReady"></a>HandleRaftReady</h2><p>​<code>HandleRaftReady</code>​是获取Raft节点是否有Ready（即状态更新），然后把这些更新进行持久化和实际应用的函数。是整个project2B的重点。</p>
<p>文档中对于它的执行逻辑描述比较详细，还贴心地给出了处理流程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-s.Ticker:</span><br><span class="line">    Node.Tick()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> Node.HasReady() &#123;</span><br><span class="line">      rd := Node.Ready()</span><br><span class="line">      saveToStorage(rd.State, rd.Entries, rd.Snapshot)</span><br><span class="line">      send(rd.Messages)</span><br><span class="line">      <span class="keyword">for</span> _, entry := <span class="keyword">range</span> rd.CommittedEntries &#123;</span><br><span class="line">        process(entry)</span><br><span class="line">      &#125;</span><br><span class="line">      s.Node.Advance(rd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<code>saveToStorage</code>​实际上就是调用之前实现的<code>peerStorage</code>​的<code>SaveReadyState</code>​函数，作用就是做持久化。</p>
<p>​<code>send</code>​是把Raft节点要转发给其他节点的消息转发出去。</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>我们重点要实现的就是<code>process</code>​，即entry应用的逻辑。这里要理解一下“应用”的含义，就是把entry中的操作拿给<code>kvDB</code>​去实际执行（例如<code>put、delete</code>​某个数据），与之前持久化日志条目（写入<code>raftDB</code>​）本质上是一样的，都是给<code>badger.DB</code>​做持久化。但是“应用”还需要一个额外的操作，还记得之前存入<code>peer.proposals</code>​的callback函数么，之前遇到错误时直接调用<code>cb.Done</code>​返回了错误响应，这里成功“应用”之后，同样需要调用它返回成功的响应。</p>
<p>这也带来了一个新的问题，如果在<code>proposals</code>​中的<code>RaftCmd</code>​没有被raft节点提交并且被覆盖了呢？显然永远不会执行这个<code>RaftCmd</code>​了，还记得在一开始提到的错误处理么？这就是第二个需要检查的错误情况<code>ErrStaleCommand</code>​，给出错误的响应。</p>
<ul>
<li>ErrStaleCommand：可能是由于领导者更改，某些日志未提交并被新的领导者日志覆盖。但客户并不知道这一点，仍在等待响应。因此，您应该返回此命令以让客户端知道并重试该命令。</li>
</ul>
<p>新的问题又来了，怎么去识别这一问题的发生呢？</p>
<p>仔细思考“日志未提交并被新的领导者日志覆盖”这一情况，同一个Index下的Term肯定发生了变化。因此只要对相同Index下的entry和proposals的Term进行检查就可以发现错误。</p>
<p>下面给出我的做法，对于每个应用完成的条目，调用<code>clearStaleAndGetTargetProposal</code>​，会首先根据Index清理已经过时的一些proposals，接着利用目标entry的index和term进行匹配，如果成功返回true，此时<code>d.proposals[0]</code>​就是目标proposal；否则返回false，没有找到对应的proposal，应用之后不做响应（这种情况通常是follower节点，因为follower节点中不会保存callback，它应用的条目是leader发送的而不是客户端发送的，不用负责返回响应）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if return true, d.proposals[0] is the target proposal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> clearStaleAndGetTargetProposal(entry *eraftpb.Entry) <span class="type">bool</span> &#123;</span><br><span class="line">	d.clearStaleProposals(entry)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(d.proposals) &gt; <span class="number">0</span> &amp;&amp; d.proposals[<span class="number">0</span>].index == entry.Index &#123;</span><br><span class="line">		p := d.proposals[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> p.term != entry.Term &#123;</span><br><span class="line">			NotifyStaleReq(entry.Term, p.cb)</span><br><span class="line">			d.proposals = d.proposals[<span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> clearStaleProposals(entry *eraftpb.Entry) &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(d.proposals) &amp;&amp; d.proposals[i].index &lt; entry.Index; i++ &#123;</span><br><span class="line">		d.proposals[i].cb.Done(ErrResp(&amp;util.ErrStaleCommand&#123;&#125;))</span><br><span class="line">	&#125;</span><br><span class="line">	d.proposals = d.proposals[i:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2B目前只需要我们实现普通<code>Request</code>​处理（<code>Put、Delete、Get、Snap</code>​），而不需要对<code>AdminRequest</code>​进行处理（<code>AdminRequest</code>​主要为对Raft集群的一些操作，例如集群成员变更等等）</p>
<p>值得注意的是，对于普通<code>Request</code>​，一个entry可能包含多个操作，因此响应需要包含多个操作的响应；而对于<code>AdminReuqest</code>​，一个entry只能包含一个操作。具体可以看proto&#x2F;pkg&#x2F;raft_cmdpb&#x2F;raft_cmdpb.pb.go中的<code>RaftCmdResponse</code>​类，可以看到<code>Responses</code>​是一个指针切片，而<code>AdminResponse</code>​则是一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftCmdResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	Header               *RaftResponseHeader <span class="string">`protobuf:&quot;bytes,1,opt,name=header&quot; json:&quot;header,omitempty&quot;`</span></span><br><span class="line">	Responses            []*Response         <span class="string">`protobuf:&quot;bytes,2,rep,name=responses&quot; json:&quot;responses,omitempty&quot;`</span></span><br><span class="line">	AdminResponse        *AdminResponse      <span class="string">`protobuf:&quot;bytes,3,opt,name=admin_response,json=adminResponse&quot; json:&quot;admin_response,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;            <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>              <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>               <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便进一步理解process普通<code>Reuqest</code>​的流程，给出关键部分的伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *proposal</span><br><span class="line">resp := &amp;raft_cmdpb.RaftCmdResponse&#123;</span><br><span class="line">	Header:    &amp;raft_cmdpb.RaftResponseHeader&#123;&#125;,</span><br><span class="line">	Responses: []*raft_cmdpb.Response&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, req := <span class="keyword">range</span> cmd.Requests &#123;</span><br><span class="line">	<span class="keyword">switch</span> req.CmdType &#123;</span><br><span class="line">	<span class="keyword">case</span> raft_cmdpb.CmdType_Put:</span><br><span class="line">		wb.SetCF(req.Put.Cf, req.Put.Key, req.Put.Value)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> raft_cmdpb.CmdType_Delete:</span><br><span class="line">		wb.DeleteCF(req.Delete.Cf, req.Delete.Key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> raft_cmdpb.CmdType_Get:</span><br><span class="line">	<span class="keyword">case</span> raft_cmdpb.CmdType_Snap:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> d.clearStaleAndGetTargetProposal(entry) &#123;</span><br><span class="line">		p = d.proposals[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">switch</span> req.CmdType &#123;</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Put:</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;CmdType: raft_cmdpb.CmdType_Put, Put: &amp;raft_cmdpb.PutResponse&#123;&#125;&#125;)</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Delete:</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;CmdType: raft_cmdpb.CmdType_Delete, Delete: &amp;raft_cmdpb.DeleteResponse&#123;&#125;&#125;)</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Get:</span><br><span class="line">			val, err := engine_util.GetCF(d.peerStorage.Engines.Kv, req.Get.Cf, req.Get.Key)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;CmdType: raft_cmdpb.CmdType_Get, Get: &amp;raft_cmdpb.GetResponse&#123;Value: val&#125;&#125;)</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Snap:</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;CmdType: raft_cmdpb.CmdType_Snap, Snap: &amp;raft_cmdpb.SnapResponse&#123;Region: d.Region()&#125;&#125;)</span><br><span class="line">			p.cb.Txn = d.peerStorage.Engines.Kv.NewTransaction(<span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;CmdType: raft_cmdpb.CmdType_Invalid&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">	p.cb.Done(resp)</span><br><span class="line">	d.proposals = d.proposals[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project2c思路</title>
    <url>/2024/05/10/tinykv_project2c_solution/</url>
    <content><![CDATA[<span id="more"></span>

<p>project2c目的是实现RaftLog GC和Snapshot支持。在Raft和raftstore中均需要修改和新增代码。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>raft 一致性算法并没有考虑log无限增长的情况，若不做任何处理，随着系统的长时间运行，Raft节点中的RaftLog会占用大量内存；所以要引进applied index，把applied之前的条目定期压缩（compact）起来然后落盘，最后在内存删除它们，只需要记录最后applied的<code>Index、Term</code>​，以及一些状态。这就是RaftLog GC。</p>
<p>基于RaftLog GC，我们需要实现Snapshot支持来保障Raft算法的正常运行。这主要是在日志复制的过程中，leader需要给follower发送<code>[next, LastIndex]</code>​的条目以及<code>next-1</code>​的index和Term，很可能<code>next-1</code>​（最小索引）的条目已经被compact掉了，此时没法完成日志复制所需的匹配动作，因此leader需要发送一个Snapshot来帮助follower赶上进度。事实上，Project3中实现增加节点（<code>Add Peer</code>​）时，也是通过Snapshot来初始化新节点。</p>
<h3 id="Snapshot的生成"><a href="#Snapshot的生成" class="headerlink" title="Snapshot的生成"></a>Snapshot的生成</h3><p>tinykv已经提供了Raft节点获取Snapshot的接口<code>r.RaftLog.storage.Snapshot()</code>​。可以发现是一个异步的实现，将一个任务丢给了<code>ps.regionSched</code>​，这是消费者端。</p>
<p>之所以采用异步实现，是因为SnapShot通常比较大，所以一般Leader第一次调用<code>r.RaftLog.storage.Snapshot()</code>​可能拿不到结果，不过worker已经开始生成了，等后面再调用时就能够直接返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// schedule snapshot generate task</span></span><br><span class="line">ps.regionSched &lt;- &amp;runner.RegionTaskGen&#123;</span><br><span class="line">	RegionId: ps.region.GetId(),</span><br><span class="line">	Notifier: ch,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者端是在kv&#x2F;raftstore&#x2F;runner&#x2F;region_task.go（根据<code>RegionTaskGen</code>​就可以找到）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *regionTaskHandler)</span></span> Handle(t worker.Task) &#123;</span><br><span class="line">	<span class="keyword">switch</span> t.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *RegionTaskGen:</span><br><span class="line">		task := t.(*RegionTaskGen)</span><br><span class="line">		<span class="comment">// It is safe for now to handle generating and applying snapshot concurrently,</span></span><br><span class="line">		<span class="comment">// but it may not when merge is implemented.</span></span><br><span class="line">		r.ctx.handleGen(task.RegionId, task.Notifier)</span><br><span class="line">	<span class="keyword">case</span> *RegionTaskApply:</span><br><span class="line">		task := t.(*RegionTaskApply)</span><br><span class="line">		r.ctx.handleApply(task.RegionId, task.Notifier, task.StartKey, task.EndKey, task.SnapMeta)</span><br><span class="line">	<span class="keyword">case</span> *RegionTaskDestroy:</span><br><span class="line">		task := t.(*RegionTaskDestroy)</span><br><span class="line">		r.ctx.cleanUpRange(task.RegionId, task.StartKey, task.EndKey)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后会走到<code>doSnapshot</code>​当中，关键的部分如下。这样就生成了一个SnapShot</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">snapshot := &amp;eraftpb.Snapshot&#123;</span><br><span class="line">	Metadata: &amp;eraftpb.SnapshotMetadata&#123;</span><br><span class="line">		Index:     key.Index,</span><br><span class="line">		Term:      key.Term,</span><br><span class="line">		ConfState: &amp;confState,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>raft leader 发现某个节点落后较多（该节点的Next-1位置的entry已经被leader compact了），则给他发送一个Snapshot</p>
<h3 id="Snapshot的Apply"><a href="#Snapshot的Apply" class="headerlink" title="Snapshot的Apply"></a>Snapshot的Apply</h3><p>SnapShot的Apply也应该采用如上的方法，以异步的方式，创意一个<code>RegionTaskApply</code>​结构体丢给<code>ps.regionSched</code>​。</p>
<p>‍</p>
<h2 id="在Raft中实现"><a href="#在Raft中实现" class="headerlink" title="在Raft中实现"></a>在Raft中实现</h2><p>对于Snapshot，在raft模块我们主要需要实现“leader获取并发送SnapShot”，“Follower处理Snapshot消息”，“log”，“ready”四块功能。</p>
<p>​<code>pb.Snapshot</code>​类定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data                 []<span class="type">byte</span>            <span class="string">`protobuf:&quot;bytes,1,opt,name=data,proto3&quot; json:&quot;data,omitempty&quot;`</span></span><br><span class="line">	Metadata             *SnapshotMetadata <span class="string">`protobuf:&quot;bytes,2,opt,name=metadata&quot; json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;          <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>            <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>             <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SnapshotMetadata <span class="keyword">struct</span> &#123;</span><br><span class="line">	ConfState            *ConfState <span class="string">`protobuf:&quot;bytes,1,opt,name=conf_state,json=confState&quot; json:&quot;conf_state,omitempty&quot;`</span></span><br><span class="line">	Index                <span class="type">uint64</span>     <span class="string">`protobuf:&quot;varint,2,opt,name=index,proto3&quot; json:&quot;index,omitempty&quot;`</span></span><br><span class="line">	Term                 <span class="type">uint64</span>     <span class="string">`protobuf:&quot;varint,3,opt,name=term,proto3&quot; json:&quot;term,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;   <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>     <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>      <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfState <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// all node id</span></span><br><span class="line">	Nodes                []<span class="type">uint64</span> <span class="string">`protobuf:&quot;varint,1,rep,packed,name=nodes&quot; json:&quot;nodes,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>   <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​​其中<code>Metadata</code>​是我们需要注意的关键数据。</p>
<h3 id="leader获取并发送SnapShot"><a href="#leader获取并发送SnapShot" class="headerlink" title="leader获取并发送SnapShot"></a>leader获取并发送SnapShot</h3><p>在“问题分析”中提到raft leader 发现某个节点落后较多（该节点的Next-1位置的entry已经被leader compact了），则给他发送一个Snapshot。</p>
<p>Compact实际做的事情就是日志截断。这里“被leader compact”的含义是由于截断leader中已经找不到Next-1（即论文中的<code>preLogIndex</code>​）位置的entry了，所以没办法通过单纯的<code>sendAppend</code>​进行日志同步（没办法获取<code>preLogTerm</code>​）。</p>
<p><strong>所以需要做的修改是要在</strong>​<code>**sendAppend**</code>​<strong>加入检查并发送Snapshot的逻辑。</strong></p>
<p>那么首先的一个问题就是如何检查<code>next-1</code>​位置的entry已经被compact了？</p>
<p>已知<code>preLogIndex=next-1</code>​，通过<code>r.RaftLog.Term(preLogIndex)</code>​来获取<code>preLogTerm</code>​。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *RaftLog)</span></span> Term(i <span class="type">uint64</span>) (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2A).</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l.entries) &gt; <span class="number">0</span> &amp;&amp; i &gt;= l.dummyIndex &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; l.LastIndex() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, ErrUnavailable</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> l.entries[i-l.dummyIndex].Term, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		term, err := l.storage.Term(i)</span><br><span class="line">		<span class="keyword">return</span> term, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果发生compact，那么显然上述调用会走到else分支，再来看一下<code>l.storage.Term</code>​的实现kv&#x2F;raftstore&#x2F;peer_storage.go。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> Term(idx <span class="type">uint64</span>) (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> idx == ps.truncatedIndex() &#123;</span><br><span class="line">		<span class="keyword">return</span> ps.truncatedTerm(), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := ps.checkRange(idx, idx+<span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ps.truncatedTerm() == ps.raftState.LastTerm || idx == ps.raftState.LastIndex &#123;</span><br><span class="line">		<span class="keyword">return</span> ps.raftState.LastTerm, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> entry eraftpb.Entry</span><br><span class="line">	<span class="keyword">if</span> err := engine_util.GetMeta(ps.Engines.Raft, meta.RaftLogKey(ps.region.Id, idx), &amp;entry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> entry.Term, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> checkRange(low, high <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> low &gt; high &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;low %d is greater than high %d&quot;</span>, low, high)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> low &lt;= ps.truncatedIndex() &#123;</span><br><span class="line">		<span class="keyword">return</span> raft.ErrCompacted</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> high &gt; ps.raftState.LastIndex+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;entries&#x27; high %d is out of bound, lastIndex %d&quot;</span>,</span><br><span class="line">			high, ps.raftState.LastIndex)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读上面的代码，在<code>checkRange</code>​函数中找到了一个错误<code>ErrCompacted</code>​，它的条件是<code>low &lt;= ps.truncatedIndex()</code>​，即小于被截断的最高Index，符合我们上面描述的Compact的操作。因此可以确定只要对这个错误进行检查即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">preLogTerm, err := r.RaftLog.Term(preLogIndex)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == ErrCompacted &#123;</span><br><span class="line">		r.sendSnapshot(to)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来考虑实现<code>sendSnapshot</code>​这一函数。</p>
<p>首先是Snapshot的获取，根据在“Snapshot生成”中的描述，通过<code>r.RaftLog.storage.Snapshot()</code>​可以异步生成一个SnapShot，由于SnapShot通常比较大，因此第一次调用可能会返回错误，即SnapShot还没有准备好，因此要对这种情况做判断，对应的错误是<code>ErrSnapshotTemporailyUnavailable</code>​。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> sendSnapshot(to <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2C).</span></span><br><span class="line">	snap, err := r.RaftLog.storage.Snapshot()</span><br><span class="line">	<span class="comment">// because snapshot is handled asynchronously, so we should check if snapshot is valid</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == ErrSnapshotTemporarilyUnavailable &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.msgs = <span class="built_in">append</span>(r.msgs, pb.Message&#123;</span><br><span class="line">		MsgType:  pb.MessageType_MsgSnapshot,</span><br><span class="line">		From:     r.id,</span><br><span class="line">		To:       to,</span><br><span class="line">		Term:     r.Term,</span><br><span class="line">		Snapshot: &amp;snap,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// avoid snapshot is sent too frequently</span></span><br><span class="line">	r.Prs[to].Next = snap.Metadata.Index + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在发送Snapshot成功之后，可以直接在leader更新目标节点的Next，避免需要频繁发送snapshot造成较高的带宽占用。</p>
</blockquote>
<p>‍</p>
<h2 id="在raftstore中实现"><a href="#在raftstore中实现" class="headerlink" title="在raftstore中实现"></a>在raftstore中实现</h2><h3 id="processAdminRequest"><a href="#processAdminRequest" class="headerlink" title="processAdminRequest"></a>processAdminRequest</h3><p>根据文档和之前的分析，需要在<code>process</code>​的逻辑中增加对<code>AdminCmdType_CompactLog</code>​这一消息的处理，不同于普通的<code>Request</code>​，它的类型是<code>AdminRequest</code>​，要分开处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> processAdminRequest(entry *eraftpb.Entry, cmd *raft_cmdpb.RaftCmdRequest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> process(entry *eraftpb.Entry) &#123;</span><br><span class="line">	cmd := &amp;raft_cmdpb.RaftCmdRequest&#123;&#125;</span><br><span class="line">	cmd.Unmarshal(entry.Data)</span><br><span class="line">	<span class="keyword">if</span> cmd.AdminRequest != <span class="literal">nil</span> &#123;</span><br><span class="line">		d.processAdminRequest(entry, cmd)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对该消息的处理流程，文档中说明的比较详细，即先更新<code>applyState.TruncatedState</code>​的状态，然后通过接口<code>d.ScheduleCompactLog</code>​为 raftlog-gc worker 安排一个任务。Raftlog-gc worker 会异步完成实际的日志删除工作。</p>
<p>‍</p>
<h3 id="ApplySnapshot"><a href="#ApplySnapshot" class="headerlink" title="ApplySnapshot"></a>ApplySnapshot</h3><p>​<code>appluSnapshot</code>​即<code>peer_storage</code>​对于<code>Ready()</code>​获得的<code>snapshot</code>​进行实际应用，要做的事情基本上能根据前面的分析推出来：删除过时的数据（所有的数据）、更新各种状态、发送任务给region_worker进行实际应用。</p>
<p>删除过时数据，根据注释可知是<code>ClearMeta</code>​和<code>ps.clearExtraData</code>​，所需要的参数也十分简单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ps.clearMeta(kvWB, raftWB)</span><br><span class="line">ps.clearExtraData(snapData.Region)</span><br></pre></td></tr></table></figure>

<p>更新peer_storage的内存状态，<code>RaftLocalState</code>​ 、<code>RaftApplyState</code>​和 <code>RegionLocalState</code>​。</p>
<p>简要分析一下需要更新哪些状态，首先<code>snapshot.MetaData</code>​只有<code>Index、Term、ConfState</code>​三个字段。对于<code>RaftLocalState</code>​，很显然只要更新<code>LastIndex</code>​、<code>LastTerm</code>​（<code>HardState</code>​的更新在<code>ApplySnapshot</code>​的上层<code>SaveReadyState</code>​当中）。对于<code>RaftApplyState</code>​，<code>AppliedIndex</code>​肯定要更新到<code>meta.Index</code>​，<code>TruncatedState</code>​代表截断状态，同样有<code>Index、Term</code>​两个字段，很显然也要更新。文档中还指明“您还需要更新<code>PeerStorage.snapState</code>​到<code>snap.SnapState_Applying</code>​”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftApplyState <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Record the applied index of the state machine to make sure</span></span><br><span class="line">	<span class="comment">// not apply any index twice after restart.</span></span><br><span class="line">	AppliedIndex <span class="type">uint64</span> <span class="string">`protobuf:&quot;varint,1,opt,name=applied_index,json=appliedIndex,proto3&quot; json:&quot;applied_index,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Record the index and term of the last raft log that have been truncated. (Used in 2C)</span></span><br><span class="line">	TruncatedState       *RaftTruncatedState <span class="string">`protobuf:&quot;bytes,2,opt,name=truncated_state,json=truncatedState&quot; json:&quot;truncated_state,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;            <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>              <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>               <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是文档中提到的<code>RegionLocalState</code>​怎么更新？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PeerStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// current region information of the peer</span></span><br><span class="line">	region *metapb.Region</span><br><span class="line">	<span class="comment">// current raft state of the peer</span></span><br><span class="line">	raftState *rspb.RaftLocalState</span><br><span class="line">	<span class="comment">// current apply state of the peer</span></span><br><span class="line">	applyState *rspb.RaftApplyState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// current snapshot state</span></span><br><span class="line">	snapState snap.SnapState</span><br><span class="line">	<span class="comment">// regionSched used to schedule task to region worker</span></span><br><span class="line">	regionSched <span class="keyword">chan</span>&lt;- worker.Task</span><br><span class="line">	<span class="comment">// generate snapshot tried count</span></span><br><span class="line">	snapTriedCnt <span class="type">int</span></span><br><span class="line">	<span class="comment">// Engine include two badger instance: Raft and Kv</span></span><br><span class="line">	Engines *engine_util.Engines</span><br><span class="line">	<span class="comment">// Tag used for logging</span></span><br><span class="line">	Tag <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>PeerStorage</code>​定义，推断<code>metapb.Region</code>​即<code>RegionLocalState</code>​。在<code>Snapshot.MetaData</code>​中似乎没有找到与之相关的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">uint64</span> <span class="string">`protobuf:&quot;varint,1,opt,name=id,proto3&quot; json:&quot;id,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Region key range [start_key, end_key).</span></span><br><span class="line">	StartKey             []<span class="type">byte</span>       <span class="string">`protobuf:&quot;bytes,2,opt,name=start_key,json=startKey,proto3&quot; json:&quot;start_key,omitempty&quot;`</span></span><br><span class="line">	EndKey               []<span class="type">byte</span>       <span class="string">`protobuf:&quot;bytes,3,opt,name=end_key,json=endKey,proto3&quot; json:&quot;end_key,omitempty&quot;`</span></span><br><span class="line">	RegionEpoch          *RegionEpoch <span class="string">`protobuf:&quot;bytes,4,opt,name=region_epoch,json=regionEpoch&quot; json:&quot;region_epoch,omitempty&quot;`</span></span><br><span class="line">	Peers                []*Peer      <span class="string">`protobuf:&quot;bytes,5,rep,name=peers&quot; json:&quot;peers,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;     <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>       <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>        <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在已经写好的代码当中，有一个<code>RaftSnapshotData</code>​类型的<code>snapData</code>​是将<code>Snapshot</code>​中的<code>Data</code>​解析后的数据，可以看到其中的<code>region</code>​数据，正是想要的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftSnapshotData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Region               *metapb.Region <span class="string">`protobuf:&quot;bytes,1,opt,name=region&quot; json:&quot;region,omitempty&quot;`</span></span><br><span class="line">	FileSize             <span class="type">uint64</span>         <span class="string">`protobuf:&quot;varint,2,opt,name=file_size,json=fileSize,proto3&quot; json:&quot;file_size,omitempty&quot;`</span></span><br><span class="line">	Data                 []*KeyValue    <span class="string">`protobuf:&quot;bytes,3,rep,name=data&quot; json:&quot;data,omitempty&quot;`</span></span><br><span class="line">	Meta                 *SnapshotMeta  <span class="string">`protobuf:&quot;bytes,5,opt,name=meta&quot; json:&quot;meta,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125;       <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="type">byte</span>         <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="type">int32</span>          <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the peer with given snapshot</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> ApplySnapshot(snapshot *eraftpb.Snapshot, kvWB *engine_util.WriteBatch, raftWB *engine_util.WriteBatch) (*ApplySnapResult, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;%v begin to apply snapshot&quot;</span>, ps.Tag)</span><br><span class="line">	snapData := <span class="built_in">new</span>(rspb.RaftSnapshotData)</span><br><span class="line">	<span class="keyword">if</span> err := snapData.Unmarshal(snapshot.Data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hint: things need to do here including: update peer storage state like raftState and applyState, etc,</span></span><br><span class="line">	<span class="comment">// and send RegionTaskApply task to region worker through ps.regionSched, also remember call ps.clearMeta</span></span><br><span class="line">	<span class="comment">// and ps.clearExtraData to delete stale data</span></span><br><span class="line">	<span class="comment">// Your Code Here (2C).</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是想用<code>kvWB.SetMeta(meta.RegionStateKey(snapData.Region.Id), snapData.Region)</code>​来持久化时却发现<code>snapData.Region</code>​参数不匹配，<code>*rspb.RegionLocalState</code>​。</p>
<p>后面在kv&#x2F;raftstore&#x2F;meta&#x2F;values.go找到了<code>WriteRegionState</code>​函数，正是我们想要的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRegionState</span><span class="params">(kvWB *engine_util.WriteBatch, region *metapb.Region, state rspb.PeerState)</span></span> &#123;</span><br><span class="line">	regionState := <span class="built_in">new</span>(rspb.RegionLocalState)</span><br><span class="line">	regionState.State = state</span><br><span class="line">	regionState.Region = region</span><br><span class="line">	kvWB.SetMeta(RegionStateKey(region.Id), regionState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个新的问题来了，之前不论是<code>RaftLocalState</code>​ 、<code>RaftApplyState</code>​还是<code>SnapState</code>​都是先在<code>PeerStorage</code>​内存中更新，再持久化，我们显然不能先对<code>RegionState</code>​持久化。</p>
<p>那么如何在内存中更新<code>RegionState</code>​？</p>
<p>在之前的分析当中以及文档当中都提到，需要“<strong>通过</strong>​<code>**PeerStorage.regionSched**</code>​<strong>发送</strong>​<code>**runner.RegionTaskApply**</code>​<strong>任务给到region_worker</strong>”，这里的<code>RegionTask</code>​是否可以理解为在内存中更新<code>RegionState</code>​呢？通过查看代码调用链<code>runner.RegionTaskApply</code>​-&gt;<code>Handle</code>​-&gt;<code>r.ctx.handleApply</code>​-&gt;<code>applySnap</code>​验证了这一想法。</p>
<p>简单参考<code>func (ps *PeerStorage) Snapshot() (eraftpb.Snapshot, error)</code>​中的代码实现（能够注意到它没有等待snapshot的生成，直接返回了一个<code>ErrSnaoshotTemporarilyUnavailable</code>​，对应我们在raft模块中的处理）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> Snapshot() (eraftpb.Snapshot, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *eraftpb.Snapshot, <span class="number">1</span>)</span><br><span class="line">	ps.snapState = snap.SnapState&#123;</span><br><span class="line">		StateType: snap.SnapState_Generating,</span><br><span class="line">		Receiver:  ch,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// schedule snapshot generate task</span></span><br><span class="line">	ps.regionSched &lt;- &amp;runner.RegionTaskGen&#123;</span><br><span class="line">		RegionId: ps.region.GetId(),</span><br><span class="line">		Notifier: ch,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> snapshot, raft.ErrSnapshotTemporarilyUnavailable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此处不能直接返回，文档中指明了要“<code>wait until region worker finishes</code>​”。猜测是因为如果直接返回，raft节点可能在没有更新regionState的情况下发生错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// send RegionTaskApply task to region worker</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">ps.regionSched &lt;- &amp;runner.RegionTaskApply&#123;</span><br><span class="line">	RegionId: snapData.Region.Id,</span><br><span class="line">	Notifier: ch,</span><br><span class="line">	SnapMeta: snapshot.Metadata,</span><br><span class="line">	StartKey: snapData.Region.GetStartKey(),</span><br><span class="line">	EndKey:   snapData.Region.GetEndKey(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// according to document, need to wait until region worker finishes</span></span><br><span class="line">&lt;-ch</span><br><span class="line"><span class="comment">// regionState update</span></span><br><span class="line">result := &amp;ApplySnapResult&#123;</span><br><span class="line">	PrevRegion: ps.region,</span><br><span class="line">	Region:     snapData.Region,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">meta.WriteRegionState(kvWB, snapData.Region, rspb.PeerState_Normal)</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project3文档翻译</title>
    <url>/2024/05/12/tinykv_project3_doc_translation/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Project-3-MultiRaftKV"><a href="#Project-3-MultiRaftKV" class="headerlink" title="Project 3 MultiRaftKV"></a>Project 3 MultiRaftKV</h2><p>在 Project2 中，你建立了一个基于Raft的高可用的kv服务器，做得很好！但还不够，这样的kv服务器是由单一的 raftGroup 支持的，不能无限扩展，并且每一个写请求都要等到提交后再逐一写入 badger，这是保证一致性的一个关键要求，但也扼杀了任何并发性。</p>
<p>​<img src="/2024/05/12/tinykv_project3_doc_translation/image1.png" alt="image">​</p>
<p>在这个项目中，你将实现一个带有平衡调度器的基于 multi Raft 的kv服务器，它由多个 Raft group 组成，每个 Raft group 负责一个单独的 key 范围，在这里被命名为 region ，布局将看起来像上图。对单个 region 的请求的处理和以前一样，但多个 region 可以同时处理请求，这提高了性能，但也带来了一些新的挑战，如平衡每个 region 的请求，等等。</p>
<p>这个项目有3个部分，包括：</p>
<ul>
<li>对 Raft 算法实现成员变更和领导变更</li>
<li>在 raftstore 上实现Conf change和 region split</li>
<li>引入 scheduler</li>
</ul>
<h3 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h3><p>在这一部分中，你将在基本的 Raft 算法上实现成员变更和领导者变更，这些功能是后面两部分所需要的。成员变更，即 confChange，用于添加或删除 peer 到Raft Group，这可能会改变 RaftGroup 的节点数目，所以要小心。领导权变更，即领导权转移，用于将领导权转移给另一个 peer，这对平衡调度器非常有用。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>你需要修改的代码都是关于 <code>raft/raft.go</code>​ 和 <code>raft/rawnode.go</code>​ 的，也可以参见<code>proto/proto/eraft.proto</code>​以了解你需要处理的新信息。confChange 和 leader transfer 都是由上层程序触发的，所以你可能想从 <code>raft/rawnode.go</code>​ 开始。</p>
<h4 id="实现领导者转移"><a href="#实现领导者转移" class="headerlink" title="实现领导者转移"></a>实现领导者转移</h4><p>为了实现领导者的转移，让我们引入两个新的消息类型，<code>MsgTransferLeader</code>​ 和<code>MsgTimeoutNow</code>​。为了转移领导权，你需要首先在当前领导上调用带有<code>MsgTransferLeader</code>​ 消息的 <code>raft.Raft.Step</code>​，为了确保转移的成功，当前领导应该首先检查被转移者（即转移目标）的资格，比如：被转移者的日志是否为最新的，等等。如果被转移者不合格，当前领导可以选择放弃转移或者帮助被转移者，既然放弃对程序本身没有帮助，就选择帮助被转移者吧。如果被转移者的日志不是最新的，当前的领导者应该向被转移者发送 <code>MsgAppend</code>​ 消息，并停止接受新的 propose，以防我们最终会出现循环。因此，如果被转移者符合条件（或者在现任领导的帮助下），领导应该立即向被转移者发送 <code>MsgTimeoutNow</code>​ 消息，在收到 <code>MsgTimeoutNow</code>​ 消息后，被转移者应该立即开始新的选举，无论其选举超时与否，被转移者都有很大机会让现任领导下台，成为新领导者。</p>
<h4 id="实现成员变更"><a href="#实现成员变更" class="headerlink" title="实现成员变更"></a>实现成员变更</h4><p>这里要实现的 conf change 算法不是扩展Raft论文中提到的联合共识算法，联合共识算法可以一次性增加和&#x2F;或移除任意 peer，相反，这个算法只能一个一个地增加或移除 peer，这更简单，更容易推理。此外，ConfChange从调用领导者的<code>raft.RawNode.ProposeConfChange</code>​开始，它将提出一个日志，其中<code>pb.Entry.EntryType</code>​设置为<code>EntryConfChange</code>​，<code>pb.Entry.Data</code>​设置为输入<code>pb.ConfChange</code>​ 。当 <code>EntryConfChange</code>​ 类型的日志被提交时，你必须通过<code>RawNode.ApplyConfChange</code>​ 与日志中的 <code>pb.ConfChange</code>​ 一起应用它，只有这样你才能根据 <code>pb.ConfChange</code>​ 通过 <code>raft.Raft.addNode</code>​ 和 <code>raft.Raft.removeNode</code>​ 向这个Raft 子节点添加或删除 peer。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>​<code>MsgTransferLeader</code>​消息是本地消息，不是来自网络的。</li>
<li>将<code>MsgTransferLeader</code>​消息的<code>Message.from</code>​设置为被转移者（即转移目标）。</li>
<li>要立即开始新的选举，你可以用<code>MsgHup</code>​消息调用<code>Raft.Step</code>​</li>
<li>调用 <code>pb.ConfChange.Marshal</code>​ 来获取 <code>pb.ConfChange</code>​ 的字节表示，并将其放入 <code>pb.Entry.Data</code>​。</li>
</ul>
</blockquote>
<h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>由于 Raft 模块现在支持成员变更和领导变更，在这一部分中，你需要在 Part A 的基础上使 TinyKV 支持这些<strong>​ admin 命令</strong>。你可以在 <code>proto/proto/raft_cmdpb.proto</code>​ 中看到，有四种 admin 命令：</p>
<ul>
<li>CompactLog (已经在 Project2 的 PartC 实现)</li>
<li>TransferLeader</li>
<li>ChangePeer</li>
<li>Split</li>
</ul>
<p>TransferLeader 和 ChangePeer 是基于 Raft 支持的领导变更和成员变更的命令。这些将被用作平衡调度器的基本操作步骤。Split 将一个 region 分割成两个 region，这是 multi Raft 的基础。你将一步一步地实现它们。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>所有的变化都是基于 Project2 的实现，所以你需要修改的代码都是关于 <code>kv/raftstore/peer_msg_handler.go</code>​ 和 <code>kv/raftstore/peer.go</code>​。</p>
<h4 id="Propose-TransferLeader"><a href="#Propose-TransferLeader" class="headerlink" title="Propose TransferLeader"></a>Propose TransferLeader</h4><p>这一步相当简单。作为一个 Raft 命令，TransferLeader 将被 Propose 为一个Raft 日志项。但是 TransferLeader 实际上是一个动作，不需要复制到其他 peer，所以<strong>你只需要调用 RawNode 的 ​</strong>​<code>TransferLeader()</code>​<strong>​ 方法</strong>，而不是 TransferLeader 命令的<code>Propose()</code>​。</p>
<h4 id="在raftstore中实现confChange"><a href="#在raftstore中实现confChange" class="headerlink" title="在raftstore中实现confChange"></a>在raftstore中实现confChange</h4><p>confChange有两种不同的类型：AddNode 和 RemoveNode。正如它的名字所暗示的，它添加一个 Peer 或从 region 中删除一个 Peer。为了实现 confChange，你应该先学习 RegionEpoch 的概念。RegionEpoch 是 <code>metapb.Region</code>​ 的元信息的一部分。当一个 Region 增加或删除 Peer 或 Split 时，Region的<code>poch</code>​就会发生变化。<strong>RegionEpoch 的 ​</strong>​<code>conf_ver</code>​<strong>​ 在 ConfChange 期间增加，而</strong>​<code>version</code>​<strong>在分裂期间增加。</strong>它将被用来保证一个 Region 中的两个领导者在网络隔离下有最新的region信息。</p>
<p>你需要使 raftstore 支持处理 conf change 命令。这个过程是：</p>
<ul>
<li>通过 <code>ProposeConfChange</code>​ 提出 conf change admin 命令</li>
<li>在日志被提交后，改变 <code>RegionLocalState</code>​，包括 RegionEpoch 和 Region 中的Peers。</li>
<li>调用 <code>raft.RawNode</code>​ 的 <code>ApplyConfChange()</code>​。</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>对于执行AddNode，新添加的 Peer 将由领导者的心跳来创建，查看<code>storeWorker</code>​ 的 <code>maybeCreatePeer()</code>​。在那个时候，这个 Peer 是未初始化的，它的 region 的任何信息对我们来说都是未知的，所以我们用 0 来初始化它的日志任期和索引。这时领导者会知道这个跟随者没有数据（存在一个从0到5的日志间隙），<strong>它将直接发送一个Snapshot给这个跟随者</strong>。</li>
<li>对于执行 RemoveNode，你应该明确地调用 <code>destroyPeer()</code>​ 来停止 Raft 模块。销毁逻辑是为你提供的。</li>
<li><strong>不要忘记更新 ​<code>GlobalContext</code>​ 的 ​</strong>​<code>storeMeta</code>​<strong>​ 中的 ​</strong>​<code>regionState</code>​<strong>。</strong></li>
<li>测试代码会多次安排一个 conf change 的命令，直到该 conf change 被应用，所以<strong>你需要考虑如何忽略同一 conf change 的重复命令</strong>。</li>
</ul>
</blockquote>
<h4 id="在raftstore中实现region-split"><a href="#在raftstore中实现region-split" class="headerlink" title="在raftstore中实现region split"></a>在raftstore中实现region split</h4><p>​<img src="/2024/05/12/tinykv_project3_doc_translation/image2.png" alt="image">​</p>
<p>为了支持 multi-raft，系统进行了数据分片，使每个 raft 组只存储一部分数据。Hash 和 Range 是常用的数据分片方式。TinyKV 使用 Range，主要原因是 Range 可以更好地聚合具有相同前缀的key，这对扫描等操作来说很方便。此外，Range在分片上比 Hash 更有优势。通常情况下，它只涉及元数据的修改，不需要移动数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message Region &#123;</span><br><span class="line"> <span class="type">uint64</span> id = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// Region key range [start_key, end_key).</span></span><br><span class="line"> bytes start_key = <span class="number">2</span>;</span><br><span class="line"> bytes end_key = <span class="number">3</span>;</span><br><span class="line"> RegionEpoch region_epoch = <span class="number">4</span>;</span><br><span class="line"> repeated Peer peers = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们重新审视一下 Region 的定义，它包括两个字段 <code>start_key</code>​ 和 <code>end_key</code>​，以表明 Region 所负责的数据范围。所以 Split 是支持多进程的关键步骤。在开始时，只有一个Region，其范围是<code>[&quot;&quot;, &quot;&quot;)</code>​。你可以把 key 空间看作一个圈，所以<code>[&quot;&quot;, &quot;&quot;)</code>​代表整个空间。随着数据的写入，<code>SplitChecker</code>​ 将在每一个 <code>cfg.SplitRegionCheckTickInterval</code>​ 检查 region 的大小（<code>SplitChecker</code>​<strong>如何获取region大小？</strong>），并在可能的情况下生成一个<code>split_key</code>​，将该 region 切割成两部分，你可以在 <code>kv/raftstore/runner/split_check.go</code>​ 中查看其逻辑。​<code>split_key</code>​将被包装成一个 <code>MsgSplitRegion</code>​，由 <code>onPrepareSplitRegion()</code>​ 处理。</p>
<p>为了确保新创建的 Region 和 Peers 的 id 是唯一的，这些 id 是由调度器分配的。<code>onPrepareSplitRegion()</code>​ 实际上为 <code>pd Worker</code>​ 安排了一个任务，向调度器索取id。并在收到调度器的响应后做出一个 Split admin命令，见<code>kv/raftstore/runner/scheduler_task.go</code>​ 中的 <code>onAskSplit()</code>​。</p>
<p>所以你的任务是实现处理 Split admin 命令的过程，就像 conf change 那样。提供的框架支持 multi-raft，见 <code>kv/raftstore/router.go</code>​。<strong>当一个 Region 分裂成两个 Region 时，其中一个 Region 将继承分裂前的元数据，只是修改其 Range 和 RegionEpoch，而另一个将创建相关的元信息。</strong></p>
<blockquote>
<p>提示:</p>
<ul>
<li>这个新创建的 Region 的对应 Peer 应该由 <code>createPeer()</code>​ 创建，并注册到 <code>router.regions</code>​。而 region 的信息应该插入 <code>ctx.StoreMeta</code>​ 中的<code>regionRanges</code>​ 中。</li>
<li>对于有网络隔离的 region split 情况，要应用的快照可能会与现有 region 的范围有重叠。检查逻辑在 <code>kv/raftstore/peer_msg_handler.go</code>​ 的<code>checkSnapshot()</code>​ 中。请在实现时牢记这一点，并照顾到这种情况。</li>
<li>使用 <code>engine_util.ExceedEndKey()</code>​ 与 region 的 end key 进行比较。因为当end key 等于” “时，任何 key 都将等于或大于” “。<strong>有更多的错误需要考虑。ErrRegionNotFound, ErrKeyNotInRegion, ErrEpochNotMatch。</strong></li>
</ul>
</blockquote>
<h3 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h3><p>正如上面所介绍的，我们的kv存储中的所有数据被分割成几个 region，每个region 都包含多个副本。一个问题出现了：我们应该把每个副本放在哪里？我们怎样才能找到副本的最佳位置？谁来发送以前的 AddPeer 和 RemovePeer 命令？Scheduler承担了这个责任。</p>
<p>为了做出明智的决定，Scheduler 应该拥有关于整个集群的一些信息。它应该知道每个 region 在哪里。它应该知道它们有多少个 key。它应该知道它们有多大…为了获得相关信息，Scheduler 要求每个 region 定期向 Scheduler 发送一个心跳请求。你可以在 <code>/proto/proto/schedulerpb.proto</code>​ 中找到心跳请求结构 <code>RegionHeartbeatRequest</code>​。在收到心跳后，调度器将更新本地 region 信息。</p>
<p>同时，调度器会定期检查 region 信息，以发现我们的 TinyKV 集群中是否存在不平衡现象。例如，如果任何 store 包含了太多的 region，region 应该从它那里转移到其他 store 。这些命令将作为相应 region 的心跳请求的响应被接收。</p>
<p>在这一部分，你将需要为 Scheduler 实现上述两个功能。按照我们的指南和框架，这不会太难。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>需要修改的代码都是关于 <code>scheduler/server/cluster.go</code>​ 和 <code>scheduler/server/schedulers/balance_region.go</code>​ 的。如上所述，当调度器收到一个 region 心跳时，它将首先更新其本地 region 信息。然后，它将检查是否有这个 region 的未决命令。如果有，它将作为响应被发送回来。</p>
<p>你只需要实现 <code>processRegionHeartbeat</code>​ 函数，其中 Scheduler 更新本地信息；以及 balance_region 的 Scheduler 函数，其中 Scheduler 扫描 Store 并确定是否存在不平衡以及它应该移动哪个 region。</p>
<h4 id="收集区域心跳"><a href="#收集区域心跳" class="headerlink" title="收集区域心跳"></a>收集区域心跳</h4><p>正如你所看到的，<code>processRegionHeartbeat</code>​ 函数的唯一参数是一个 <code>regionInfo</code>​。它包含了关于这个心跳的发送者 region 的信息。Scheduler 需要做的仅仅是更新本地region 记录。但是，它应该为每次心跳更新这些记录吗？</p>
<p>肯定不是！有两个原因。有两个原因。一个是当这个 region 没有变化时，更新可能被跳过。更重要的一个原因是，Scheduler 不能相信每一次心跳。特别是说，如果集群在某个部分有分区，一些节点的信息可能是错误的。</p>
<p>例如，一些 Region 在被分割后会重新启动选举和分割，但另一批孤立的节点仍然通过心跳向 Scheduler 发送过时的信息。所以对于一个 Region 来说，两个节点中的任何一个都可能说自己是领导者，这意味着 Scheduler 不能同时信任它们。</p>
<p>哪一个更可信呢？<strong>Scheduler 应该使用 ​<code>conf_ver</code>​ 和 <code>version</code>​ 来确定，即 <code>RegionEpoch</code>​​</strong>​。Scheduler 应该首先比较两个节点的 Region <code>version</code>​ 的值。如果数值相同，Scheduler 会比较 <code>conf_ver</code>​ 的数值。拥有较大 <code>conf_ver</code>​ 的节点必须拥有较新的信息。</p>
<p>简单地说，你可以按以下方式组织检查程序：</p>
<ul>
<li>检查本地存储中是否有一个具有相同 Id 的 region。如果有，并且至少有一个心跳的 conf_ver 和版本小于它，那么这个心跳 region 就是过时的。</li>
<li>如果没有，则扫描所有与之重叠的区域。心跳的 <code>conf_ver</code>​ 和 <code>version</code>​ 应该大于或等于所有的，否则这个 region 是陈旧的。</li>
</ul>
<p>那么 Scheduler 如何确定是否可以跳过这次更新？我们可以列出一些简单的条件。</p>
<ul>
<li>如果新的 <code>version</code>​ 或 <code>conf_ver</code>​ 大于原来的版本，就不能被跳过。</li>
<li>如果领导者改变了，它不能被跳过</li>
<li>如果新的或原来的有挂起的 peer，它不能被跳过。</li>
<li>如果 ApproximateSize 发生变化，则不能跳过。</li>
<li>…</li>
</ul>
<p>不要担心。你不需要找到一个严格的充分和必要条件。<strong>冗余的更新不会影响正确性。</strong></p>
<p>如果 Scheduler 决定根据这个心跳来更新本地存储，有两件事它应该更新：region tree 和 store status。你可以使用 <code>RaftCluster.core.PutRegion</code>​ 来更新 region-tree ，并使用 <code>RaftCluster.core.UpdateStoreStatus</code>​ 来更新相关存储的状态（如领导者数量、区域数量、待处理的 peer 数量…）。</p>
<h4 id="实现-region-balance-调度器"><a href="#实现-region-balance-调度器" class="headerlink" title="实现 region balance 调度器"></a>实现 region balance 调度器</h4><p>在调度器中可以有许多不同类型的调度器在运行，例如，balance_region 调度器和balance_leader 调度器。这篇学习材料将集中讨论 balance_region 调度器。</p>
<p>每个调度器都应该实现了 <code>Scheduler</code>​ 接口，你可以在 <code>/scheduler/server/schedule/scheduler.go</code>​ 中找到它。调度器将使用 <code>GetMinInterval</code>​ 的返回值作为默认的时间间隔来定期运行 <code>Schedule</code>​ 方法。如果它的返回值为空（有几次重试），<code>Scheduler</code>​ 将使用 <code>GetNextInterval</code>​ 来增加间隔时间。通过定义 <code>GetNextInterval</code>​，你可以定义时间间隔的增加方式。如果它返回一个操作符，<code>Scheduler</code>​ 将派遣这些操作符作为相关区域的下一次心跳的响应。</p>
<p>​<code>Scheduler</code>​ 接口的核心部分是 <code>Schedule</code>​ 方法。这个方法的返回值是操作符，它包含多个步骤，如 AddPeer 和 RemovePeer。例如，MovePeer 可能包含 AddPeer、transferLeader 和 RemovePeer，你在前面的部分已经实现了。以下图中的第一个RaftGroup为例。调度器试图将 peer 从第三个 store 移到第四个 store。首先，它应该为第四个 store 添加 peer。然后它检查第三家是否是领导者，发现不是，所以不需要转移领导者。然后，它删除第三个 store 的 peer。</p>
<p>你可以使用 <code>scheduler/server/schedule/operator</code>​ 包中的<code>CreateMovePeerOperator</code>​ 函数来创建一个 <code>MovePeer</code>​ 操作。</p>
<p>​<img src="/2024/05/12/tinykv_project3_doc_translation/image3.png" alt="image">​</p>
<p>​<img src="/2024/05/12/tinykv_project3_doc_translation/image4.png" alt="image">​</p>
<p>在这一部分，你需要实现的唯一函数是<code>scheduler/server/schedulers/balance_region.go</code>​ 中的 <code>Schedule</code>​ 方法。这个调度器避免了在一个 store 里有太多的 region。首先，Scheduler 将选择所有合适的 store。然后根据它们的 region 大小进行排序。然后，调度器会尝试从 reigon 大小最大的 store 中找到要移动的 region。</p>
<p>调度器将尝试找到最适合在 store 中移动的 region。首先，它将尝试选择一个挂起的 region，因为挂起可能意味着磁盘过载。如果没有一个挂起的 region，它将尝试找到一个 Follower region。如果它仍然不能挑选出一个 region，它将尝试挑选 Leader region。最后，它将挑选出要移动的 region，或者 Scheduler 将尝试下一个 region 大小较小的 store，直到所有的 store 都将被尝试。</p>
<p>在您选择了一个要移动的 region 后，调度器将选择一个 store 作为目标。实际上，调度器将选择 region 大小最小的 store 。然后，调度程序将通过检查原始 store 和目标 store 的 region 大小之间的差异来判断这种移动是否有价值。如果差异足够大，Scheduler 应该在目标 store 上分配一个新的 peer 并创建一个 Movepeer 操作。</p>
<p>正如你可能已经注意到的，上面的例程只是一个粗略的过程。还剩下很多问题：</p>
<ul>
<li>哪些存储空间适合移动？</li>
</ul>
<p>简而言之，一个合适的 store 应该是 Up 的，而且 down 的时间不能超过集群的<code>MaxStoreDownTime</code>​，你可以通过 <code>cluster.GetMaxStoreDownTime()</code>​ 得到。</p>
<ul>
<li>如何选择区域？</li>
</ul>
<p>Scheduler 框架提供了三种方法来获取区域。<code>GetPendingRegionsWithLock</code>​, <code>GetFollowersWithLock</code>​ 和 <code>GetLeadersWithLock</code>​。Scheduler 可以从中获取相关region。然后你可以选择一个随机的region。</p>
<ul>
<li>如何判断这个操作是否有价值？</li>
</ul>
<p>如果原始 region 和目标 region 的 region 大小差异太小，在我们将 region 从原始 store 移动到目标 store 后，Scheduler 可能希望下次再移动回来。所以我们要确保这个差值必须大于 region 近似大小的2倍，这样才能保证移动后，目标 store 的 region 大小仍然小于原 store。</p>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project3a思路</title>
    <url>/2024/05/11/tinykv_project3a_solution/</url>
    <content><![CDATA[<span id="more"></span>

<p>在Raft层实现领导者转移和成员变更（<strong>虽然Raft层实现简单，但是存在很多细节问题需要注意，后面3B的测试问题一半都来自Raft层</strong>）</p>
<h2 id="领导者转移"><a href="#领导者转移" class="headerlink" title="领导者转移"></a>领导者转移</h2><p>HandleTransferLeader</p>
<ol>
<li><p>检查目标节点是否在集群当中，如果不在直接返回</p>
</li>
<li><p>如果当前节点不是leader，转发给Leader后返回</p>
</li>
<li><p>r.leadTransferee &#x3D; m.From</p>
</li>
<li><p>接收该请求</p>
<ol>
<li>检查目标节点的日志是否最新，如果不是则<code>sendAppend</code>​，而后返回（等后续<code>HandleAppendResponse</code>​来进一步处理</li>
<li>如果目标节点的日志已经最新，发送<code>TimeoutNow</code>​消息给它，让其立即开始选举；最后将leadTransferee置为None</li>
</ol>
</li>
</ol>
<p>HandleAppendResponse</p>
<p>当转移的目标节点日志不是最新时，HandleTransferLeader不能立即发送<code>TimeoutNow</code>​消息，而是<code>sendAppend</code>​使目标日志最新，这时需要在HandleAppendResponse中增加发送<code>TimeoutNow</code>​和重置<code>r.leadTransferee</code>​的逻辑。</p>
<blockquote>
<p>注意，当<code>leaderTransferee != None</code>​时，即在领导这转移过程中，不接受Propose请求，避免循环。</p>
</blockquote>
<p>‍</p>
<h2 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h2><p>Raft层的逻辑十分简单，主要是针对<code>r.Prs</code>​的修改。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addNode add a new node to raft group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> addNode(id <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (3A).</span></span><br><span class="line">	<span class="comment">// if exit</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := r.Prs[id]; ok &#123;</span><br><span class="line">		r.PendingConfIndex = None</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.Prs[id] = &amp;Progress&#123;</span><br><span class="line">		Match: <span class="number">0</span>,</span><br><span class="line">		Next:  <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	r.PendingConfIndex = None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeNode remove a node from raft group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> removeNode(id <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (3A).</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := r.Prs[id]; !ok &#123;</span><br><span class="line">		r.PendingConfIndex = None</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(r.Prs, id)</span><br><span class="line">	<span class="comment">// important: if leader, should update commit</span></span><br><span class="line">	<span class="keyword">if</span> r.State == StateLeader &#123;</span><br><span class="line">		r.tryUpdateCommit()</span><br><span class="line">	&#125;</span><br><span class="line">	r.PendingConfIndex = None</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>notice</p>
<ol>
<li>当<code>removeNode</code>​时，由于集群成员数量发生变化，Leader要尝试推进日志的提交</li>
<li>PendingConfIndex是一个值得注意的变量。当其不为None时，代表目前正有confChange发生，不再接收新的confChange请求，因此要在<code>HandlePropose</code>​中做一定的检查。判断条件为<code>r.PendingConfIndex != None &amp;&amp; r.PendingConfIndex &gt; r.RaftLog.applied</code>​，代表存在尚未应用的confChange。</li>
</ol>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project3b疑难杂症</title>
    <url>/2024/05/13/tinykv_project3b_problems/</url>
    <content><![CDATA[<span id="more"></span>

<p>我在做tinykv这个课程的过程中，3b之前遇到的问题大多能在网上找到解决方法，因此也没怎么做记录；而3b由于引入了Multi Raft以及集群成员变更、Split Region等Admin命令，对很多细节处理要求严格，并且测试点会模拟丢包和网络隔离等异常情况，需要做较多额外的针对性处理，因此我在做的时候遇到了许多网上难以找到的问题，通过在海量日志中一步步跟踪才解决了它们。</p>
<p>下面将对我在3b中遇到的疑难杂症及解决方法进行汇总。</p>
<h2 id="SnapShot相关"><a href="#SnapShot相关" class="headerlink" title="SnapShot相关"></a>SnapShot相关</h2><h3 id="（1）Request-Timeout-1"><a href="#（1）Request-Timeout-1" class="headerlink" title="（1）Request Timeout-1"></a>（1）Request Timeout-1</h3><p>问题原因：当前节点有snapshot正在被应用时，收到新的snapshot没有过滤掉</p>
<p>解决方法：当<code>r.RaftLog.pendingSnapshot != nil</code>​时不接受新的snapShot，并且不处理<code>Append</code>​消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleAppendEntries(m pb.Message) &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RaftLog.pendingSnapshot != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleSnapshot(m pb.Message) &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RaftLog.pendingSnapshot != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h3 id="（2）Request-Timeout-2"><a href="#（2）Request-Timeout-2" class="headerlink" title="（2）Request Timeout-2"></a>（2）Request Timeout-2</h3><p>问题原因：follower在处理append消息的时候，<code>prevLogIndex</code>​的条目在follower已经被Compact掉了（<strong>Leader当中反而没有被Compact，怪了</strong>），此时通过<code>RaftLog.Term()</code>​会返回错误，无法完成日志匹配动作，导致leader中记录的Match会保持不变，在集群中只有两个节点的情况下committed无法推进。</p>
<p>解决方法：follower返回响应，令leader主动发送一个Snapshot给自己，我这里利用了<code>MsgAppendResponse</code>​中没有使用的<code>commit</code>​字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ShouldSendSnapByCommit <span class="type">uint64</span> = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleAppendEntries(m pb.Message) &#123;</span><br><span class="line">。。。</span><br><span class="line">	tTerm, terr := r.RaftLog.Term(m.Index)</span><br><span class="line">		<span class="comment">// debug</span></span><br><span class="line">		lastTerm, _ := r.RaftLog.Term(r.RaftLog.LastIndex())</span><br><span class="line">		<span class="keyword">if</span> terr != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.DPrintfRaft(<span class="string">&quot;node %d handleAppendEntries from %d failed, get term failed: %v\n&quot;</span>, r.id, m.From, terr)</span><br><span class="line">			log.DPrintfRaft(<span class="string">&quot;l.entries: %d, i: %d, l.dummyIndex: %d, l.lastIndex: %d\n&quot;</span>, <span class="built_in">len</span>(r.RaftLog.entries), m.Index, r.RaftLog.dummyIndex, r.RaftLog.LastIndex())</span><br><span class="line"></span><br><span class="line">			<span class="comment">// tell leader should send snapshot</span></span><br><span class="line">			r.msgs = <span class="built_in">append</span>(r.msgs, pb.Message&#123;</span><br><span class="line">				MsgType: pb.MessageType_MsgAppendResponse,</span><br><span class="line">				To:      m.From,</span><br><span class="line">				From:    r.id,</span><br><span class="line">				Term:    lastTerm,</span><br><span class="line">				Index:   <span class="number">0</span>,</span><br><span class="line">				Reject:  <span class="literal">true</span>,</span><br><span class="line">				Commit:  ShouldSendSnapByCommit,</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleAppendResponse(m pb.Message) &#123;</span><br><span class="line">	<span class="keyword">if</span> m.Term &gt; r.Term &#123;</span><br><span class="line">		r.greaterTermRspNum += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> r.greaterTermRspNum &gt; GreaterTermRspThreshold &#123;</span><br><span class="line">			r.greaterTermRspNum = <span class="number">0</span></span><br><span class="line">			r.becomeFollower(m.Term, None)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// r.becomeFollower(m.Term, None)</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// special handle for need to send snapshot</span></span><br><span class="line">	<span class="keyword">if</span> m.Commit == ShouldSendSnapByCommit &#123;</span><br><span class="line">		r.sendSnapshot(m.From)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="TransferLeader相关"><a href="#TransferLeader相关" class="headerlink" title="TransferLeader相关"></a>TransferLeader相关</h2><h3 id="（1）Request-Timeout（选举冲突的问题）"><a href="#（1）Request-Timeout（选举冲突的问题）" class="headerlink" title="（1）Request Timeout（选举冲突的问题）"></a>（1）Request Timeout（选举冲突的问题）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[RaftStore]: node[[region <span class="number">1</span>] <span class="number">2</span>] propose common request: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; region_epoch:&lt;conf_ver:<span class="number">4</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Put put:&lt;cf:<span class="string">&quot;default&quot;</span> key:<span class="string">&quot;2 00000053&quot;</span> value:<span class="string">&quot;x 2 53 y&quot;</span> &gt; &gt; , leader: <span class="number">2</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">2</span> is leader, but leadTransferee is not None, stop accept propose</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">2</span> tryUpdateCommit: <span class="built_in">len</span>(r.Prs) = <span class="number">2</span>, r.RaftLog.LastIndex() = <span class="number">584</span>, r.committed = <span class="number">583</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">2</span> transfer leader to <span class="number">1</span> success! sendTimeoutNow!</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [RaftStore]: -------------------------------------------------------------------------</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [RaftStore]: node[[region <span class="number">1</span>] <span class="number">2</span>] propose common request: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; region_epoch:&lt;conf_ver:<span class="number">4</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Snap snap:&lt;&gt; &gt; , leader: <span class="number">2</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">2</span> tryUpdateCommit: <span class="built_in">len</span>(r.Prs) = <span class="number">2</span>, r.RaftLog.LastIndex() = <span class="number">585</span>, r.committed = <span class="number">584</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32.433521</span> cluster.<span class="keyword">go</span>:<span class="number">200</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [Cluster] request err resp. err: message:<span class="string">&quot;raft proposal dropped&quot;</span> , req: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; region_epoch:&lt;conf_ver:<span class="number">4</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Put put:&lt;cf:<span class="string">&quot;default&quot;</span> key:<span class="string">&quot;1 00000062&quot;</span> value:<span class="string">&quot;x 1 62 y&quot;</span> &gt; &gt; [<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32.433521</span> cluster.<span class="keyword">go</span>:<span class="number">200</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [Cluster] request err resp. err: message:<span class="string">&quot;raft proposal dropped&quot;</span> , req: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; region_epoch:&lt;conf_ver:<span class="number">4</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Put put:&lt;cf:<span class="string">&quot;default&quot;</span> key:<span class="string">&quot;4 00000046&quot;</span> value:<span class="string">&quot;x 4 46 y&quot;</span> &gt; &gt; [<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32.433564</span> cluster.<span class="keyword">go</span>:<span class="number">200</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [Cluster] request err resp. err: message:<span class="string">&quot;raft proposal dropped&quot;</span> , req: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; region_epoch:&lt;conf_ver:<span class="number">4</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Put put:&lt;cf:<span class="string">&quot;default&quot;</span> key:<span class="string">&quot;2 00000053&quot;</span> value:<span class="string">&quot;x 2 53 y&quot;</span> &gt; &gt; [<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [RaftStore]: node[[region <span class="number">1</span>] <span class="number">2</span>]: process common request: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; region_epoch:&lt;conf_ver:<span class="number">4</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Put put:&lt;cf:<span class="string">&quot;default&quot;</span> key:<span class="string">&quot;0 00000057&quot;</span> value:<span class="string">&quot;x 0 57 y&quot;</span> &gt; &gt; </span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">1</span> handleAppendEntries from <span class="number">2</span>, lastIndex: <span class="number">584</span>,preLogIndex: <span class="number">583</span>, preLogTerm: <span class="number">6</span>, <span class="built_in">len</span>(m.Entries): <span class="number">1</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">1</span> handleAppendEntries from <span class="number">2</span> success, conflictFlag: <span class="literal">true</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">1</span> handleAppendEntries from <span class="number">2</span>, lastIndex: <span class="number">584</span>,preLogIndex: <span class="number">583</span>, preLogTerm: <span class="number">6</span>, <span class="built_in">len</span>(m.Entries): <span class="number">1</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">1</span> handleAppendEntries from <span class="number">2</span> success, conflictFlag: <span class="literal">true</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">1</span> handleAppendEntries from <span class="number">2</span>, lastIndex: <span class="number">584</span>,preLogIndex: <span class="number">584</span>, preLogTerm: <span class="number">6</span>, <span class="built_in">len</span>(m.Entries): <span class="number">0</span></span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">22</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">32</span> [Raft]: node <span class="number">1</span> handleAppendEntries from <span class="number">2</span> success, conflictFlag: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，当Node 2<code>sendTimeOutNow</code>​给1之后，由于还是leader，且<code>leaderTransferee == None</code>​，能够propose新的entry，导致node 1发起选举之后，没办法得到选票，没办法当选，从而造成冲突。</p>
<p>解决方法：leader在<code>sendTimeoutNow</code>​之后主动变为follower，从而不会接收到propose产生新的entry，目标节点能够顺利当选。</p>
<p>‍</p>
<h3 id="（2）TransferLeader的超时机制"><a href="#（2）TransferLeader的超时机制" class="headerlink" title="（2）TransferLeader的超时机制"></a>（2）TransferLeader的超时机制</h3><p>如果领导权转移的目标节点失联，会导致leader一直处于leadTransferee的状态，没办法propose entry，因此要为TransferLeader增加超时机制，我直接使用选举超时作为领导权转移的超时时间。TransferLeader成功后<code>becomefollower()</code>​会完成清零选举超时的工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> tickLeader() &#123;</span><br><span class="line">	<span class="comment">// special handle with leadTransforee</span></span><br><span class="line">	<span class="keyword">if</span> r.leadTransferee != None &#123;</span><br><span class="line">		r.electionElapsed += <span class="number">1</span></span><br><span class="line">		<span class="comment">// can&#x27;t transfer success before a ElectTimeout, give up</span></span><br><span class="line">		<span class="keyword">if</span> r.electionElapsed &gt;= r.randElectTimeout &#123;</span><br><span class="line">			r.leadTransferee = None</span><br><span class="line">			r.electionElapsed = <span class="number">0</span></span><br><span class="line">			r.randElectTimeout = r.electionTimeout + rand.Intn(r.electionTimeout)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>‍</p>
<h2 id="confChange相关"><a href="#confChange相关" class="headerlink" title="confChange相关"></a>confChange相关</h2><h3 id="（1）无法正确处理confChange命令"><a href="#（1）无法正确处理confChange命令" class="headerlink" title="（1）无法正确处理confChange命令"></a>（1）无法正确处理confChange命令</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">--- FAIL: TestBasicConfChange3B (<span class="number">6.34</span>s)</span><br><span class="line"><span class="built_in">panic</span>: have peer: id:<span class="number">2</span> store_id:<span class="number">2</span>  [recovered]</span><br><span class="line">	<span class="built_in">panic</span>: have peer: id:<span class="number">2</span> store_id:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>错误原因：ConfChange条目中的数据不正确</p>
<p>Solution：在Propose中，针对 ConfChange 请求的序列化和反序列化方式与其他请求不同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, marErr := msg.Marshal()</span><br><span class="line"><span class="keyword">if</span> marErr != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(marErr)</span><br><span class="line">&#125;</span><br><span class="line">err := d.RaftGroup.ProposeConfChange(eraftpb.ConfChange&#123;</span><br><span class="line">	ChangeType: msg.AdminRequest.ChangePeer.ChangeType,</span><br><span class="line">	NodeId:     msg.AdminRequest.ChangePeer.Peer.Id,</span><br><span class="line">	Context:    ctx,			<span class="comment">// notice</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="（2）AddNode后-RequestTimeout（对于未初始化的Raft节点的处理）"><a href="#（2）AddNode后-RequestTimeout（对于未初始化的Raft节点的处理）" class="headerlink" title="（2）AddNode后 RequestTimeout（对于未初始化的Raft节点的处理）"></a>（2）AddNode后 RequestTimeout（对于未初始化的Raft节点的处理）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">-- FAIL: TestBasicConfChange3B (<span class="number">52.68</span>s)</span><br><span class="line"><span class="built_in">panic</span>: request timeout [recovered]</span><br><span class="line">	<span class="built_in">panic</span>: request timeout</span><br></pre></td></tr></table></figure>

<p>错误原因：对于Raft节点不在集群当中（尚未初始化）的情况，屏蔽掉了<code>HeartBeat</code>​和<code>Snapshot</code>​消息，使得节点不能通过leader发送的Snapshot完成初始化，进而导致committed始终无法向前推进（<strong>由于新节点的原因无法满足“集群大多数”的条件</strong>），请求无法应用而超时。</p>
<p>Solution：对于Raft节点不在集群当中（尚未初始化）的情况，只能屏蔽选举相关的消息。</p>
<h3 id="（3）​-region-x-x-meta-corruption-detected​"><a href="#（3）​-region-x-x-meta-corruption-detected​" class="headerlink" title="（3）​[region x] x meta corruption detected​"></a>（3）​[region x] x meta corruption detected​</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span>/<span class="number">12</span>/<span class="number">29</span> <span class="number">12</span>:<span class="number">16</span>:<span class="number">14</span> request err resp.</span><br><span class="line"><span class="built_in">panic</span>: [region <span class="number">1</span>] <span class="number">5</span> meta corruption detected</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">321</span> [running]:</span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).destroyPeer(<span class="number">0xc17c9b9e10</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">975</span> +<span class="number">0x265</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).processConfChange(<span class="number">0xc17c9b9e10</span>, <span class="number">0xc17c924d50</span>?, <span class="number">0xc17c9b9aa0</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">253</span> +<span class="number">0x6de</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).process(<span class="number">0xc17c9b9e10</span>, <span class="number">0xc17c9b9c40</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">351</span> +<span class="number">0x199</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).HandleRaftReady(<span class="number">0xc17c9b9e10</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">450</span> +<span class="number">0x408</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*raftWorker).run(<span class="number">0xc000264920</span>, <span class="number">0xc000039440</span>, <span class="number">0x0</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/raft_worker.<span class="keyword">go</span>:<span class="number">70</span> +<span class="number">0x439</span></span><br><span class="line">created by github.com/pingcap-incubator/tinykv/kv/raftstore.(*Raftstore).startWorkers</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/raftstore.<span class="keyword">go</span>:<span class="number">271</span> +<span class="number">0x17b</span></span><br><span class="line">FAIL	github.com/pingcap-incubator/tinykv/kv/test_raftstore	<span class="number">2.015</span>s</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>

<p>根据报错信息可以找到出错的位置在<code>destroyPeer</code>​，出错的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := meta.regions[regionID]; !ok &#123;</span><br><span class="line">	<span class="built_in">panic</span>(d.Tag + <span class="string">&quot; meta corruption detected&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出错原因：对于RemoveNode命令的apply，不需要对<code>storeMeta</code>​进行修改，<code>destoryPeer</code>​会负责对<code>storeMeta</code>​的修改。因此下列操作是不应该做的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d.ctx.storeMeta.Lock()</span><br><span class="line"><span class="built_in">delete</span>(d.ctx.storeMeta.regions, targetPeer.Id)</span><br><span class="line">d.ctx.storeMeta.regionRanges.Delete(&amp;regionItem&#123;region: region&#125;)</span><br><span class="line">d.ctx.storeMeta.Unlock()</span><br></pre></td></tr></table></figure>

<p>Solution：在RemoveNode的Apply处理中去掉</p>
<h3 id="（4）confChange-Request-TimeOut（propose成功，但是confChange无法添加到RaftLog当中）"><a href="#（4）confChange-Request-TimeOut（propose成功，但是confChange无法添加到RaftLog当中）" class="headerlink" title="（4）confChange Request TimeOut（propose成功，但是confChange无法添加到RaftLog当中）"></a>（4）confChange Request TimeOut（propose成功，但是confChange无法添加到RaftLog当中）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">--- FAIL: TestConfChangeRecover3B (<span class="number">58.85</span>s)</span><br><span class="line"><span class="built_in">panic</span>: request timeout [recovered]</span><br><span class="line">	<span class="built_in">panic</span>: request timeout</span><br></pre></td></tr></table></figure>

<p>错误原因：当<code>r.PendingConfIndex != None</code>​，会忽略所有新的confChange Entry而不报错，这就造成了能够<code>ProposeConfChange</code>​成功，但是Entry却没有append进去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> appendEntries(entries ...*pb.Entry) &#123;</span><br><span class="line">	ents := <span class="built_in">make</span>([]pb.Entry, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> entries &#123;</span><br><span class="line">		<span class="keyword">if</span> e.EntryType == pb.EntryType_EntryConfChange &#123;</span><br><span class="line">			<span class="keyword">if</span> r.PendingConfIndex != None &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			r.PendingConfIndex = e.Index</span><br><span class="line">		&#125;</span><br><span class="line">		ents = <span class="built_in">append</span>(ents, pb.Entry&#123;</span><br><span class="line">			EntryType: e.EntryType,</span><br><span class="line">			Term:      e.Term,</span><br><span class="line">			Index:     e.Index,</span><br><span class="line">			Data:      e.Data,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	r.RaftLog.appendEntries(ents...)</span><br><span class="line">	r.Prs[r.id].Match = r.RaftLog.LastIndex()</span><br><span class="line">	r.Prs[r.id].Next = r.RaftLog.LastIndex() + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然这个条件<code>r.PendingConfIndex != None</code>​是不合适的，错误地忽略了不该忽略的confChange Entry。</p>
<p>正确的条件应该是：<code>r.PendingConfIndex != None &amp;&amp; r.PendingConfIndex &gt; r.RaftLog.applied</code>​，代表还有confChange Entry没有被Apply（已经Apply的显然可以忽略了）</p>
<h3 id="（5）删除节点时会遇到-Request-timeout-问题"><a href="#（5）删除节点时会遇到-Request-timeout-问题" class="headerlink" title="（5）删除节点时会遇到 Request timeout 问题"></a>（5）删除节点时会遇到 Request timeout 问题</h3><p>观察日志，发现一直在进行选举</p>
<p>​<img src="/2024/05/13/tinykv_project3b_problems/image-20240121115130-zowanex.png" alt="image">​</p>
<p>解决参考：</p>
<p><a href="https://github.com/Smith-Cruise/TinyKV-White-Paper/blob/main/Project3-MultiRaftKV.md">TinyKV-White-Paper&#x2F;Project3-MultiRaftKV.md at main · Smith-Cruise&#x2F;TinyKV-White-Paper (github.com)</a></p>
<p>问题原因：只剩两个节点，然后被移除的那个节点正好是 Leader。因为网络是 unreliable，Leader 广播给另一个 Node 的心跳正好被丢了，也就是另一个节点的 commit 并不会被推进，也就是对方节点并不会执行 remove node 操作。而这一切 Leader 并不知道，它自己调用 <code>d.destroyPeer()</code>​ 已经销毁了。此时另一个节点并没有移除 Leader，它会发起选举，但是永远赢不了，因为需要收到被移除 Leader 的投票。</p>
<p>白皮书提供的解决方法：</p>
<ol>
<li>在 propose 阶段，如果已经处于两节点，被移除的正好是 Leader，那么直接拒绝该 propose，并且发起 Transfer Leader 到另一个节点上。Client 到时候会重试 remove node 指令。</li>
<li>在 apply 阶段 DestroyPeer 上面做一个保险（有必要，虽然用到的概率很低），让 Leader 在自己被 remove 前重复多次发送心跳到目标节点，尝试推动目标节点的 commit。重复多次是为了抵消测试用例的 unreliable</li>
</ol>
<p>我这里两个都实现了，不同的是第二个的保险措施我发送的是Append消息而不是心跳消息（我的Raft层实现中follower处理心跳没有推进Commit），并且根据我的测试，重复的次数为5已经够了。</p>
<p>即使如此，仍然只是在概率上避免了这个问题，不能完美的解决。</p>
<p>‍</p>
<h2 id="Split相关"><a href="#Split相关" class="headerlink" title="Split相关"></a>Split相关</h2><h3 id="（1）Snap请求处理超时"><a href="#（1）Snap请求处理超时" class="headerlink" title="（1）Snap请求处理超时"></a>（1）Snap请求处理超时</h3><p>日志显示总是snap消息的处理问题，总是报错<code>key not in region</code>​，而snap不涉及key。</p>
<p>问题原因：出在propose上面，对common request进行<code>key in region</code>​检查时应该跳过<code>Snap request</code>​，而这里忘记跳过了。</p>
<p>解决方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check if key in region</span></span><br><span class="line"><span class="keyword">for</span> _, req := <span class="keyword">range</span> msg.Requests &#123;</span><br><span class="line">	<span class="keyword">if</span> req.CmdType != raft_cmdpb.CmdType_Snap &#123;</span><br><span class="line">		<span class="keyword">if</span> err := util.CheckKeyInRegion(getRequestKey(req), d.Region()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			cb.Done(ErrResp(err))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）key-xxx…-is-not-in-region-xx"><a href="#（2）key-xxx…-is-not-in-region-xx" class="headerlink" title="（2）key [xxx…] is not in region xx"></a>（2）key [xxx…] is not in region xx</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: key [<span class="number">49</span> <span class="number">55</span> <span class="number">32</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span>] is not in region id:<span class="number">1</span> end_key:<span class="string">&quot;13 00000001&quot;</span> region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">2</span> &gt; peers:&lt;id:<span class="number">1</span> store_id:<span class="number">1</span> &gt; peers:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; peers:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; peers:&lt;id:<span class="number">4</span> store_id:<span class="number">4</span> &gt; peers:&lt;id:<span class="number">5</span> store_id:<span class="number">5</span> &gt; </span><br><span class="line"></span><br><span class="line">goroutine <span class="number">327</span> [running]:</span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/storage/raft_storage.(*RegionIterator).Seek(<span class="number">0xc17cb84ed0</span>, &#123;<span class="number">0xc17cc01d50</span>, <span class="number">0xb</span>, <span class="number">0x10</span>?&#125;)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/storage/raft_storage/region_reader.<span class="keyword">go</span>:<span class="number">83</span> +<span class="number">0xec</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/test_raftstore.(*Cluster).Scan(<span class="number">0xb86019</span>?, &#123;<span class="number">0xc17cc01d50</span>, <span class="number">0xb</span>, <span class="number">0x10</span>&#125;, &#123;<span class="number">0xc17c6dddb0</span>, <span class="number">0xb</span>, <span class="number">0x20</span>&#125;)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/test_raftstore/cluster.<span class="keyword">go</span>:<span class="number">388</span> +<span class="number">0x322</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/test_raftstore.GenericTest.func1(<span class="number">0x11</span>, <span class="number">0x0</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/test_raftstore/test_test.<span class="keyword">go</span>:<span class="number">218</span> +<span class="number">0x533</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/test_raftstore.runClient(<span class="number">0x0</span>?, <span class="number">0x0</span>?, <span class="number">0x0</span>?, <span class="number">0x0</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/test_raftstore/test_test.<span class="keyword">go</span>:<span class="number">27</span> +<span class="number">0x78</span></span><br><span class="line">created by github.com/pingcap-incubator/tinykv/kv/test_raftstore.SpawnClientsAndWait</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/test_raftstore/test_test.<span class="keyword">go</span>:<span class="number">37</span> +<span class="number">0x85</span></span><br><span class="line">FAIL	github.com/pingcap-incubator/tinykv/kv/test_raftstore	<span class="number">6.645</span>s</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>

<p>问题原因分析：报错是由Scan操作（对应Snap命令）引起的，Seek()函数产生的报错，错误原因是key不在该region中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *RegionIterator)</span></span> Seek(key []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := util.CheckKeyInRegion(key, it.region); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	it.iter.Seek(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜想哪些情况会导致上述错误的发生：</p>
<ol>
<li>处理Snap命令时<code>region := c.GetRegion(key)</code>​获取了错误的region（这种情况有可能是在更新region后，没有及时告知Scheduler）</li>
<li>目标region在请求过程中发生了变化，导致错误产生（然而Snap请求不包含key字段，没办法在raftStore中通过<code>checkKeyInRegion</code>​检查，所以为了避免Snap的key错误，当region发生变化时，清空所有proposals么？？）</li>
</ol>
<p>再仔细打印和观察日志</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03</span> [RaftStore]: process common request: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Snap snap:&lt;&gt; &gt; </span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03</span> [RaftStore]: process common request: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Snap snap:&lt;&gt; &gt; </span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03</span> [RaftStore]: process admin request: Split</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03.477082</span> cluster.<span class="keyword">go</span>:<span class="number">204</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [Cluster] kv/test_raftstore/cluster.<span class="keyword">go</span>: request success. req: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Snap snap:&lt;&gt; &gt; [<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03.477110</span> cluster.<span class="keyword">go</span>:<span class="number">204</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [Cluster] kv/test_raftstore/cluster.<span class="keyword">go</span>: request success. req: header:&lt;region_id:<span class="number">1</span> peer:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">1</span> &gt; &gt; requests:&lt;cmd_type:Snap snap:&lt;&gt; &gt; [<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03.477145</span> region_reader.<span class="keyword">go</span>:<span class="number">84</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] seek key [<span class="number">51</span> <span class="number">32</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span>] in region <span class="number">1</span> failed: key [<span class="number">51</span> <span class="number">32</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span>] is not in region id:<span class="number">1</span> end_key:<span class="string">&quot;18 00000000&quot;</span> region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">2</span> &gt; peers:&lt;id:<span class="number">1</span> store_id:<span class="number">1</span> &gt; peers:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; peers:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; peers:&lt;id:<span class="number">4</span> store_id:<span class="number">4</span> &gt; peers:&lt;id:<span class="number">5</span> store_id:<span class="number">5</span> &gt; [<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">04</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">03.477158</span> region_reader.<span class="keyword">go</span>:<span class="number">84</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] seek key [<span class="number">56</span> <span class="number">32</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span>] in region <span class="number">1</span> failed: key [<span class="number">56</span> <span class="number">32</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span> <span class="number">48</span>] is not in region id:<span class="number">1</span> end_key:<span class="string">&quot;18 00000000&quot;</span> region_epoch:&lt;conf_ver:<span class="number">1</span> version:<span class="number">2</span> &gt; peers:&lt;id:<span class="number">1</span> store_id:<span class="number">1</span> &gt; peers:&lt;id:<span class="number">2</span> store_id:<span class="number">2</span> &gt; peers:&lt;id:<span class="number">3</span> store_id:<span class="number">3</span> &gt; peers:&lt;id:<span class="number">4</span> store_id:<span class="number">4</span> &gt; peers:&lt;id:<span class="number">5</span> store_id:<span class="number">5</span> &gt; [<span class="number">0</span>m</span><br></pre></td></tr></table></figure>

<p>发现错误原因是，已经处理完了Snap请求，但是之后执行了一个Split操作，导致region更新以后，再进行Scan就出错了，这是因为Snap响应中包含一个当前region的指针，Split之后就会导致<code>key not in region</code>​的错误。</p>
<p>解决方法：在Snap命令之后执行的Split命令不应当造成影响，因此要在返回Snap响应时拷贝一份region，从而避免后面的命令对region的修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> raft_cmdpb.CmdType_Snap:</span><br><span class="line">	<span class="comment">// solve key not in region error: copy region</span></span><br><span class="line">	region := <span class="built_in">new</span>(metapb.Region)</span><br><span class="line">	err := util.CloneMsg(d.Region(), region)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// resp.Responses = []*raft_cmdpb.Response&#123;&#123;CmdType: raft_cmdpb.CmdType_Snap, Snap: &amp;raft_cmdpb.SnapResponse&#123;Region: d.Region()&#125;&#125;&#125;</span></span><br><span class="line">	resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;CmdType: raft_cmdpb.CmdType_Snap, Snap: &amp;raft_cmdpb.SnapResponse&#123;Region: region&#125;&#125;)</span><br><span class="line">	p.cb.Txn = d.peerStorage.Engines.Kv.NewTransaction(<span class="literal">false</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）test-timed-out-after-10m0s"><a href="#（3）test-timed-out-after-10m0s" class="headerlink" title="（3）test timed out after 10m0s"></a>（3）test timed out after 10m0s</h3><p>这个是困扰我最久的一个错误，在上一篇project3b思路中也提到了。</p>
<p>错误原因是测试时间太久了。但是我根本不知道为什么这么久，一开始以为是选举太慢了，直到看到了<code>peer</code>​中两个成员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An inaccurate difference in region size since last reset.</span></span><br><span class="line"><span class="comment">// split checker is triggered when it exceeds the threshold, it makes split checker not scan the data very often</span></span><br><span class="line"><span class="comment">// (Used in 3B split)</span></span><br><span class="line">SizeDiffHint <span class="type">uint64</span></span><br><span class="line"><span class="comment">// Approximate size of the region.</span></span><br><span class="line"><span class="comment">// It&#x27;s updated everytime the split checker scan the data</span></span><br><span class="line"><span class="comment">// (Used in 3B split)</span></span><br><span class="line">ApproximateSize *<span class="type">uint64</span></span><br></pre></td></tr></table></figure>

<p>原来split checker会依据<code>SizeDiffHint</code>​来判断region承载的数据量是否超出阈值，从而触发split操作。</p>
<p>因此要做如下两个修改</p>
<ol>
<li><p>Apply Admin_Split完成后，要对<code>SizeDiffHint</code>​和<code>ApproximateSize</code>​更新</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clear region size</span></span><br><span class="line">d.SizeDiffHint = <span class="number">0</span></span><br><span class="line">d.ApproximateSize = <span class="built_in">new</span>(<span class="type">uint64</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>Apply <code>put/delete</code>​时对<code>SizeDiffHint</code>​进行调整，在 <code>Put</code>​ 的时候，<code>SizeDiffHint</code>​ 加上 <code>key</code>​ 和 <code>value</code>​ 的大小；在 <code>Delete</code>​ 的时候，减去 <code>key</code>​ 的大小。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> raft_cmdpb.CmdType_Put:</span><br><span class="line">	wb.SetCF(req.Put.Cf, req.Put.Key, req.Put.Value)</span><br><span class="line">	d.SizeDiffHint += <span class="type">uint64</span>(<span class="built_in">len</span>(req.Put.Key) + <span class="built_in">len</span>(req.Put.Value))</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> raft_cmdpb.CmdType_Delete:</span><br><span class="line">	wb.DeleteCF(req.Delete.Cf, req.Delete.Key)</span><br><span class="line">	d.SizeDiffHint -= <span class="type">uint64</span>(<span class="built_in">len</span>(req.Delete.Key))</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>当时没仔细看白皮书，它里面有提到过这个问题：</p>
<p>在 <code>nclient &gt;= 8 &amp;&amp; crash = true &amp;&amp; split = true</code>​ 这种条件下，测试在 Delete 阶段卡死问题，这是因为在 apply <code>CmdType_Put</code>​ 和 <code>CmdType_Delete</code>​ 请求的时候没有更新 <code>SizeDiffHint</code>​。因此需要在 <code>Put</code>​ 的时候，<code>SizeDiffHint</code>​ 加上 <code>key</code>​ 和 <code>value</code>​ 的大小；在 <code>Delete</code>​ 的时候，减去 <code>key</code>​ 的大小。</p>
</blockquote>
<h3 id="（4）runtime-error-index-out-of-range-1-with-length-1"><a href="#（4）runtime-error-index-out-of-range-1-with-length-1" class="headerlink" title="（4）runtime error: index out of range [1] with length 1"></a>（4）runtime error: index out of range [1] with length 1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.882060</span> peer.<span class="keyword">go</span>:<span class="number">55</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [region <span class="number">1</span>] replicates peer with ID <span class="number">14</span>[<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.885097</span> peer_storage.<span class="keyword">go</span>:<span class="number">182</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [region <span class="number">1</span>] <span class="number">5</span> requesting snapshot[<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.984182</span> peer_storage.<span class="keyword">go</span>:<span class="number">341</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] [region <span class="number">1</span>] <span class="number">14</span> begin to apply snapshot[<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.984211</span> region_task.<span class="keyword">go</span>:<span class="number">93</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] begin apply snap data. [regionId: <span class="number">1</span>][<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.984223</span> region_task.<span class="keyword">go</span>:<span class="number">137</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] succeed in deleting data in <span class="keyword">range</span>. [regionId: <span class="number">1</span>, startKey: , endKey: <span class="number">32203030303030303033</span>][<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.996109</span> snap.<span class="keyword">go</span>:<span class="number">700</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] apply snapshot ingested <span class="number">1</span> tables[<span class="number">0</span>m</span><br><span class="line"><span class="number">2024</span>/<span class="number">02</span>/<span class="number">16</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">40.996163</span> region_task.<span class="keyword">go</span>:<span class="number">117</span>: [<span class="number">0</span>;<span class="number">37</span>m[info] applying <span class="built_in">new</span> data. [regionId: <span class="number">1</span>, timeTakes: <span class="number">11.892027</span>ms][<span class="number">0</span>m</span><br><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: index out of <span class="keyword">range</span> [<span class="number">1</span>] with length <span class="number">1</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">288</span> [running]:</span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).processAdminRequest(<span class="number">0xc191a41e10</span>, <span class="number">0xc00000000a</span>?, <span class="number">0x27</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">137</span> +<span class="number">0xe08</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).process(<span class="number">0xc191a41e10</span>, <span class="number">0xc224bbdea0</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">442</span> +<span class="number">0x347</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).HandleRaftReady(<span class="number">0xc191a41e10</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">677</span> +<span class="number">0x57f</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*raftWorker).run(<span class="number">0xc1051b3840</span>, <span class="number">0xc000194d20</span>, <span class="number">0x0</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/raft_worker.<span class="keyword">go</span>:<span class="number">70</span> +<span class="number">0x439</span></span><br><span class="line">created by github.com/pingcap-incubator/tinykv/kv/raftstore.(*Raftstore).startWorkers</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/raftstore.<span class="keyword">go</span>:<span class="number">271</span> +<span class="number">0x17b</span></span><br><span class="line">FAIL	github.com/pingcap-incubator/tinykv/kv/test_raftstore	<span class="number">6.899</span>s</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>

<p>报错点在应用Split命令处</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> raft_cmdpb.AdminCmdType_Split:</span><br><span class="line">	leftRegion := d.Region()</span><br><span class="line">	<span class="comment">// check</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// backup rawRegion for delete regionRange</span></span><br><span class="line">	rawRegion := <span class="built_in">new</span>(metapb.Region)</span><br><span class="line">	util.CloneMsg(leftRegion, rawRegion)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create rightRegion</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// create rightRegion</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	rightRegion := <span class="built_in">new</span>(metapb.Region)</span><br><span class="line">	util.CloneMsg(leftRegion, rightRegion)</span><br><span class="line">	<span class="comment">// newPeers and split Region</span></span><br><span class="line">	newPeers := <span class="built_in">make</span>([]*metapb.Peer, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i, peer := <span class="keyword">range</span> leftRegion.Peers &#123;</span><br><span class="line">		newPeers = <span class="built_in">append</span>(newPeers, &amp;metapb.Peer&#123;</span><br><span class="line">			Id:      split.NewPeerIds[i],</span><br><span class="line">			StoreId: peer.StoreId,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [StartKey, SplitKey) -&gt; leftRegion</span></span><br><span class="line">	<span class="comment">// [SplitKey, EndKey) -&gt; rightRegion</span></span><br><span class="line">	rightRegion.Id = split.NewRegionId</span><br><span class="line">	rightRegion.StartKey = split.SplitKey</span><br><span class="line">	rightRegion.Peers = newPeers</span><br><span class="line">	leftRegion.EndKey = split.SplitKey</span><br><span class="line"></span><br><span class="line">	leftRegion.RegionEpoch.Version += <span class="number">1</span></span><br><span class="line">	rightRegion.RegionEpoch.Version += <span class="number">1</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>这里默认<code>leftRegion.Peers</code>​与<code>split.NewPeerIds</code>​长度相同了，但实际可能没有，因此要修改，保证不会越界即可。</p>
<p>我这里直接判定长度是否相等了，如果不相等直接返回，等客户端重试。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(leftRegion.Peers) != <span class="built_in">len</span>(split.NewPeerIds) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）find-no-peer-for-store-4-in-region-id-13-start-key-”0-00000011”-end-key-”2-00000004”"><a href="#（5）find-no-peer-for-store-4-in-region-id-13-start-key-”0-00000011”-end-key-”2-00000004”" class="headerlink" title="（5）find no peer for store 4 in region id:13 start_key:”0 00000011” end_key:”2 00000004”"></a>（5）find no peer for store 4 in region id:13 start_key:”0 00000011” end_key:”2 00000004”</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: find no peer <span class="keyword">for</span> store <span class="number">4</span> in region id:<span class="number">13</span> start_key:<span class="string">&quot;0 00000011&quot;</span> end_key:<span class="string">&quot;2 00000004&quot;</span> region_epoch:&lt;conf_ver:<span class="number">6</span> version:<span class="number">3</span> &gt; peers:&lt;id:<span class="number">14</span> store_id:<span class="number">2</span> &gt; </span><br><span class="line"></span><br><span class="line">goroutine <span class="number">271</span> [running]:</span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).processAdminRequest(<span class="number">0xc17bdbfe10</span>, <span class="number">0xc10000000a</span>?, <span class="number">0x27</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">187</span> +<span class="number">0xdfd</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).process(<span class="number">0xc17bdbfe10</span>, <span class="number">0xc20d840140</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">445</span> +<span class="number">0x347</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*peerMsgHandler).HandleRaftReady(<span class="number">0xc17bdbfe10</span>)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/peer_msg_handler.<span class="keyword">go</span>:<span class="number">680</span> +<span class="number">0x57f</span></span><br><span class="line">github.com/pingcap-incubator/tinykv/kv/raftstore.(*raftWorker).run(<span class="number">0xc000130b80</span>, <span class="number">0xc0002a51a0</span>, <span class="number">0x0</span>?)</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/raft_worker.<span class="keyword">go</span>:<span class="number">70</span> +<span class="number">0x439</span></span><br><span class="line">created by github.com/pingcap-incubator/tinykv/kv/raftstore.(*Raftstore).startWorkers</span><br><span class="line">	/home/sszgwdk/project/tinykv/tinykv/kv/raftstore/raftstore.<span class="keyword">go</span>:<span class="number">271</span> +<span class="number">0x17b</span></span><br><span class="line">FAIL	github.com/pingcap-incubator/tinykv/kv/test_raftstore	<span class="number">7.331</span>s</span><br><span class="line">FAIL</span><br><span class="line">rm -rf /tmp<span class="comment">/*test-raftstore*</span></span><br></pre></td></tr></table></figure>

<p>报错位置：Apply Split创建新的Peer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Peer: creat and register and start</span></span><br><span class="line">newPeer, err := createPeer(d.ctx.store.Id, d.ctx.cfg, d.ctx.regionTaskSender, d.ctx.engine, rightRegion)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出问题的地方与上一个错误一样，没有对<code>newPeers</code>​是否为空进行判断，也没有对<code>newPeers</code>​是否包含当前store进行检查。</p>
<p>解决方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newPeers := <span class="built_in">make</span>([]*metapb.Peer, <span class="number">0</span>)</span><br><span class="line">hasCurrentStore := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(leftRegion.Peers) != <span class="built_in">len</span>(split.NewPeerIds) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, peer := <span class="keyword">range</span> leftRegion.Peers &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(split.NewPeerIds) &#123;</span><br><span class="line">		newPeers = <span class="built_in">append</span>(newPeers, &amp;metapb.Peer&#123;</span><br><span class="line">			Id:      split.NewPeerIds[i],</span><br><span class="line">			StoreId: peer.StoreId,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> peer.StoreId == d.ctx.store.GetId() &#123;</span><br><span class="line">			hasCurrentStore = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(newPeers) == <span class="number">0</span> || !hasCurrentStore &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project3b思路</title>
    <url>/2024/05/12/tinykv_project3b_solution/</url>
    <content><![CDATA[<span id="more"></span>

<p>project3b是整个tinykv中最难的部分，测试会出现很多问题，往往需要通过打印大量日志才能找到问题的原因，因此在编程时要尤其注意一些细节。不过调试这些Bug也是该项目的内容之一，锻炼发现问题解决问题的能力，加深对分布式kv引擎的认识。</p>
<p>project3b的代码实现最主要还是在<code>kv/raftstore/peer_msg_handler.go</code>​当中，当然在调试过程中必然会发现Raft层的处理也会有很多问题要进行修改。</p>
<p>project3b增加了三个admin命令：TransferLeader，ChangePeer，Split。为了使tinykv支持这些命令，要完成对应的Propose和Process的逻辑。建议尽量将普通命令和admin命令的Propose和Process分开处理，不要太耦合。</p>
<h2 id="TransferLeader"><a href="#TransferLeader" class="headerlink" title="TransferLeader"></a>TransferLeader</h2><p>如文档所说，TransferLeader是一个动作不需要作为一条日志Propose到Raft层共识，更不需要Process，只需要调用 RawNode 的 TransferLeader() 方法并返回响应。</p>
<h2 id="ChangePeer"><a href="#ChangePeer" class="headerlink" title="ChangePeer"></a>ChangePeer</h2><p>propose ChangePeer命令的流程与之前普通命令类似，不同的是调用的RawNode接口由<code>Propose</code>​变成了<code>ProposeConfChange</code>​</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">perr := d.RaftGroup.ProposeConfChange(eraftpb.ConfChange&#123;</span><br><span class="line">	ChangeType: msg.AdminRequest.ChangePeer.ChangeType,</span><br><span class="line">	NodeId:     msg.AdminRequest.ChangePeer.Peer.Id,</span><br><span class="line">	Context:    ctx,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>process的流程则相对复杂，需要按照check、apply、response三步来做。</p>
<p>对于check，由于ChangePeer不涉及key，所以不要考虑<strong>ErrKeyNotInRegion，</strong>但是需要考虑<strong>ErrEpochNotMatch</strong>，使用<code>util.CheckRegionEpoch</code>​方法，具体用法可以参考<code>preProposeRaftCommand</code>​中的代码。</p>
<blockquote>
<p>实际上在propose之前也需要检查<strong>ErrEpochNotMatch，</strong>不过已经在<code>preProposeRaftCommand</code>​中已经实现了。</p>
<p><strong>如果检查出错误，需要利用proposals中的回调返回errResponse。</strong></p>
</blockquote>
<p>对于apply，分为AddNode和RemoveNode两种。</p>
<h3 id="AddNode的Apply"><a href="#AddNode的Apply" class="headerlink" title="AddNode的Apply"></a>AddNode的Apply</h3><ol>
<li><p>检查是否是重复的命令，即如果节点已在集群中，此时跳过apply</p>
</li>
<li><p>修改并写入<code>RegionLocalState</code>​（使用​<code>meta.WriteRegionState</code>​），包括<code>RegionEpoch</code>​和<code>Region&#39;s peers</code>​</p>
<ol>
<li>​<code>region.Peers = append(region.Peers, targetPeer)</code>​</li>
<li>​<code>region.RegionEpoch.ConfVer += 1</code>​</li>
</ol>
</li>
<li><p>更新<code>GlobalContext storeMeta</code>​，包括<code>regions</code>​和<code>regionRanges</code>​，<strong>注意访问和修改时的加锁</strong></p>
</li>
<li><p>​<code>insertPeerCache</code>​，<code>d.RaftGroup.ApplyConfChange</code>​</p>
</li>
</ol>
<blockquote>
<p>注意不需要实际创建的一个Peer，这里是先加入到集群当中，Leader发送心跳，转发消息时发现节点不存在，由storeWorker调用maybeCreatePeer()进行实际的创建</p>
</blockquote>
<h3 id="RemoveNode的Apply"><a href="#RemoveNode的Apply" class="headerlink" title="RemoveNode的Apply"></a>RemoveNode的Apply</h3><ol>
<li>如果需要Remove的节点ID与当前节点ID相等，调用<code>d.destroyPeer()</code>​</li>
<li>检查是否是重复的命令，即如果节点已不在集群中，此时跳过apply</li>
<li>修改并写入<code>RegionLocalState</code>​（使用<code>meta.WriteRegionState</code>​），包括<code>RegionEpoch</code>​和<code>Region&#39;s peers</code>​</li>
<li>不用更新<code>GlobalContext storeMeta</code>​，这个是由<code>d.destroyPeer()</code>​完成的</li>
<li>​<code>removePeerCache</code>​，​<code>d.RaftGroup.ApplyConfChange</code>​</li>
</ol>
<p>另外，在完成process后，要检查节点是否停止，因为有可能会销毁当前节点，此时直接返回即可，不需要做后面的任何处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, entry := <span class="keyword">range</span> ready.CommittedEntries &#123;</span><br><span class="line">	d.process(&amp;entry)</span><br><span class="line">	<span class="comment">// may destroy oneself, so need to check if stopped</span></span><br><span class="line">	<span class="keyword">if</span> d.stopped &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于response，按照之前在project2b中相同的处理，我使用自定义的<code>clearStaleAndGetTargetProposal</code>​（详见project2b思路），注意在最后需要调用<code>d.notifyHeartbeatScheduler(region, d.peer)</code>​给Scheduler（project3c）发送一个心跳，来通知region的变化（冗余的更新不会影响正确性，因此建议在发生region修改的地方都发送一个心跳）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.clearStaleAndGetTargetProposal(entry) &#123;</span><br><span class="line">	p := d.proposals[<span class="number">0</span>]</span><br><span class="line">	resp := &amp;raft_cmdpb.RaftCmdResponse&#123;</span><br><span class="line">		Header: &amp;raft_cmdpb.RaftResponseHeader&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> req.CmdType &#123;</span><br><span class="line">	<span class="keyword">case</span> raft_cmdpb.AdminCmdType_ChangePeer:</span><br><span class="line">		resp.AdminResponse = &amp;raft_cmdpb.AdminResponse&#123;</span><br><span class="line">			CmdType:    raft_cmdpb.AdminCmdType_ChangePeer,</span><br><span class="line">			ChangePeer: &amp;raft_cmdpb.ChangePeerResponse&#123;&#125;,</span><br><span class="line">			<span class="comment">// ChangePeer: &amp;raft_cmdpb.ChangePeerResponse&#123;Region: d.Region()&#125;,</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.cb.Done(resp)</span><br><span class="line">	d.proposals = d.proposals[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d.notifyHeartbeatScheduler(region, d.peer)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> notifyHeartbeatScheduler(region *metapb.Region, peer *peer) &#123;</span><br><span class="line">	clonedRegion := <span class="built_in">new</span>(metapb.Region)</span><br><span class="line">	err := util.CloneMsg(region, clonedRegion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	d.ctx.schedulerTaskSender &lt;- &amp;runner.SchedulerRegionHeartbeatTask&#123;</span><br><span class="line">		Region:          clonedRegion,</span><br><span class="line">		Peer:            peer.Meta,</span><br><span class="line">		PendingPeers:    peer.CollectPendingPeers(),</span><br><span class="line">		ApproximateSize: peer.ApproximateSize,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就完成了最基本的confChange，但是不能通过所有测试，由于可能存在网络不稳定和隔离等情况，需要做一些特殊处理和优化，这些处理会在下一篇“tinykv project3b疑难杂症”中汇总。</p>
<h2 id="Region-Split"><a href="#Region-Split" class="headerlink" title="Region Split"></a>Region Split</h2><p>Split命令的Propose过程与ChangePeer也是类似的，不同的是Split命令中包含一个<code>split_key</code>​，代表将当前region按<code>split_key</code>​拆分，因此要检查<strong>ErrKeyNotInRegion。</strong></p>
<blockquote>
<p>之前在project2b中对于普通命令没有对<strong>ErrKeyNotInRegion</strong>检查，此处也需要为除了Snap（Snap命令中不包含key）命令之外的其他普通命令增加检查<strong>ErrKeyNotInRegion</strong>的代码。</p>
</blockquote>
<p>Split命令的Process同样可以分成check、apply、response三步。</p>
<p>对于check，实际上是重复Propose的检查过程，需要检查<strong>ErrEpochNotMatch和ErrKeyNotInRegion。</strong></p>
<h3 id="apply-Split"><a href="#apply-Split" class="headerlink" title="apply Split"></a>apply Split</h3><p>apply的过程则相对复杂，我的实现步骤如下：</p>
<ol>
<li><p>​<code>split := req.GetSplit()</code>​​获取Split命令中的数据，拷贝一份当前节点原始Region信息暂存在<code>rawRegion</code>​​中（利用<code>util.CloneMsg</code>​​方法），原始Region使用<code>leftRegion</code>​​命名，再拷贝一份<code>rightRegion</code>​​，代表拆分后的右半region。</p>
</li>
<li><p>使用<code>split.NewPeerIds</code>​​初始化<code>rightRegion.Peers</code>​​，将<code>split.NewRegionId</code>​​赋值给<code>rightRegion.Id</code>​​，将<code>split.SplitKey</code>​​赋值给<code>rightRegion.StartKey</code>​​，将<code>split.SplitKey</code>​​赋值给<code>leftRegion.EndKey</code>​​，即<code>[StartKey, SplitKey) -&gt; leftRegion</code>​​、<code>[SplitKey, EndKey) -&gt; rightRegion</code>​​。最后不要忘记<code>leftRegion.RegionEpoch.Version += 1</code>​​、<code>rightRegion.RegionEpoch.Version += 1</code>​​。此时<code>leftRegion</code>​​和<code>rightRegion</code>​​对应Split之后的左右Region。（<strong>注意leftRegion继承原始region的所有数据</strong>）</p>
</li>
<li><p>使用<code>meta.WriteRegionState</code>​​写入两个region</p>
</li>
<li><p>更新<code>storeMeta</code>​​，包括：</p>
<ol>
<li>在<code>storeMeta.regionRanges</code>​​中删除<code>rawRegion</code>​​</li>
<li>在<code>storeMeta.regions</code>​​中添加<code>rightRegion</code>​​</li>
<li>使用<code>leftRegion</code>​​和<code>rightRegion</code>​​更新<code>storeMeta.regionRanges</code>​​（调用方法<code>storeMeta.regionRanges.ReplaceOrInsert</code>​​）</li>
<li>注意加锁</li>
</ol>
</li>
<li><p>清理region size，包括<code>SizeDiffHint</code>​和<code>ApproximateSize</code>​，这个很关键，在下一篇疑难杂症也会提到</p>
</li>
<li><p>使用<code>createPeer</code>​​方法创建<code>newPeer</code>​​，利用<code>d.ctx.router</code>​​注册和启动该节点</p>
</li>
</ol>
<p>reponse的过程与ChangePeer类似：</p>
<ol>
<li><code>notifyHeartbeatScheduler</code>​​发送心跳，注意两个Region都要调用</li>
<li>返回响应，还是利用自定义的<code>clearStaleAndGetTargetProposal</code>​​</li>
</ol>
<h2 id="其他修改"><a href="#其他修改" class="headerlink" title="其他修改"></a>其他修改</h2><h3 id="ApplySnapshot后的region状态更新"><a href="#ApplySnapshot后的region状态更新" class="headerlink" title="ApplySnapshot后的region状态更新"></a>ApplySnapshot后的region状态更新</h3><p>应用快照会通常会伴随region的更新（例如未初始化的新节点），<code>SaveReadyState</code>​的返回值中有一个<code>*ApplySnapResult</code>​，如果它不为<code>nil</code>​且其中的<code>PrevRegion</code>​和<code>Region</code>​不相等，说明发生了Region更新，不仅要在内存中更新<code>regionLocalState</code>​以及持久化，还要更新全局的<code>storeMeta</code>​并发送心跳给Scheduler，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := d.peerStorage.SaveReadyState(&amp;ready)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update region</span></span><br><span class="line"><span class="keyword">if</span> result != <span class="literal">nil</span> &amp;&amp; !reflect.DeepEqual(result.PrevRegion, result.Region) &#123;</span><br><span class="line">	d.peerStorage.SetRegion(result.Region)</span><br><span class="line"></span><br><span class="line">	storeMeta := d.ctx.storeMeta</span><br><span class="line">	storeMeta.Lock()</span><br><span class="line">	storeMeta.regions[result.Region.GetId()] = result.Region</span><br><span class="line">	storeMeta.regionRanges.ReplaceOrInsert(&amp;regionItem&#123;region: result.Region&#125;)</span><br><span class="line">	storeMeta.Unlock()</span><br><span class="line"></span><br><span class="line">	d.HeartbeatScheduler(d.ctx.schedulerTaskSender)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通命令的修改"><a href="#普通命令的修改" class="headerlink" title="普通命令的修改"></a>普通命令的修改</h3><p>由于引入了region，对普通命令的propose和process也要做相应修改。</p>
<p>首先就是对Get、Put、Delete检查<strong>ErrEpochNotMatch</strong>​和<strong>ErrKeyNotInRegion。</strong></p>
<p>其次对于Put和Delete命令的应用，需要记录当前region的大小变化，这是通过<code>SizeDiffHint</code>​记录的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> peer <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// An inaccurate difference in region size since last reset.</span></span><br><span class="line">	<span class="comment">// split checker is triggered when it exceeds the threshold, it makes split checker not scan the data very often</span></span><br><span class="line">	<span class="comment">// (Used in 3B split)</span></span><br><span class="line">	SizeDiffHint <span class="type">uint64</span></span><br><span class="line">	<span class="comment">// Approximate size of the region.</span></span><br><span class="line">	<span class="comment">// It&#x27;s updated everytime the split checker scan the data</span></span><br><span class="line">	<span class="comment">// (Used in 3B split)</span></span><br><span class="line">	ApproximateSize *<span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于Put，​<code>d.SizeDiffHint += uint64(len(req.Put.Key) + len(req.Put.Value))</code>​</li>
<li>对于Delete命令，​<code>d.SizeDiffHint -= uint64(len(req.Delete.Key))</code>​</li>
</ol>
<p>在Split中也提到Apply Admin_Split完成后，要对<code>SizeDiffHint</code>​和<code>ApproximateSize</code>​更新。</p>
<blockquote>
<p>如果不做上述处理在测试时会引发Request Timeout。原来split checker会依据<code>SizeDiffHint</code>​来判断region承载的数据量是否超出阈值，从而触发split操作。这在文档中并没有说明，害我调了很久。</p>
</blockquote>
<p>‍</p>
<p>以上就完成了3B的所有基本内容，但测试通常是过不了的，会有很多异常情况，下一篇将对我当时遇到的疑难杂症进行汇总。</p>
<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>tinykv project3c思路</title>
    <url>/2024/05/23/tinykv_project3c_solution/</url>
    <content><![CDATA[<span id="more"></span>

<p>3c要求实现region balance调度器，文档给了详细的算法步骤，相对比较容易。</p>
<h2 id="processRegionHeartbeat"><a href="#processRegionHeartbeat" class="headerlink" title="processRegionHeartbeat"></a>processRegionHeartbeat</h2><p>每个region都会周期性的发送心跳给调度器，调度器需要首先检查RegionEpoch是否是最新的，如果是则进行更新，否则忽略。</p>
<p>检查的逻辑是：</p>
<ol>
<li>如果该心跳对应的region id在调度器中存在，检查心跳中的RegionEpoch是否过时，如果过时则直接返回；</li>
<li>如果该心跳对应的region id在调度器中找不到，扫描调度器中所有与心跳region有重叠的Regions。同样的方法对比RegionEpoch，如果Regions中存在一个region比心跳region新，那么就是过时的。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// processRegionHeartbeat updates the region information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RaftCluster)</span></span> processRegionHeartbeat(region *core.RegionInfo) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (3C).</span></span><br><span class="line">	epoch := region.GetRegionEpoch()</span><br><span class="line">	<span class="keyword">if</span> epoch == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;region has no epoch&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check if the region is in the cluster</span></span><br><span class="line">	rawRegion := c.GetRegion(region.GetID())</span><br><span class="line">	<span class="keyword">if</span> rawRegion != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// check if regionVersion is stale or not</span></span><br><span class="line">		stale := util.IsEpochStale(epoch, rawRegion.GetRegionEpoch())</span><br><span class="line">		<span class="keyword">if</span> stale &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;region is stale&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// scan all regions that overlap with it</span></span><br><span class="line">		overlapRegions := c.ScanRegions(region.GetStartKey(), region.GetEndKey(), <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">for</span> _, oRegion := <span class="keyword">range</span> overlapRegions &#123;</span><br><span class="line">			stale := util.IsEpochStale(epoch, oRegion.GetRegionEpoch())</span><br><span class="line">			<span class="keyword">if</span> stale &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;region is stale&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.putRegion(region)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> region.GetStoreIds() &#123;</span><br><span class="line">		c.updateStoreStatusLocked(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h2><p>region balance调度器目标是让集群中的stores所负载的region数目趋于平衡。一个调度命令通常就是将某个region从一个store移动到另一个store，因此Schedule的逻辑是先找到合适的region和目标store，然后创建一个<code>MovePeerOperator</code>​。详细算法官方文档给的很详细，实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StoreInfoSlice []*core.StoreInfo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StoreInfoSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StoreInfoSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StoreInfoSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i].GetRegionSize() &gt; s[j].GetRegionSize() &#125; <span class="comment">// 降序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *balanceRegionScheduler)</span></span> Schedule(cluster opt.Cluster) *operator.Operator &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (3C).</span></span><br><span class="line">	maxStoreDownTime := cluster.GetMaxStoreDownTime()</span><br><span class="line">	<span class="comment">// // Get suitable stores.</span></span><br><span class="line">	source := cluster.GetStores()</span><br><span class="line">	suitableStores := <span class="built_in">make</span>([]*core.StoreInfo, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, store := <span class="keyword">range</span> source &#123;</span><br><span class="line">		<span class="keyword">if</span> store.IsUp() &amp;&amp; store.DownTime() &lt; maxStoreDownTime &#123;</span><br><span class="line">			suitableStores = <span class="built_in">append</span>(suitableStores, store)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(suitableStores) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sort stores by regionSize.</span></span><br><span class="line">	sort.Sort(StoreInfoSlice(suitableStores))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scan suitableStores to find the best store to move region from.</span></span><br><span class="line">	<span class="keyword">var</span> fromStore, toStore *core.StoreInfo</span><br><span class="line">	<span class="keyword">var</span> region *core.RegionInfo</span><br><span class="line">	<span class="keyword">for</span> _, store := <span class="keyword">range</span> suitableStores &#123;</span><br><span class="line">		<span class="keyword">var</span> regions core.RegionsContainer</span><br><span class="line">		cluster.GetPendingRegionsWithLock(store.GetID(), <span class="function"><span class="keyword">func</span><span class="params">(rc core.RegionsContainer)</span></span> &#123; regions = rc &#125;)</span><br><span class="line">		region = regions.RandomRegion(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> region != <span class="literal">nil</span> &#123;</span><br><span class="line">			fromStore = store</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		cluster.GetFollowersWithLock(store.GetID(), <span class="function"><span class="keyword">func</span><span class="params">(rc core.RegionsContainer)</span></span> &#123; regions = rc &#125;)</span><br><span class="line">		region = regions.RandomRegion(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> region != <span class="literal">nil</span> &#123;</span><br><span class="line">			fromStore = store</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		cluster.GetLeadersWithLock(store.GetID(), <span class="function"><span class="keyword">func</span><span class="params">(rc core.RegionsContainer)</span></span> &#123; regions = rc &#125;)</span><br><span class="line">		region = regions.RandomRegion(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> region != <span class="literal">nil</span> &#123;</span><br><span class="line">			fromStore = store</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> region == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	storeIds := region.GetStoreIds()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(storeIds) &lt; cluster.GetMaxReplicas() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scan suitableStores again to find the best store to move region to.</span></span><br><span class="line">	<span class="comment">// the best store is the one with the smallest regionSize.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(suitableStores) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := storeIds[suitableStores[i].GetID()]; !ok &#123;</span><br><span class="line">			toStore = suitableStores[i]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> toStore == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if diff &lt; 2*ApproximateSize, give up.</span></span><br><span class="line">	<span class="keyword">if</span> fromStore.GetRegionSize()-toStore.GetRegionSize() &lt; <span class="number">2</span>*region.GetApproximateSize() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create operator</span></span><br><span class="line">	newPeer, _ := cluster.AllocPeer(toStore.GetID())</span><br><span class="line">	op, _ := operator.CreateMovePeerOperator(<span class="string">&quot;balance-region&quot;</span>, cluster, region, operator.OpBalance, fromStore.GetID(), toStore.GetID(), newPeer.GetId())</span><br><span class="line">	<span class="keyword">return</span> op</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>Tinykv，启~动！！</title>
    <url>/2024/05/01/tinykv_start/</url>
    <content><![CDATA[<p>前段时间磕磕绊绊学习了Tinykv这个项目，通过所有测试就没再理了，现在觉得不能把工夫浪费了，因此写个Blog记录一下。</p>
<h2 id="什么是Tinykv？"><a href="#什么是Tinykv？" class="headerlink" title="什么是Tinykv？"></a>什么是Tinykv？</h2><p>Tinykv是PingCAP推出的一个学习分布式系统的课程，这个公司在存储领域很厉害，比较著名的产品是TiDB。</p>
<p>Tinykv这个课程的具体内容是使用Raft共识算法构建一个具有分布式事务支持的键值存储系统，它提供了一些骨架代码，我们只需要填充其中的一些核心逻辑，例如Raft层实现共识，RaftStore实现消息处理等等。</p>
<p>整个课程有4个Project，分别为StandaloneKv、raftKv、MuiltiRaftKv、Transactions，整体难度上：porject3 &gt; project2 &gt;&gt; project4 &gt; project1。其中project2B和project3B是两个分水岭，一般都会Bug满天飞，需要打印详细的日志仔细地跟踪，并且有的Bug复现概率较低，要反复跑好几次，因此要坚持下来需要一定的毅力。</p>
<p>如果集中精力做的话，我了解到的几个同学都是暑假一个月不到的时间就完成了，整体代码量也不多，就是测试修Bug比较折磨。我当时还有学业上的别的事情，并没有太多的精力集中搞这个，从开始到完成花了有三个月，期间也是卡在2B和3B摆烂了很久。不过所幸是坚持到了最后。</p>
<p>如果时间凑巧的话，还可以报名PingCAP定期举办的tinykv学习营（<a href="https://tidb.net/talent-plan">Talent Plan | TiDB 社区</a>），能起到一定的督促作用，还能与其他同学交流经验心得，可以少踩很多坑。</p>
<p>整个课程做下来能够学到的东西还是挺多的，例如raft共识算法、分布式系统架构、多版本并发控制等等，对于想走存储、分布式系统方向的同学还是很有用处的。</p>
<p>‍</p>
<h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p>github仓库</p>
<p><a href="https://github.com/talent-plan/tinykv">talent-plan&#x2F;tinykv：基于 TiKV 模型构建分布式键值服务的课程 (github.com)</a></p>
<p>讲解视频</p>
<p><a href="https://learn.pingcap.com/learner/course/510001">Talent Plan 2021 KV 学习营分享课 (pingcap.com)</a></p>
<p>很有帮助的文章，Tinykv白皮书</p>
<p><a href="https://zhuanlan.zhihu.com/p/457696758">如何快速通关 Talent Plan TinyKV？ - 知乎 (zhihu.com)</a></p>
<p>‍</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>tinykv对硬件稍微有点要求，否则跑得太慢又Bug满天飞心态很容易炸。我是使用14核处理器，32GB内存，SSD固态的笔记本，搭配wsl2的linux环境，运行起来非常流畅。固态据说是刚需，其他感觉与这差不多的配置或者低一点也没关系。非常推荐使用wsl，可以直接连接vscode非常快，环境配起来也嘎嘎轻松；用虚拟机也可以，不过我感觉有点慢。有配置好服务器的话更好，可以一直挂着跑。</p>
<p>附上我当时配置wsl2参考的博客</p>
<p><a href="https://blog.csdn.net/syqkali/article/details/131524540">如何在Windows11上安装WSL2的Ubuntu22.04（包括换源）_wsl2换源_syqkali的博客-CSDN博客</a></p>
<p>由于项目用go实现，所以也要配置golang的运行环境，项目里还用到了make，我这里直接用apt安装即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">apt search golang-go</span><br><span class="line">sudo apt install golang-go</span><br><span class="line">go version </span><br><span class="line">sudo apt install make</span><br></pre></td></tr></table></figure>

<p>接着从github仓库下载源码，得到的就是只有骨架代码的版本了。</p>
<p>​<code>git clone https://github.com/talent-plan/tinykv.git</code>​</p>
<p>建议在github上创建一个私有仓库来维护代码，这样就知道在哪些地方做了修改，并且可以很方便地恢复了。</p>
<p>‍</p>
<h2 id="快速掌握Go语言基本语法"><a href="#快速掌握Go语言基本语法" class="headerlink" title="快速掌握Go语言基本语法"></a>快速掌握Go语言基本语法</h2><p>如果对Go语言的基本语法不熟悉，可以通过以下链接的教程快速掌握，对于Tinykv已经足够了。</p>
<p><a href="https://tour.go-zh.org/welcome/1">Go 语言之旅 (go-zh.org)</a></p>
<p>‍</p>
<h2 id="Tinykv快速上手"><a href="#Tinykv快速上手" class="headerlink" title="Tinykv快速上手"></a>Tinykv快速上手</h2><p>tinykv根目录下的doc目录存放了四个project的说明文档。文档是全英文的（如果英文不是很好的话，可以先找中文翻译了解一下大体的框架，细节上还是要看英文，有些翻译得不准会造成误解），文档介绍了每个项目的要实现的具体功能和一些细节上的要求，不过整体上文档还是不够全面，很多功能需要仔细阅读它的骨架代码才能实现。</p>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>每个project所要编写的代码的位置都给出了注释提示，可以通过grep命令找到需要编写代码的地方。</p>
<p>以project1为例，可以使用命令<code>grep -rIi &quot;Your Code Here(1)&quot;</code>​，来查找project1的项目文件以及需要编写代码的地方，主要的函数名和参数返回值都已经定义好了，只要填充其中的逻辑即可。注意project1之后的234都分成了A、B、C三部分，这时查找则是例如<code>grep -rIi &quot;Your Code Here(2A)&quot;</code>​这样。</p>
<p>​​<img src="/2024/05/01/tinykv_start/image-20240501155452-w7ey5c1.png" alt="image">​</p>
<p>当然虽然给出了主要的函数名和参数返回值，在project2和3还是要增加很多自定义的函数。</p>
<h3 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h3><p><code>make projectxxx</code></p>
<p>project2b、2c、3b、3c测试一遍是不够的，需要跑很多次才能复现一些Bug，可以使用shell脚本批量跑。</p>
<p>下面是我使用的测试脚本，只需要改运行次数times和project，removelog是在PASS的情况下删除日志。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># settings to change</span></span><br><span class="line"><span class="built_in">times</span>=20</span><br><span class="line">project=<span class="string">&quot;2b&quot;</span></span><br><span class="line">removelog=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># don&#x27;t change</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;./test_output&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="string">&quot;./test_output&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">logdir=<span class="string">&quot;./test_output/<span class="variable">$&#123;project&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$logdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$logdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">lastdir=<span class="string">&quot;<span class="variable">$&#123;logdir&#125;</span>/`date +%Y%m%d%H%M%S`&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$lastdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$lastdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">summary=<span class="string">&quot;<span class="variable">$&#123;lastdir&#125;</span>/summary.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;times pass fail panic runtime&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">totalpass=0</span><br><span class="line">totalfail=0</span><br><span class="line">totalpanic=0</span><br><span class="line">totalruntime=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$times</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    logfile=<span class="string">&quot;<span class="variable">$&#123;lastdir&#125;</span>/<span class="variable">$i</span>.log&quot;</span></span><br><span class="line">    start=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;make project<span class="variable">$&#123;project&#125;</span> <span class="variable">$i</span> times&quot;</span></span><br><span class="line">    make project<span class="variable">$&#123;project&#125;</span> &gt;&gt; <span class="variable">$logfile</span></span><br><span class="line">    end=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    pass_count=$(grep -i <span class="string">&quot;PASS&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;pass count: <span class="variable">$pass_count</span>&quot;</span></span><br><span class="line">    fail_count=$(grep -i <span class="string">&quot;fail&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;fail count: <span class="variable">$fail_count</span>&quot;</span></span><br><span class="line">    panic_count=$(grep -i <span class="string">&quot;panic&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;panic count: <span class="variable">$panic_count</span>&quot;</span></span><br><span class="line">    runtime=$((end-start))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span> <span class="variable">$pass_count</span> <span class="variable">$fail_count</span> <span class="variable">$panic_count</span> <span class="variable">$runtime</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">    totalpass=$((totalpass+pass_count))</span><br><span class="line">    totalfail=$((totalfail+fail_count))</span><br><span class="line">    totalpanic=$((totalpanic+panic_count))</span><br><span class="line">    totalruntime=$((totalruntime+runtime))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if pass, remove the log</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$removelog</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$panic_count</span> -lt 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">rm</span> <span class="variable">$logfile</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;total <span class="variable">$totalfail</span> <span class="variable">$totalpanic</span> <span class="variable">$totalruntime</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br></pre></td></tr></table></figure>
<p>Project2B、2C、3B的测试时间比较长，有时只需要解决某一个测试点的Bug，没必要跑所有的测试点浪费时间。可以用命令<code>GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitConfChangeSnapshotUnreliableRecover3B|| true</code>来运行单个测试点。</p>
<p>下面是我使用的单测试点的测试脚本，注意要改title和中间的测试命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># settings to change</span></span><br><span class="line">project=<span class="string">&quot;3b&quot;</span></span><br><span class="line">removelog=1</span><br><span class="line"><span class="built_in">times</span>=50</span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeRemoveLeader3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestSplitRecoverManyClients3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeRecoverManyClients3B&quot;</span></span><br><span class="line">title=<span class="string">&quot;TestSplitConfChangeSnapshotUnreliableRecover3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeRemoveLeader3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeSnapshotUnreliableRecover3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestSplitConfChangeSnapshotUnreliableRecoverConcurrentPartition3B&quot;</span></span><br><span class="line"><span class="comment"># title=&quot;TestConfChangeUnreliableRecover3B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no change below this line</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;./test_output&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="string">&quot;./test_output&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">logdir=<span class="string">&quot;test_output/<span class="variable">$project</span>/<span class="variable">$title</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$logdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$logdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">lastdir=<span class="string">&quot;<span class="variable">$logdir</span>/`date +%Y%m%d%H%M%S`&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$lastdir</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$lastdir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">summary=<span class="string">&quot;<span class="variable">$lastdir</span>/summary.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;times pass fail panic runtime panicinfo&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">totalpass=0</span><br><span class="line">totalfail=0</span><br><span class="line">totalpanic=0</span><br><span class="line">totalruntime=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 <span class="variable">$times</span>)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    logfile=<span class="string">&quot;<span class="variable">$&#123;lastdir&#125;</span>/<span class="variable">$i</span>.log&quot;</span></span><br><span class="line">    start=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;start <span class="variable">$i</span> times&quot;</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRemoveLeader3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitRecover3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRemoveLeader3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitRecoverManyClients3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRecoverManyClients3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    (GO111MODULE=on go <span class="built_in">test</span> -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitConfChangeSnapshotUnreliableRecover3B|| <span class="literal">true</span>) &gt;&gt; <span class="variable">$logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeRemoveLeader3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeSnapshotUnreliableRecover3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestSplitConfChangeSnapshotUnreliableRecoverConcurrentPartition3B|| true) &gt;&gt; $logfile</span></span><br><span class="line">    <span class="comment"># (GO111MODULE=on go test -v --count=1 --parallel=1 -p=1 ./kv/test_raftstore -run ^TestConfChangeUnreliableRecover3B|| true) &gt;&gt; $logfile</span></span><br><span class="line"></span><br><span class="line">    end=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    pass_count=$(grep -i <span class="string">&quot;PASS&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;pass count: <span class="variable">$pass_count</span>&quot;</span></span><br><span class="line">    fail_count=$(grep -i <span class="string">&quot;fail&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;fail count: <span class="variable">$fail_count</span>&quot;</span></span><br><span class="line">    panic_count=$(grep -i <span class="string">&quot;panic&quot;</span> <span class="variable">$logfile</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;panic count: <span class="variable">$panic_count</span>&quot;</span></span><br><span class="line">    runtime=$((end-start))</span><br><span class="line"></span><br><span class="line">    panic_info=$(grep -m 1 -i <span class="string">&quot;panic&quot;</span> <span class="variable">$logfile</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span> <span class="variable">$pass_count</span> <span class="variable">$fail_count</span> <span class="variable">$panic_count</span> <span class="variable">$runtime</span> <span class="variable">$panic_info</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br><span class="line"></span><br><span class="line">    totalpass=$((totalpass+pass_count))</span><br><span class="line">    totalfail=$((totalfail+fail_count))</span><br><span class="line">    totalpanic=$((totalpanic+panic_count))</span><br><span class="line">    totalruntime=$((totalruntime+runtime))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if pass, remove the log</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$removelog</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$pass_count</span> -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">rm</span> <span class="variable">$logfile</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;total <span class="variable">$totalfail</span> <span class="variable">$totalpanic</span> <span class="variable">$totalruntime</span>&quot;</span> &gt;&gt; <span class="variable">$summary</span></span><br></pre></td></tr></table></figure>

<h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><p>打印日志非常重要，尤其是对于跟踪Project2B、2C、3B中的Bug。</p>
<p>可以在<code>log/log.go</code>​的末尾增加以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> debug_raft = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> debug_raftStore = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DPrintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> debug &gt; <span class="number">0</span> &#123;</span><br><span class="line">		_log.Infof(format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DPrintfRaft</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> debug_raft &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;[Raft]: &quot;</span>+format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DPrintfRaftStore</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> debug_raftStore &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;[RaftStore]: &quot;</span>+format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>debug_xxx</code>​改为大于0之后，在需要打印日志的地方调用<code>log.DPrintfxxx</code>​即可。</p>
<p>我这里分了三种日志类型，最重要的是<code>Raft</code>​和<code>RaftStore</code>​，分别对应Raft层的日志和RaftStore的日志，这样做的好处是面对海量的日志能够很容易找到哪个模块的代码出了问题，也可以很轻松过地关闭一个模块的日志减少干扰。</p>
<p>‍</p>
<h2 id="Tinykv架构"><a href="#Tinykv架构" class="headerlink" title="Tinykv架构"></a>Tinykv架构</h2><p>在正式编码之前，我们可以大致了解一下Tinykv的架构，这里我直接结合官方的图大致来讲一下自己的理解。</p>
<p>​<img src="/2024/05/01/tinykv_start/image-20240501170434-8r9kv28.png" alt="image">​</p>
<p>Tinykv只关注分布式数据库系统的存储层，可以处理响应来自SQL层的RPC请求，同时还有一个TinyScheduler组件作为整个Tinykv集群的控制中心，从Tinykv的心跳中收集信息，负责一些调度工作，向Tinykv节点发送调度命令以实现负载均衡（project 3c）等等功能。</p>
<p>自下而上解析Tinykv的组成：</p>
<ol>
<li><p>Engine，即kv存储引擎，是实际存储kv的地方。在Tinykv中使用的是badgerDB，使用了两个DB实例：kv和raftkv，分别用于存储实际的kv数据和raft日志，当然还分别存储了一些状态数据。</p>
</li>
<li><p>Storage，我理解为分布式逻辑层，这里分为了Standalone Storage和RaftStorage</p>
<ol>
<li><p>Standalone Storage对应project1，在badgerDB的API基础上封装了列族（可以理解为给每个key加上了前缀以实现分类），这是为了在后面project4中实现事务机制。</p>
</li>
<li><p>RaftStorage：project2和3的重点。负责了请求的处理和响应。包括了Raft层和Raft层之上的逻辑<strong>RaftStore</strong></p>
<ol>
<li>Raft层用于接收来自上层的Raft日志，实现共识算法，会定期给上层反馈已经提交的日志和要转发的消息等等。</li>
<li>RaftStore则负责消息的封装和路由（分发到raft节点）、raft日志的持久化和命令的应用等等，比较复杂。</li>
</ol>
</li>
</ol>
</li>
<li><p>server，接收RPC调用和响应，实现MVCC（多版本并发控制）和封装事务性API，对应project4</p>
</li>
</ol>
<p>‍</p>
<p>项目目录：</p>
<ul>
<li>​<code>kv</code>​包含键值存储的实现。</li>
<li>​<code>raft</code>​包含 Raft 共识算法的实现。</li>
<li>​<code>scheduler</code>​包含 TinyScheduler 的实现，该实现负责管理 TinyKV 节点和生成时间戳。</li>
<li>​<code>proto</code>​包含节点和进程之间所有通信的实现，使用基于 gRPC 的协议缓冲区。此包包含 TinyKV 使用的协议定义，以及您可以使用的生成的 Go 代码。</li>
<li>​<code>log</code>​包含基于级别输出日志的实用程序。</li>
</ul>
<p>‍</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了上述的一些准备之后就可以开始攻克Tinykv的各个project了，万事开头难，这也是我正儿八经的第一篇博客，后续会更新四个project的思路和踩的一些坑。由于缺乏有关分布式系统的很多知识，理解上可能会有很多谬误和遗漏，欢迎多多提问和指正。</p>
<p>Tinykv 启~动！</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>kv</tag>
        <tag>分布式系统</tag>
        <tag>raft</tag>
      </tags>
  </entry>
</search>
